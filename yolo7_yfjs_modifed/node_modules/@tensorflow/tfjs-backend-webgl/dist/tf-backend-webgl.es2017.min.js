/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf)}(this,(function(e,t){"use strict";function n(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var a=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,a.get?a:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,t}var a=n(t);const r={},o={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function i(e,t){r[e]=t}function s(e,t){if(!(e in r)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;if(n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete r[e]}),!1),1===e)return n.getContext("webgl",o)||n.getContext("experimental-webgl",o);return n.getContext("webgl2",o)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;r[e]=n}const n=r[e];return null==n||n.isContextLost()?(delete r[e],s(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),r[e])}var u,l,c;function d(e,t){return[t,e]}function p(e){const n=t.util.sizeFromShape(e),a=Math.ceil(n/4);return t.util.sizeToSquarishShape(a)}function h(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function f(e,n){const a=e;let r,o,i,s,u,l,c,d,p,h;return 2===t.env().getNumber("WEBGL_VERSION")?(r=a.R32F,o=a.R16F,i=a.RGBA16F,s=a.RGBA32F,u=a.RED,c=4,d=1,p=a.HALF_FLOAT,h=a.FLOAT,l=a.RGBA8):(r=e.RGBA,o=e.RGBA,i=e.RGBA,s=a.RGBA,u=e.RGBA,c=4,d=4,p=null!=n?n.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:s,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:h}}function x(e,n){const a=n();return t.env().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+g(e,t))}(e),a}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(u||(u={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(l||(l={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(c||(c={}));function m(e){return!!(t.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function g(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function b(e,t){return V(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function v(e,t){const n=V(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(x(e,(()=>e.shaderSource(n,t))),x(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function C(e,n){const a=V(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(x(e,(()=>e.shaderSource(a,n))),x(e,(()=>e.compileShader(a))),t.env().get("ENGINE_COMPILE_ONLY"))return a;if(!1===e.getShaderParameter(a,e.COMPILE_STATUS))throw I(n,e.getShaderInfoLog(a)),new Error("Failed to compile fragment shader.");return a}const $=/ERROR: [0-9]+:([0-9]+):/g;function I(e,n){const a=$.exec(n);if(null==a)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(e);const r=+a[1],o=e.split("\n"),i=o.length.toString().length+2,s=o.map(((e,n)=>t.util.rightPad((n+1).toString(),i)+e));let u=0;for(let e=0;e<s.length;e++)u=Math.max(s[e].length,u);const l=s.slice(0,r-1),c=s.slice(r-1,r),d=s.slice(r);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${t.util.rightPad(c[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function k(e){return V(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function y(e,n){if(x(e,(()=>e.linkProgram(n))),!t.env().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function S(e,t){if(x(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function w(e,t){const n=V(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),x(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function R(e,t){const n=V(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return x(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),x(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function T(e){return V(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function E(e,n){const a=t.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0){throw new Error("Requested texture size "+`[${e}x${n}]`+" is invalid.")}if(e>a||n>a){throw new Error("Requested texture size "+`[${e}x${n}]`+" greater than WebGL maximum on this browser / GPU "+`[${a}x${a}]`+".")}}function N(e){return V(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function A(e,t,n,a,r,o,i){const s=e.getAttribLocation(t,n);return-1!==s&&(x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),x(e,(()=>e.vertexAttribPointer(s,r,e.FLOAT,!1,o,i))),x(e,(()=>e.enableVertexAttribArray(s))),!0)}function F(e,t,n){W(e,n),x(e,(()=>e.activeTexture(e.TEXTURE0+n))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function _(e,t,n){return V(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function O(e,t,n){return e.getUniformLocation(t,n)}function D(e,t,n,a){x(e,(()=>F(e,t,a))),x(e,(()=>e.uniform1i(n,a)))}function P(e,t,n){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),x(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function L(e,t){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),x(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function B(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+U(e,t))}function U(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function V(e,t,n){const a=x(e,(()=>t()));if(null==a)throw new Error(n);return a}function W(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function M(e,n=2){return t.util.sizeFromShape(e.slice(0,e.length-n))}function G(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function z(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[M(e),...G(e)]),t}function X(e,n=!1){let a=t.env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n&&(a*=2,1===(e=e.map(((n,a)=>a>=e.length-2?t.util.nearestLargerEven(e[a]):e[a]))).length&&(e=[2,e[0]])),2!==e.length){const n=t.util.squeezeShape(e);e=n.newShape}let r=t.util.sizeFromShape(e);if(e.length<=1&&r<=a)return[1,r];if(2===e.length&&e[0]<=a&&e[1]<=a)return e;if(3===e.length&&e[0]*e[1]<=a&&e[2]<=a)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=a&&e[1]*e[2]<=a)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=a&&e[3]<=a)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=a&&e[1]*e[2]*e[3]<=a)return[e[0],e[1]*e[2]*e[3]];if(n){const n=M(e);let a=2,o=2;return e.length&&([a,o]=G(e)),r=n*(a/2)*(o/2),t.util.sizeToSquarishShape(r).map((e=>2*e))}return t.util.sizeToSquarishShape(r)}function H(e){return e%2==0}function j(e,n){if(e=e.slice(-2),n=n.slice(-2),t.util.arraysEqual(e,n))return!0;if(!e.length||!n.length)return!0;if(0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){const t=e.slice(-1)[0],a=n.slice(-1)[0];if(t===a)return!0;if(H(t)&&H(a)&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&H(e[0])&&H(n[0])}let K,q;function Y(e){if(null==K){const t=s(e);K=t.getParameter(t.MAX_TEXTURE_SIZE)}return K}function Q(e){if(null==q){const t=s(e);q=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,q)}function Z(e){if(0===e)return 0;let t;const n=s(e);return t=J(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:J(n,"EXT_disjoint_timer_query")?1:0,t}function J(e,t){return null!=e.getExtension(t)}function ee(e){try{if(null!=s(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function te(e){if(0===e)return!1;const t=s(e);if(1===e){if(!J(t,"OES_texture_float"))return!1}else if(!J(t,"EXT_color_buffer_float"))return!1;return ae(t)}function ne(e){if(0===e)return!1;const t=s(e);if(1!==e){if(J(t,"EXT_color_buffer_float"))return ae(t);const e="EXT_color_buffer_half_float";if(J(t,e)){const n=t.getExtension(e);return function(e,t){const n=f(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(i),s}(t,n)}return!1}if(!J(t,"OES_texture_float"))return!1;if(!J(t,"WEBGL_color_buffer_float"))return!1;return ae(t)}function ae(e){const t=f(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function re(e){if(2!==e)return!1;return null!=s(e).fenceSync}function oe(e,n){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&t.util.assert("complex64"!==e.dtype,(()=>`${n} does not support complex64 tensors in the WebGL backend.`))}))}var ie={__proto__:null,callAndCheck:x,canBeRepresented:m,getWebGLErrorMessage:g,getExtensionOrThrow:b,createVertexShader:v,createFragmentShader:C,logShaderSourceAndInfoLog:I,createProgram:k,linkProgram:y,validateProgram:S,createStaticVertexBuffer:w,createStaticIndexBuffer:R,getNumChannels:function(){return 2===t.env().getNumber("WEBGL_VERSION")?1:4},createTexture:T,validateTextureSize:E,createFramebuffer:N,bindVertexBufferToProgramAttribute:A,bindTextureUnit:F,unbindTextureUnit:function(e,t){W(e,t),x(e,(()=>e.activeTexture(e.TEXTURE0+t))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))},getProgramUniformLocationOrThrow:_,getProgramUniformLocation:O,bindTextureToProgramUniformSampler:D,bindCanvasToFramebuffer:function(e){x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),x(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),x(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))},bindColorTextureToFramebuffer:P,unbindColorTextureFromFramebuffer:L,validateFramebuffer:B,getFramebufferErrorMessage:U,getBatchDim:M,getRowsCols:G,getShapeAs3D:z,getTextureShapeFromLogicalShape:X,isReshapeFree:j,getWebGLMaxTextureSize:Y,resetMaxTextureSize:function(){K=null},resetMaxTexturesInShader:function(){q=null},getMaxTexturesInShader:Q,getWebGLDisjointQueryTimerVersion:Z,hasExtension:J,isWebGLVersionEnabled:ee,isCapableOfRenderingToFloatTexture:te,isDownloadFloatTextureEnabled:ne,isWebGLFenceEnabled:re,assertNotComplex:oe};const se=t.env();function ue(){let e,n,a,r,o,i,s,u,l,c;return 2===t.env().getNumber("WEBGL_VERSION")?(e="#version 300 es",n="in",a="out",r="in",o="texture",i="outputColor",s="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",n="attribute",a="varying",r="varying",o="texture2D",i="gl_FragColor",s="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:n,varyingVs:a,varyingFs:r,texture2D:o,output:i,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function le(e,n,a="index"){const r=t.util.computeStrides(n);return r.map(((t,n)=>`${`int ${e[n]} = ${a} / ${t}`}; ${n===r.length-1?`int ${e[n+1]} = ${a} - ${e[n]} * ${t}`:`index -= ${e[n]} * ${t}`};`)).join("")}function ce(e,n,a="index"){const r=t.util.computeStrides(n);return r.map(((t,n)=>`${`int ${e[n]} = ${a} / outShapeStrides[${n}]`}; ${n===r.length-1?`int ${e[n+1]} = ${a} - ${e[n]} * outShapeStrides[${n}]`:`index -= ${e[n]} * outShapeStrides[${n}]`};`)).join("")}function de(e,t,n="index"){const a=function(e,t){const n=e.length,a=e.map((e=>`${t}[${e}]`)),r=new Array(n-1);r[n-2]=a[n-1];for(let e=n-3;e>=0;--e)r[e]=`(${r[e+1]} * ${a[e+1]})`;return r}(e.map(((e,t)=>t)),t);return a.map(((t,r)=>`${`int ${e[r]} = ${n} / ${a[r]}`}; ${r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`};`)).join("")}function pe(e){const n=t.util.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}se.registerFlag("HAS_WEBGL",(()=>se.getNumber("WEBGL_VERSION")>0)),se.registerFlag("WEBGL_VERSION",(()=>ee(2)?2:ee(1)?1:0)),se.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),se.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===se.get("WEBGL_VERSION"))),se.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),se.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),se.registerFlag("WEBGL_PACK",(()=>se.getBool("HAS_WEBGL"))),se.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_PACK_CLIP",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_PACK_REDUCE",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_LAZILY_UNPACK",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_CONV_IM2COL",(()=>se.getBool("WEBGL_PACK"))),se.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>Y(se.getNumber("WEBGL_VERSION")))),se.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>Q(se.getNumber("WEBGL_VERSION")))),se.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=se.getNumber("WEBGL_VERSION");return 0===e?0:Z(e)})),se.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>se.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!t.device_util.isMobile())),se.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>te(se.getNumber("WEBGL_VERSION")))),se.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!se.getBool("WEBGL_FORCE_F16_TEXTURES")&&se.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),se.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>ne(se.getNumber("WEBGL_VERSION")))),se.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>re(se.getNumber("WEBGL_VERSION")))),se.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>se.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),se.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),se.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>t.device_util.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),se.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),se.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),se.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),se.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));const he="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:fe}=t.backend_util;function xe(e,n,a){const r=[];if(e.forEach((e=>{const n=t.util.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${n>1?`[${n}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),a.enableShapeUniforms){const{uniformShape:t}=we(a.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),a.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}a.customUniforms&&a.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const o=r.join("\n"),i=e.map((e=>function(e,n,a=!1,r){let o="";o+=a?ge(e,r):me(e,r);const i=e.shapeInfo.logicalShape,s=n.logicalShape;i.length<=s.length&&(o+=a?function(e,n){const a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),o="get"+r+"AtOutCoords",i=e.shapeInfo.logicalShape.length,s=n.logicalShape.length,u=fe(e.shapeInfo.logicalShape,n.logicalShape),l=Se(s),c=s-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":s<2&&u.length>=1?"coords = 0;":u.map((e=>`coords.${p[e+c]} = 0;`)).join("\n");let h="";h=s<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+c]}`)).join(", ");let f="return outputValue;";const x=1===t.util.sizeFromShape(e.shapeInfo.logicalShape),m=1===t.util.sizeFromShape(n.logicalShape);if(1!==i||x||m){if(x&&!m)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){const e=i-2,t=i-1;u.indexOf(e)>-1&&u.indexOf(t)>-1?f="return vec4(outputValue.x);":u.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(t)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(e,n):function(e,n){const a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),o="get"+r+"AtOutCoords",i=n.texShape,s=e.shapeInfo.texShape,u=e.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!e.shapeInfo.isUniform&&u===l&&null==e.shapeInfo.flatOffset&&t.util.arraysEqual(s,i))return`\n      float ${o}() {\n        return sampleTexture(${a}, resultUV);\n      }\n    `;const c=Se(l),d=fe(e.shapeInfo.logicalShape,n.logicalShape),p=l-u;let h;const f=["x","y","z","w","u","v"];h=0===u?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${f[e+p]} = 0;`)).join("\n");let x="";x=l<2&&u>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${f[t+p]}`)).join(", ");return`\n    float ${o}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${r}(${x});\n    }\n  `}(e,n));return o}(e,n,a.packedInputs,a.enableShapeUniforms))).join("\n"),s=n.texShape,u=ue(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,d,p=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${be}\n    ${ve}\n    ${Ce}\n  `}(u);n.isPacked?(c=function(e,n,a){switch(e.length){case 0:return Ie();case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${a[1]}.0);\n      }\n    `;if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${a[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);\n    }\n  `}(0,n,a);case 2:return function(e,n,a){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(t.util.arraysEqual(e,n))return a?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const o=Math.ceil(e[1]/2);if(a)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,n,a);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,n,a);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let i=o,s="",u="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],s=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+s,u=`b${t}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      ${s}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,n,a)}}(n.logicalShape,s,a.enableShapeUniforms),d=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,n,a){switch(e.length){case 0:return Ie();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,n,a);case 2:return function(e,n,a){if(t.util.arraysEqual(e,n))return a?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;if(1===e[1])return a?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return a?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(a)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,n,a);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${ce(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const a=le(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec3(r, c, d);\n    }\n  `}(e,n,a);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${ce(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const a=le(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,n,a);case 5:return function(e,t){const n=le(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,n);case 6:return function(e,t){const n=le(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(n.logicalShape,s,a.enableShapeUniforms),d=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),a.packedInputs&&(p+=$e);return[p,l,d,o,c,i,a.userCode].join("\n")}function me(e,n=!1){const a=e.shapeInfo.logicalShape;switch(a.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return`\n      float ${a}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=ke(n);if(t)return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[s,u]=e.shapeInfo.texShape;return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${s}, ${u}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,n);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${a}(int index) {\n        ${ye(e)}\n      }\n    `;const r=e.shapeInfo.texShape,o=r[0],i=r[1];if(1===i&&1===o)return`\n      float ${a}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const s=ke(n);if(1===i)return t?`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${o}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===o)return t?`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape;if(null!=i&&t.util.arraysEqual(a,i)){if(n)return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=i[0];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:s,keptDims:u}=t.util.squeezeShape(a),l=s;if(l.length<a.length){const t=["row","col"];return`\n      ${me(Re(e,l),n)}\n      float ${o}(int row, int col) {\n        return ${o}(${Te(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${a[1]}, 1)));\n        ${ye(e)}\n      }\n    `;const c=i[0],d=i[1],p=ke(r);if(1===d)return n?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${a[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===c)return n?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${a[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(n)return`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${a[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,n);case 3:return function(e,n){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=a[1]*a[2],s=a[2],{newShape:u,keptDims:l}=t.util.squeezeShape(a),c=u;if(c.length<a.length){const t=["row","col","depth"];return`\n        ${me(Re(e,c),n)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${Te(t,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${s}, 1)));\n        ${ye(e)}\n      }\n    `;const d=e.shapeInfo.texShape,p=d[0],h=d[1],f=e.shapeInfo.flatOffset;if(h===i&&null==f)return n?`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${s}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===s&&null==f)return n?`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${a[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const x=ke(r);if(n)return`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${i} + col * ${s} + depth + ${x};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${s} + depth + ${x};\n        vec2 uv = uvFromFlat(${p}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,n);case 4:return function(e,n){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=a[3],s=a[2]*i,u=a[1]*s,{newShape:l,keptDims:c}=t.util.squeezeShape(a);if(l.length<a.length){const t=["row","col","depth","depth2"];return`\n      ${me(Re(e,l),n)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${Te(t,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${u}, ${s}, ${i}, 1)));\n        ${ye(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1],x=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===u&&null==d)return n?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${x}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===i&&null==d)return n?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${a[1]*a[2]}, ${a[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const b=ke(r);if(n)return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${x}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${s} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,n);case 5:return function(e){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=n[4],i=n[3]*o,s=n[2]*i,u=n[1]*s,{newShape:l,keptDims:c}=t.util.squeezeShape(n);if(l.length<n.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${me(Re(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Te(t,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${s}, ${i}, ${o})) +\n          depth3;\n        ${ye(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===u&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${s}, ${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;const x=ke(a);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${s} + depth * ${i} +\n          depth2 * ${o} + depth3 + ${x};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${a}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),{newShape:o,keptDims:i}=t.util.squeezeShape(n);if(o.length<n.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${me(Re(e,o))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Te(t,i)});\n      }\n    `}const s=n[5],u=n[4]*s,l=n[3]*u,c=n[2]*l,d=n[1]*c;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${l}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${s}, 1)));\n        ${ye(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,f=h[0],x=h[1];if(x===d&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${u}, ${s})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${f}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;if(x===s&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${f}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;const m=ke(a);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${l} +\n          depth2 * ${u} + depth3 * ${s} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${f}, ${x}, index);\n      return sampleTexture(${a}, uv);\n    }\n  `}(e);default:throw new Error(`${a.length}-D input sampling is not yet supported`)}}function ge(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=ue();return`\n    vec4 ${n}() {\n      return ${a.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,o=ue();if(t)return`\n    vec4 ${a}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${a}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,s=i[0],u=i[1],l=ue();if(null!=i&&t.util.arraysEqual(a,i))return n?`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${s}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(a[1]/2);return`\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,n);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const a=[1,2],o=["b","row","col"];return`\n        ${ge(Re(e,n.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Te(o,a)});\n        }\n      `}const s=ue();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${s.texture2D}(${a}, uv);\n    }\n  `;const u=i[0],l=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${d}, ${c}, b, row, col);\n      return ${s.texture2D}(${a}, uv);\n    }\n  `}(e,n);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=ue();if(t)return`\n    vec4 ${a}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;const o=e.shapeInfo.logicalShape,i=o.length,s=e.shapeInfo.texShape,u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],l=u[0],c=u[1],d=Math.ceil(o[i-1]/2);let p=d*Math.ceil(o[i-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<i-1;e++)h=`int b${e}, `+h,p*=o[i-e-1],f=`b${e} * ${p} + `+f;return`\n    vec4 ${a}(${h}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `}(e,n)}}const be="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ve="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ce="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$e="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Ie(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function ke(e){return`offset${e}`}function ye(e){const n=e.name,a=t.util.sizeFromShape(e.shapeInfo.logicalShape);return a<2?`return ${n};`:`\n    for (int i = 0; i < ${a}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function Se(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function we(e,n,a){const{newShape:r,keptDims:o}=t.util.squeezeShape(n),i=n.length,s=e&&3===i&&1===n[0],u=s?n.slice(1):r,l=!e&&i>1&&!t.util.arraysEqual(n,a)&&r.length<i||s;return{useSqueezeShape:l,uniformShape:l?u:n,keptDims:o}}function Re(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Te(e,t){return t.map((t=>e[t])).join(", ")}function Ee(e,n,a){const r={},o={},i={},s=[];let u,l,c,d=null,p=null;p=e.getUniformLocation(a,"NAN",!1),1===t.env().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(a,"INFINITY",!1));const h=!1;for(let t=0;t<n.variableNames.length;t++){const s=n.variableNames[t];r[s]=e.getUniformLocation(a,s,h),r[`offset${s}`]=e.getUniformLocation(a,`offset${s}`,h),n.enableShapeUniforms&&(o[`${s}Shape`]=e.getUniformLocation(a,`${s}Shape`,h),i[`${s}TexShape`]=e.getUniformLocation(a,`${s}TexShape`,h))}return n.enableShapeUniforms&&(u=e.getUniformLocation(a,"outShape",h),c=e.getUniformLocation(a,"outShapeStrides",h),l=e.getUniformLocation(a,"outTexShape",h)),n.customUniforms&&n.customUniforms.forEach(((t,n)=>{s[n]=e.getUniformLocation(a,t.name,h)})),{uniformLocations:r,customUniformLocations:s,infLoc:d,nanLoc:p,inShapesLocations:o,inTexShapesLocations:i,outShapeLocation:u,outShapeStridesLocation:c,outTexShapeLocation:l}}function Ne(e,n){if(e.length!==n.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${n.length} inputs`);e.forEach(((e,a)=>{const r=e.logicalShape,o=n[a],i=o.shape;if(!t.util.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const s=e.texShape,u=o.isUniform?null:o.texData.texShape;if(!t.util.arraysEqual(s,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${s} and ${u} must match`)}))}function Ae(e){return t.env().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class Fe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=u.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ue();this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ce(["r","c","d"],e):le(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class _e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=u.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ue();this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ce(["r","c","d"],e):le(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class Oe{constructor(e){this.variableNames=["A"],this.outTexUsage=l.DOWNLOAD;const t=ue();this.outputShape=e,this.userCode=`\n      ${he}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class De{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=l.DOWNLOAD;const t=ue();this.outputShape=e,this.userCode=`\n      ${he}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class Pe{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=ue();this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":pe(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class Le{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=ue();this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let r=0;r<=1;r++){const o=2*t+r;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${r} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${r};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":pe(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${n.output} = ${r};\n        }\n    `}}function Be(e){const t=ue();return v(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Ue(e){return w(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Ve(e){return R(e,new Uint16Array([0,1,2,2,1,3]))}function We(e,n,a,r,o,i){E(n,a);const s=T(e),u=e.TEXTURE_2D;return x(e,(()=>e.bindTexture(u,s))),x(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),x(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),x(e,(()=>e.texParameteri(u,e.TEXTURE_MIN_FILTER,e.NEAREST))),x(e,(()=>e.texParameteri(u,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===t.env().getNumber("WEBGL_VERSION")?x(e,(()=>e.texImage2D(u,0,r,n,a,0,o,i,null))):x(e,(()=>e.texStorage2D(u,1,r,n,a))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:s,texShape:[a,n]}}function Me(e){return e.internalFormatFloat}function Ge(e,t,n,a){const[r,o]=d(t,n);return We(e,r,o,Me(a),a.textureFormatFloat,e.FLOAT)}function ze(e){return e.internalFormatHalfFloat}function Xe(e,t,n,a){const[r,o]=d(t,n);return We(e,r,o,ze(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function He(e){return e.downloadTextureFormat}function je(e,t,n,a){const[r,o]=d(t,n);return We(e,r,o,He(a),e.RGBA,e.UNSIGNED_BYTE)}function Ke(e){return e.internalFormatPackedFloat}function qe(e,t,n,a){const[r,o]=h(t,n);return We(e,r,o,Ke(a),e.RGBA,e.FLOAT)}function Ye(e){return e.internalFormatPackedHalfFloat}function Qe(e,t,n,a){const[r,o]=h(t,n);return We(e,r,o,Ye(a),e.RGBA,a.textureTypeHalfFloat)}function Ze(e,t,n){x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));return A(e,t,"clipSpacePos",n,3,20,0)&&A(e,t,"uv",n,2,20,12)}function Je(e,n,a,r,o,i){let s,u,l;x(e,(()=>e.bindTexture(e.TEXTURE_2D,n))),o instanceof Uint8Array?(s=new Uint8Array(a*r*4),u=e.UNSIGNED_BYTE,l=e.RGBA):(s=new Float32Array(a*r*4),u=e.FLOAT,l=i.internalFormatPackedFloat),s.set(o),2===t.env().getNumber("WEBGL_VERSION")?x(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,a,r,e.RGBA,u,s))):x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,a,r,0,e.RGBA,u,s))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function et(e,n,a){x(e,(()=>e.bindTexture(e.TEXTURE_2D,n))),a.data instanceof Uint8Array?2===t.env().getNumber("WEBGL_VERSION")?x(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,a.width,a.height,e.RGBA,e.UNSIGNED_BYTE,a.data))):x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a.width,a.height,0,e.RGBA,e.UNSIGNED_BYTE,a.data))):2===t.env().getNumber("WEBGL_VERSION")?x(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,a))):x(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,a))),x(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function tt(e,t,n,a){const r=e.createBuffer();x(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const o=16*t*n;return x(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),x(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),x(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}function nt(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function at(e,t,n,a){const[r,o]=d(t,n),i=new Uint8Array(t*n*4);return x(e,(()=>e.readPixels(0,0,r,o,a.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}function rt(e,t,n,a,r,o,i,s){const u=e,l=new Float32Array(function(e,t){const[n,a]=h(e,t);return n*a*4}(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function ot(e,t,n){const a=new Float32Array(t*n*4);return x(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}var it={__proto__:null,createVertexShader:Be,createVertexBuffer:Ue,createIndexBuffer:Ve,getInternalFormatForFloat32MatrixTexture:Me,createFloat32MatrixTexture:Ge,getInternalFormatForFloat16MatrixTexture:ze,createFloat16MatrixTexture:Xe,getInternalFormatForUnsignedBytesMatrixTexture:He,createUnsignedBytesMatrixTexture:je,getInternalFormatForPackedMatrixTexture:Ke,createPackedMatrixTexture:qe,getInternalFormatForFloat16PackedMatrixTexture:Ye,createFloat16PackedMatrixTexture:Qe,bindVertexProgramAttributeStreams:Ze,uploadDenseMatrixToTexture:Je,uploadPixelDataToTexture:et,createBufferFromOutputTexture:tt,downloadFloat32MatrixFromBuffer:nt,downloadByteEncodedFloatMatrixFromOutputTexture:at,downloadPackedMatrixFromBuffer:rt,downloadMatrixFromPackedOutputTexture:ot};class st{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const n=t.env().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,i(n,e)):this.gl=s(n);let a="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===t.env().getNumber("WEBGL_VERSION")){const e="OES_texture_float",n="OES_texture_half_float";if(this.textureFloatExtension=b(this.gl,e),J(this.gl,n))this.textureHalfFloatExtension=b(this.gl,n);else if(t.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(a),J(this.gl,r))this.colorBufferHalfFloatExtension=b(this.gl,r);else if(t.env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(a="EXT_color_buffer_float",J(this.gl,a))this.colorBufferFloatExtension=this.gl.getExtension(a);else{if(!J(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=Ue(this.gl),this.indexBuffer=Ve(this.gl),this.framebuffer=N(this.gl),this.textureConfig=f(this.gl,this.textureHalfFloatExtension)}get debug(){return t.env().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;x(e,(()=>e.finish())),x(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),x(e,(()=>e.deleteFramebuffer(this.framebuffer))),x(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),x(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),x(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Ge(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Xe(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),je(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),et(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),Je(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Qe(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),qe(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(L(this.gl,this.framebuffer),this.outputTexture=null),x(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>at(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,o){return rt(this.gl,e,0,0,0,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return nt(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=tt(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,a;if(t.env().getBool("WEBGL_FENCE_API_ENABLED")){const t=e,r=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),a=()=>{const e=t.clientWaitSync(r,0,0);return e===t.ALREADY_SIGNALED||e===t.CONDITION_SATISFIED},n=r}else t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),a=()=>this.isQueryAvailable(n,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):a=()=>!0;return{query:n,isFencePassed:a}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>ot(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=Be(t));const n=k(t);return x(t,(()=>t.attachShader(n,this.vertexShader))),x(t,(()=>t.attachShader(n,e))),y(t,n),this.debug&&S(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=Ze(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&x(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&S(this.gl,this.program),x(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?_(this.gl,e,t):O(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),x(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),D(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=h(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&S(this.gl,this.program),B(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),x(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),x(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=b(this.gl,2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(2===t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await t.util.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1||t.util.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),P(this.gl,e,this.framebuffer),this.debug&&B(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(P(this.gl,this.outputTexture,this.framebuffer),this.debug&&B(this.gl)):L(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;P(a,e,this.framebuffer),this.debug&&B(a),this.outputTexture=e,x(a,(()=>a.viewport(0,0,t,n))),x(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),x(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function ut(e){return(n,a,r,o,i)=>{const s=t.backend_util.assertAndGetBroadcastShape(n,a),u=s.length,l=t.util.computeStrides(s),c=t.util.sizeFromShape(s),d=t.util.getTypedArrayFromDType(i,c),p=n.length,h=a.length,f=t.util.computeStrides(n),x=t.util.computeStrides(a),m=t.backend_util.getBroadcastDims(n,s),g=t.backend_util.getBroadcastDims(a,s);if(m.length+g.length===0)for(let t=0;t<d.length;++t)d[t]=e(r[t%r.length],o[t%o.length]);else for(let n=0;n<d.length;++n){const a=t.util.indexToLoc(n,u,l),i=a.slice(-p);m.forEach((e=>i[e]=0));const s=t.util.locToIndex(i,p,f),c=a.slice(-h);g.forEach((e=>c[e]=0));const b=t.util.locToIndex(c,h,x);d[n]=e(r[s],o[b])}return[d,s]}}const lt=ut(((e,t)=>e+t));function ct(e){return(n,a,r)=>{const o=t.util.getTypedArrayFromDType(a,n.length);for(let t=0;t<n.length;++t)o[t]=e(n[t],r);return o}}const dt=ct((e=>Math.ceil(e)));const pt=ut(((e,t)=>e===t?1:0)),ht=ct((e=>Math.exp(e))),ft=ct((e=>Math.expm1(e))),xt=ct((e=>Math.floor(e)));const mt=ut(((e,t)=>e>t?1:0)),gt=ut(((e,t)=>e>=t?1:0)),bt=ut(((e,t)=>e<t?1:0)),vt=ut(((e,t)=>e<=t?1:0));const Ct=ct((e=>Math.log(e)));const $t=ut(((e,t)=>Math.max(e,t))),It=ut(((e,t)=>Math.min(e,t))),kt=ut(((e,t)=>e*t));const yt=ut(((e,t)=>e!==t?1:0));const St=ct((e=>1/Math.sqrt(e))),wt=ct((e=>1/(1+Math.exp(-e))));const Rt=ct((e=>Math.sqrt(e))),Tt=ut(((e,t)=>{const n=e-t;return n*n}));class Et{constructor(e,n,a,r,o,i){this.separator=t.util.encodeString(e),this.nGramWidths=n,this.leftPad=t.util.encodeString(a),this.rightPad=t.util.encodeString(r),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,o){for(let i=0;i<r;++i){const s=this.getPadWidth(o),u=Math.max(0,s-i),l=Math.max(0,s-(r-(i+1))),c=o-(u+l),d=t+(u>0?0:i-s);let p=0;p+=u*this.leftPad.length;for(let t=0;t<c;++t)p+=e[d+t].length;p+=l*this.rightPad.length;p+=(u+l+c-1)*this.separator.length,n[a+i]=new Uint8Array(p);const h=n[a+i];let f=0;const x=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<u;++e)x(this.leftPad),x(this.separator);for(let t=0;t<c-1;++t)x(e[d+t]),x(this.separator);if(c>0){x(e[d+c-1]);for(let e=0;e<l;++e)x(this.separator),x(this.rightPad)}else{for(let e=0;e<l-1;++e)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,n){const a=e.length,r=n.length;if(r>0){let e=n[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let t=1;t<r;++t){let r=n[t]>=e;if(r=r&&n[t]<=a,!r)throw new Error(`Invalid split value ${n[t]}, must be in [${e}, ${a}]`);e=n[t]}if(e!==a)throw new Error(`Last split value must be data size. Expected ${a}, got ${e}`)}const o=r-1,i=t.util.getArrayFromDType("int32",r);if(0===a||0===r){const e=new Array(a);for(let e=0;e<=o;++e)i[e]=0;return[e,i]}i[0]=0;for(let e=1;e<=o;++e){const t=n[e]-n[e-1];let a=0;this.nGramWidths.forEach((e=>{a+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===a&&(a=1),i[e]=i[e-1]+a}const s=new Array(i[o]);for(let t=0;t<o;++t){const a=n[t];let r=i[t];if(this.nGramWidths.forEach((o=>{const i=n[t+1]-n[t],u=this.getNumNGrams(i,o);this.createNGrams(e,a,s,r,u,o),r+=u})),this.preserveShort&&r===i[t]){const o=n[t+1]-n[t];if(0===o)continue;const i=o+2*this.padWidth,u=1;this.createNGrams(e,a,s,r,u,i)}}return[s,i]}}function Nt(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||a.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(r,o);n&&0===t.length||a.push(t),r=o+1}}const At=ut(((e,t)=>e-t));const Ft=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function _t(e,n,a=0,r=e.length-1){for(;r>a;){if(r-a>600){const t=r-a+1,o=n-a+1,i=Math.log(t),s=.5*Math.exp(2*i/3),u=.5*Math.sqrt(i*s*(t-s)/t)*Math.sign(o-t/2);_t(e,n,Math.max(a,Math.floor(n-o*s/t+u)),Math.min(r,Math.floor(n+(t-o)*s/t+u)))}const o=e[n];let i=a,s=r;for(t.util.swap(e,a,n),Ft(e[r],o)>0&&t.util.swap(e,a,r);i<s;){for(t.util.swap(e,i,s),i++,s--;Ft(e[i],o)<0;)i+=1;for(;Ft(e[s],o)>0;)s-=1}0===Ft(e[a],o)?t.util.swap(e,a,s):(s+=1,t.util.swap(e,s,r)),s<=n&&(a=s+1),n<=s&&(r=s-1)}}var Ot={__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:lt,bincountImpl:function(e,n,a,r,o){const i=t.util.sizeFromShape(r),s=t.util.makeZerosTypedArray(o,a);for(let t=0;t<e.length;t++){const a=e[t];if(a<0)throw new Error("Input x must be non-negative!");a>=o||(s[a]+=i>0?n[t]:1)}return s},bincountReduceImpl:function(e,n,a,r=!1){const o=e.shape[0],i=e.shape[1],s=t.buffer([o,a],n.dtype);for(let t=0;t<o;t++)for(let o=0;o<i;o++){const i=e.get(t,o);if(i<0)throw new Error("Input x must be non-negative!");i>=a||(r?s.set(1,t,i):n.size>0?s.set(s.get(t,i)+n.get(t,o),t,i):s.set(s.get(t,i)+1,t,i))}return s},ceilImpl:dt,concatImpl:function(e,n,a,r){const o=t.util.getArrayFromDType(a,t.util.sizeFromShape(n));if(r&&"string"!==a){let n=0;e.forEach((e=>{const a=t.util.sizeFromShape(e.shape);o.set(e.vals,n),n+=a}))}else{let r=0;e.forEach((e=>{const i="string"===a?t.backend_util.fromUint8ToStringArray(e.vals):e.vals;let s=0;for(let t=0;t<e.shape[0];++t){const a=t*n[1]+r;for(let t=0;t<e.shape[1];++t)o[a+t]=i[s++]}r+=e.shape[1]}))}return o},equalImpl:pt,expImpl:ht,expm1Impl:ft,floorImpl:xt,gatherNdImpl:function(e,n,a,r,o,i,s,u,l){const c=t.buffer([r,i],a);for(let t=0;t<r;t++){const a=[];let r=0;for(let n=0;n<o;n++){const i=e[t*o+n];r+=i*s[n],a.push(i)}if(r<0||r>=l/i)throw new Error(`Invalid indices: ${a} does not index into ${u}`);for(let e=0;e<i;e++)c.values[t*i+e]=n.get(...n.indexToLoc(r*i+e))}return c},gatherV2Impl:function(e,n,a){const r=t.buffer(a,e.dtype);for(let t=0;t<r.size;++t){const a=r.indexToLoc(t).slice(),o=a[0],i=a[2],s=n.locToIndex([o,i]);a[2]=n.values[s];const u=e.locToIndex(a);0<=u&&u<e.values.length&&(r.values[t]=e.values[u])}return r},greaterImpl:mt,greaterEqualImpl:gt,lessImpl:bt,lessEqualImpl:vt,linSpaceImpl:function(e,n,a){const r=(n-e)/(a-1),o=t.util.makeZerosTypedArray(a,"float32");o[0]=e;for(let e=1;e<o.length;e++)o[e]=o[e-1]+r;return o},logImpl:Ct,maxImpl:function(e,n,a,r){const o=t.util.getTypedArrayFromDType(r,t.util.sizeFromShape(a));for(let t=0;t<o.length;++t){const a=t*n;let r=e[a];for(let t=0;t<n;++t){const n=e[a+t];(Number.isNaN(n)||n>r)&&(r=n)}o[t]=r}return o},maximumImpl:$t,minimumImpl:It,multiplyImpl:kt,negImpl:function(e,n,a){const r=t.util.createScalarValue(-1,a);return kt([],n,r,e,a)},notEqualImpl:yt,prodImpl:function(e,n,a,r){const[o,i]=t.backend_util.computeOutAndReduceShapes(e,r),s=t.upcastType(n,"int32"),u=t.util.makeZerosTypedArray(t.util.sizeFromShape(o),s),l=t.util.sizeFromShape(i);for(let e=0;e<u.length;++e){const t=e*l;let n=1;for(let e=0;e<l;++e)n*=a[t+e];u[e]=n}return{outVals:u,outShape:o,outDtype:s}},rangeImpl:function(e,n,a,r){if(e===n||e<n&&a<0||n<e&&a>1)return t.util.makeZerosTypedArray(0,r);const o=Math.abs(Math.ceil((n-e)/a)),i=t.util.makeZerosTypedArray(o,r);n<e&&1===a&&(a=-1),i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+a;return i},rsqrtImpl:St,sigmoidImpl:wt,sliceImpl:function(e,n,a,r,o){const i=t.slice_util.isSliceContinous(r,n,a),s=t.util.sizeFromShape(a),u=t.util.computeStrides(r);if(i){const a=t.slice_util.computeFlatOffset(n,u);return"string"===o?e.slice(a,a+s):e.subarray(a,a+s)}const l="string"===o?t.backend_util.fromUint8ToStringArray(e):e,c=t.buffer(r,o,l),d=t.buffer(a,o);for(let e=0;e<d.size;++e){const t=d.indexToLoc(e),a=t.map(((e,t)=>e+n[t]));d.set(c.get(...a),...t)}return"string"===o?t.backend_util.fromStringArrayToUint8(d.values):d.values},sparseFillEmptyRowsImpl:function(e,n,a,r,o,i,s){const u=n[0],l=i[0],c=new Array(l),d=new Array(u),p=n[1];if(0===l){if(0!==u)throw new Error(t.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));return[t.util.getArrayFromDType(a,0),[0,p],t.util.getArrayFromDType(o,0),c,d]}let h=!0,f=0;const x=new Array(l).fill(0);for(let n=0;n<u;++n){const a=e[n*p];if(a<0)throw new Error(t.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(n,a));if(a>=l)throw new Error(t.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(n,a,l));++x[a],h=h&&a>=f,f=a}let m=!0;for(let e=0;e<l;++e){const t=0===x[e];c[e]=t,m=m&&!t,x[e]=Math.max(x[e],1),e>0&&(x[e]+=x[e-1])}if(m&&h){const t=e,n=r;for(let e=0;e<u;++e)d[e]=e;return[t,[u,p],n,c,d]}{const n=x[l-1],i=t.util.getArrayFromDType(a,n*p),h=t.util.getArrayFromDType(o,n),f=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*p],a=f[n],o=(0===n?0:x[n-1])+a;f[n]++;for(let n=0;n<p;++n)i[o*p+n]=e[t*p+n];h[o]=r[t],d[t]=o}for(let e=0;e<l;++e){if(0===f[e]){const t=0===e?0:x[e-1];i[t*p+0]=e;for(let e=1;e<p;++e)i[t*p+e]=0;h[t]=s}}return[i,[n,p],h,c,d]}},sparseReshapeImpl:function(e,n,a,r,o){const i=t.util.sizeFromShape(r),s=n[0],u=o.length,l=[];let c=1,d=-1;for(let e=0;e<u;++e){const n=o[e];if(-1===n){if(-1!==d)throw new Error(t.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,e));d=e,l.push(1)}else{if(n<0)throw new Error(t.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(e,n));c*=n,l.push(n)}}if(-1!==d){if(c<=0)throw new Error(t.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(i/c);if(c*e!==i)throw new Error(t.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[d]=e}if(t.util.sizeFromShape(l)!==i)throw new Error(t.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const p=r.length,h=[];if(p>0){h[p-1]=1;for(let e=p-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const f=[];if(u>0){f[u-1]=1;for(let e=u-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const x=t.util.getArrayFromDType(a,s*u);for(let t=0;t<s;++t){let n=0;for(let a=0;a<p;++a)n+=e[t*p+a]*h[a];for(let e=0;e<u;++e)x[t*u+e]=Math.trunc(n/f[e]),n%=f[e]}return[x,[s,u],l]},sparseSegmentReductionImpl:function(e,n,a,r,o,i=!1,s=0){const u=r.length,l=[n[0],e.length/n[0]],c=l[1],d=u>0?o[u-1]+1:0;if(d<0)throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const p=n.slice();p[0]=d;const h=p.reduce(((e,t)=>e*t),1),f=t.util.getArrayFromDType(a,h);if(0===u)return d>0&&f.fill(s),[f,p];if(d<=0)throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let x=0,m=1,g=0,b=o[x];for(;;){let n=0;if(m<u){if(n=o[m],b===n){++m;continue}if(b>=n)throw new Error(t.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=d)throw new Error(t.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,d));b>g&&f.fill(s,g*c,b*c);for(let n=x;n<m;++n){const a=r[n];if(a<0||a>=l[0])throw new Error(t.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let t=0;t<c;t++)f[b*c+t]+=e[a*c+t]}if(i)for(let e=0;e<c;e++)f[b*c+e]/=m-x;if(x=m,++m,g=b+1,b=n,m>u)break}return g<d&&f.fill(s,g*c,d*c),[f,p]},sqrtImpl:Rt,squaredDifferenceImpl:Tt,stridedSliceImpl:function(e,n,a,r){const o=t.buffer(e,n.dtype);for(let e=0;e<o.size;e++){const t=o.indexToLoc(e),i=new Array(t.length);for(let e=0;e<i.length;e++)i[e]=t[e]*a[e]+r[e];o.set(n.get(...i),...t)}return o},stringNGramsImpl:function(e,t,n,a,r,o,i,s){return new Et(n,a,r,o,i,s).compute(e,t)},stringSplitImpl:function(e,n,a){const r=e.length,o=[];let i=0,s=0;const u=new Array(r);for(let t=0;t<r;++t){const r=o.length;Nt(e[t],n,a,o);const l=o.length-r;u[t]=l,i+=l,s=Math.max(s,l)}const l=t.util.getArrayFromDType("int32",2*i),c=new Array(i),d=[r,s];let p=0;for(let e=0;e<r;++e)for(let t=0;t<u[e];++t)l[2*p]=e,l[2*p+1]=t,c[p]=o[p],++p;return[l,c,d]},stringToHashBucketFastImpl:function(e,n){const a=t.util.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)a[r]=t.util.fingerPrint64(e[r]).modulo(n).getLowBitsUnsigned();return a},subImpl:At,tileImpl:function(e,n){const a=new Array(e.rank);for(let t=0;t<a.length;t++)a[t]=e.shape[t]*n[t];const r=t.buffer(a,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),a=new Array(e.rank);for(let t=0;t<a.length;t++)a[t]=n[t]%e.shape[t];const o=e.locToIndex(a);r.values[t]=e.values[o]}return r},topKImpl:function(e,n,a,r,o){const i=n[n.length-1],[s,u]=[e.length/i,i],l=t.util.getTypedArrayFromDType(a,s*r),c=t.util.getTypedArrayFromDType("int32",s*r);for(let t=0;t<s;t++){const n=t*u,a=e.subarray(n,n+u);let i=new Array(a.length);a.forEach(((e,t)=>i[t]={value:e,index:t})),r<i.length&&(_t(i,r),i=i.slice(0,r)),o&&i.sort(Ft);const s=t*r,d=l.subarray(s,s+r),p=c.subarray(s,s+r);for(let e=0;e<r;e++)d[e]=i[e].value,p[e]=i[e].index}const d=n.slice();return d[d.length-1]=r,[t.buffer(d,a,l),t.buffer(d,"int32",c)]},transposeImpl:function(e,n,a,r,o){const i=n.length,s=t.util.sizeFromShape(n),u=t.util.computeStrides(n),l=t.util.computeStrides(o),c=t.util.getTypedArrayFromDType(a,t.util.sizeFromShape(o));for(let n=0;n<s;++n){const a=t.util.indexToLoc(n,i,u),o=new Array(a.length);for(let e=0;e<o.length;e++)o[e]=a[r[e]];c[t.util.locToIndex(o,i,l)]=e[n]}return c},uniqueImpl:function(e,n,a,r){const o=t.util.parseAxisParam(n,a)[0],i=[1,a[0],1];for(let e=0;e<o;e++)i[0]*=a[e];i[1]=a[o];for(let e=o+1;e<a.length;e++)i[2]*=a[e];const s={},u=new Int32Array(a[o]),l=new t.TensorBuffer(i,r,e),c=[],d=1===i[0]&&1===i[2];for(let t=0;t<a[o];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<i[0];n++)for(let a=0;a<i[2];a++)e.push(l.get(n,t,a));n=e.join(",")}if(void 0!==s[n])u[t]=s[n];else{const e=Object.keys(s).length;s[n]=e,u[t]=e,c.push(t)}}const p=i.slice();p[1]=Object.keys(s).length;const h=new t.TensorBuffer(p,r);c.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let a=0;a<i[2];a++)h.set(l.get(n,e,a),n,t,a)}));const f=a.slice();return f[o]=p[1],{outputValues:h.values,outputShape:f,indices:u}}};const{addImpl:Dt,bincountImpl:Pt,bincountReduceImpl:Lt,ceilImpl:Bt,concatImpl:Ut,equalImpl:Vt,expImpl:Wt,expm1Impl:Mt,floorImpl:Gt,gatherNdImpl:zt,gatherV2Impl:Xt,greaterImpl:Ht,greaterEqualImpl:jt,lessImpl:Kt,lessEqualImpl:qt,linSpaceImpl:Yt,logImpl:Qt,maxImpl:Zt,maximumImpl:Jt,minimumImpl:en,multiplyImpl:tn,negImpl:nn,notEqualImpl:an,prodImpl:rn,rangeImpl:on,rsqrtImpl:sn,sigmoidImpl:un,simpleAbsImpl:ln,sliceImpl:cn,sparseFillEmptyRowsImpl:dn,sparseReshapeImpl:pn,sparseSegmentReductionImpl:hn,sqrtImpl:fn,stridedSliceImpl:xn,stringNGramsImpl:mn,stringSplitImpl:gn,stringToHashBucketFastImpl:bn,subImpl:vn,tileImpl:Cn,topKImpl:$n,transposeImpl:In,uniqueImpl:kn}=Ot;function yn(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Sn(e,t){return 1===t?[e]:yn(e,t)}class wn{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ae(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Sn("rc",this.rank),t=Se(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${r}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r=`${0===n?"r":"rp1"}, ${0===a?"c":"cp1"}`;for(let t=2;t<this.rank;t++)r=`${e[e.length-1-t]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${a};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class Rn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var a,r;this.userCode=`\n      ${a=t,r=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${r?de(["r","c","d"],"inputShape"):le(["r","c","d"],a)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":pe(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Tn{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const a=Nn(t,n),r=An(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=En(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let i;return a===c.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===c.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===c.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===c.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===c.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,n,a,r){if(null==this.freeTextures)return;const o=Nn(a,r),i=An(n,o,r);i in this.freeTextures||(this.freeTextures[i]=[]);const s=En(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=t.env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const l=this.usedTextures[i],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function En(e,t,n,a,r){const o=function(e,t){switch(e){case c.PACKED_2X2_FLOAT32:return Ke(t);case c.PACKED_2X2_FLOAT16:return Ye(t);case c.UNPACKED_FLOAT32:return Me(t);case c.UNPACKED_FLOAT16:return ze(t);case c.PACKED_4X1_UNSIGNED_BYTE:return He(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,a);let i;if(r){const[t,n]=h(e[0],e[1]);i=t*n}else{const[t,n]=d(e[0],e[1]);i=t*n}return i*function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,o)}function Nn(e,n){if(e===l.UPLOAD)return c.PACKED_2X2_FLOAT32;if(e===l.RENDER||null==e)return function(e){return t.env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?c.PACKED_2X2_FLOAT32:c.UNPACKED_FLOAT32:e?c.PACKED_2X2_FLOAT16:c.UNPACKED_FLOAT16}(n);if(e===l.DOWNLOAD||e===l.PIXELS)return c.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function An(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Fn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const _n="return abs(x);",On="return x;";class Dn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Pn{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length);const t=e.length,n=Sn("rc",t),a=Se(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),i=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const Ln=t.kernel_impls.whereImpl,Bn={};const Un=t.env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class Vn extends t.KernelBackend{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!t.env().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(null!=e){if(e instanceof st)n=e;else{const a=s(t.env().getNumber("WEBGL_VERSION"),e);n=new st(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=s(t.env().getNumber("WEBGL_VERSION"));n=new st(e),this.binaryCache=((a=t.env().getNumber("WEBGL_VERSION"))in Bn||(Bn[a]={}),Bn[a]),this.gpgpuCreatedLocally=!0}var a;this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Tn(this.gpgpu),this.numMBBeforeWarning=null==t.env().global.screen?1024:t.env().global.screen.height*t.env().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new t.DataStorage(this,t.engine())}nextDataId(){return Vn.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,n,a){if((t.env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||t.env().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===a&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:e,usage:l.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,n,a,r,o){if(t.env().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:a,dtype:r,values:n,usage:l.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:a,dtype:r,complexTensorInfos:o,slice:i,shape:s,isPacked:u}=n;if(null!=i){let t;t=u?new Dn(s,On):new Fn(s,On);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=a)return this.convertAndCacheOnCPU(e);if("string"===r)return a;const l=null!=this.activeTimers;let c,d;if(l&&(c=t.util.now()),"complex64"===r){const e=this.readSync(o.real.dataId),n=this.readSync(o.imag.dataId);d=t.backend_util.mergeRealAndImagArrays(e,n)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=t.util.now()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const n=this.texData.get(e),{values:a,shape:r,slice:o,dtype:i,complexTensorInfos:s,isPacked:u}=n;if(null!=o){let t;t=u?new Dn(r,On):new Fn(r,On);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:i}],i),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=a)return this.convertAndCacheOnCPU(e);if(t.env().getBool("DEBUG")&&!t.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===t.env().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,d=null;if("complex64"!==i&&t.env().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(t.texture.texture,...p(r))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const e=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]),n=e[0],a=e[1];c=t.backend_util.mergeRealAndImagArrays(n,a)}else if(null==d)c=this.getValuesFromTexture(e);else{const e=t.util.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=d){const e=this.gpgpu.gl;x(e,(()=>e.deleteBuffer(d)))}const h=this.convertAndCacheOnCPU(e,c),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&t.engine().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,n={}){const a=this.texData.get(e),{values:r,shape:o,slice:i,dtype:s,isPacked:u,texture:l}=a;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let t;t=u?new Dn(o,On):new Fn(o,On);const a=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:s}],s),r=this.readToGPU(a,n);return this.disposeIntermediateTensorInfo(a),r}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,n.customTexShape),d=t.engine().makeTensorFromDataId(c.dataId,c.shape,c.dtype),p=this.texData.get(c.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(e){const n=this.readSync(e.dataId);let a=n;if("string"===e.dtype)try{a=n.map((e=>t.util.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return t.buffer(e.shape,e.dtype,a)}checkNumericalProblems(e){if(null!=e)for(let n=0;n<e.length;n++){const a=e[n];if(!m(a)){if(t.env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${a} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:n,dtype:a,isPacked:r}=this.texData.get(e),o=t.util.sizeFromShape(n);if(t.env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const t=this.decode(e),a=this.texData.get(t.dataId),r=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...p(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(t),r}const i=t.env().getBool("WEBGL_PACK")&&!0===r,s=i?z(n):n,u=i?new De(s):new Oe(s),l=this.runWebGLProgram(u,[{shape:s,dtype:a,dataId:e}],"float32"),c=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,a=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,e();const o=t.util.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=t.util.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=n,r&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);s.kernelMs=t.util.sum(e),s.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:t.util.now(),endMs:null}}endTimer(e){return t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=t.util.now(),e)}async getQueryTime(e){if(t.env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:o,slice:i}=this.texData.get(e),s=i&&i.origDataId||e,u=this.dataRefCount.get(s);u>1?this.dataRefCount.set(s,u-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=Un){return t.env().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&t.util.sizeFromShape(e.shape)<n))}getGPGPUContext(){return this.gpgpu}where(e){t.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return Ln(e.shape,n)}packedUnaryOp(e,n,a){const r=new Dn(e.shape,n),o=this.compileAndRun(r,[e],a);return t.engine().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=ln(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,_n,e.dtype);const n=new Fn(e.shape,_n),a=this.compileAndRun(n,[e]);return t.engine().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}makeTensorInfo(e,n,a){let r;if("string"===n&&null!=a&&a.length>0&&t.util.isString(a[0])){const o=a.map((e=>t.util.encodeString(e)));r=this.write(o,e,n)}else r=this.write(a,e,n);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:n}}makeOutput(e,n,a){const{dataId:r}=this.makeTensorInfo(e,n,a);return t.engine().makeTensorFromDataId(r,e,n,this)}unpackTensor(e){const t=new Pn(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new wn(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[M(e.shape),...G(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[M(t),...G(t)],o=new Rn(r,n),i=[n],s=this.runWebGLProgram(o,[a],e.dtype,i,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e,n){const a=this.texData.get(e),{isPacked:r,shape:o,dtype:i}=a;if(null!=n){const e=t.util.sizeFromShape(o),a=n[0]*n[1]*4;t.util.assert(e<=a,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const s=z(o);let u;u=r?new _e(s):new Fe(s);const l=[null!=n?n:p(s)];return{dtype:i,shape:o,dataId:this.runWebGLProgram(u,[{shape:s,dtype:i,dataId:e}],i,l,!0,n).dataId}}runWebGLProgram(e,n,a,r,o=!1,i){const s=this.makeTensorInfo(e.outputShape,a),l=this.texData.get(s.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===u.DENSE){const t=null!=i?i:p(e.outputShape);l.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(l.usage=e.outTexUsage),0===t.util.sizeFromShape(s.shape))return l.values=t.util.getTypedArrayFromDType(s.dtype,0),s;const c=[],d=n.map((n=>{if("complex64"===n.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let a=this.texData.get(n.dataId);if(null==a.texture){if(!e.packedInputs&&t.util.sizeFromShape(n.shape)<=t.env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:n.shape,texData:null,isUniform:!0,uniformValues:a.values};e.packedInputs&&(a.isPacked=!0,a.shape=n.shape)}if(this.uploadToGPU(n.dataId),!!a.isPacked!=!!e.packedInputs)n=a.isPacked?this.unpackTensor(n):this.packTensor(n),c.push(n),a=this.texData.get(n.dataId);else if(a.isPacked&&!j(a.shape,n.shape)){const e=n,t=n.shape;n.shape=a.shape,n=this.packedReshape(n,t),c.push(n),a=this.texData.get(n.dataId),e.shape=t}return{shape:n.shape,texData:a,isUniform:!1}}));this.uploadToGPU(s.dataId);const h={shape:s.shape,texData:l,isUniform:!1},f=function(e,n,a){let r="";n.concat(a).forEach((n=>{const o=null!=n.texData&&null!=n.texData.slice&&n.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!n.isUniform){const i=n.texData.texShape,{useSqueezeShape:s,uniformShape:u,keptDims:l}=we(e.packedInputs,n.shape,i);let c="",d="",p="";if(1===u.length&&e.packedInputs){const e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];c=`${e[0]>1}_${e[1]>1}`}else if(2!==u.length||e.packedInputs){if(u.length>2&&!e.packedInputs){const e=t.util.computeStrides(u);p=`${e[0]===i[1]}_${e[e.length-1]===i[1]}`}}else d=`${u[0]>1}_${u[1]>1}`;const h=n.shape.length,f=2===u.length&&t.util.arraysEqual(n.shape,i),x=1===t.util.sizeFromShape(n.shape),m=t.backend_util.getBroadcastDims(n.shape,a.shape),g=!e.packedInputs&&h===a.shape.length&&t.util.arraysEqual(i,a.texData.texShape),b=e.packedInputs||u.length>2?"":`${i[0]>1}_${i[1]>1}`;r+=`${h}_${g}_${s?l:""}_${u.length}_${x}_${m}_${f}_${c}_${d}_${p}_${b}_${o}`}else{const e=n.isUniform?"uniform":n.texData.texShape;r+=`${n.shape}_${e}_${o}`}}));const o=e.userCode;let i=e.constructor.name;return i+="_"+r+"_"+o+`${t.env().getNumber("WEBGL_VERSION")}`,i}(e,d,h),x=this.getAndSaveBinary(f,(()=>function(e,n,a,r){const o=a.map(((e,t)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:n.variableNames[t],shapeInfo:a}})),i=o.map((e=>e.shapeInfo)),s={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=xe(o,s,n),l=C(e.gl,u),c=e.createProgram(l);return t.env().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:i,outShapeInfo:s,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:n,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:i,outShapeInfo:s},Ee(e,n,c))}(this.gpgpu,e,d,h))),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),t.env().get("ENGINE_COMPILE_ONLY")||function(e,n,a,r,o){n.program.enableShapeUniforms||(Ne(n.inShapeInfos,a),Ne([n.outShapeInfo],[r]));const i=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,s[0],s[1]):e.setOutputMatrixTexture(i.texture,s[0],s[1]),e.setProgram(n.webGLProgram),1===t.env().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&e.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&e.gl.uniform1f(n.nanLoc,NaN),a.forEach(((a,r)=>{const o=n.program.variableNames[r],i=n.uniformLocations[o],s=n.uniformLocations[`offset${o}`],u=n.inShapesLocations[`${o}Shape`],l=n.inTexShapesLocations[`${o}TexShape`];if(u){const{uniformShape:t}=we(n.program.packedInputs,a.shape,a.texData.texShape);switch(t.length){case 1:e.gl.uniform1iv(u,new Int32Array(t));break;case 2:e.gl.uniform2iv(u,new Int32Array(t));break;case 3:e.gl.uniform3iv(u,new Int32Array(t));break;case 4:e.gl.uniform4iv(u,new Int32Array(t))}}if(l&&e.gl.uniform2i(l,a.texData.texShape[0],a.texData.texShape[1]),null!=i)if(a.isUniform)if(t.util.sizeFromShape(a.shape)<2)e.gl.uniform1f(i,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(i,t)}else null!=a.texData.slice&&null!=s&&e.gl.uniform1i(s,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,i,r)}));const u=n.outShapeLocation;if(u)switch(r.shape.length){case 1:e.gl.uniform1iv(u,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(u,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(u,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(u,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const a=t.util.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(a));break;case 3:e.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(a));break;case 4:e.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(a))}}n.outTexShapeLocation&&e.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&o&&n.program.customUniforms.forEach(((t,a)=>{const r=n.customUniformLocations[a],i=o[a];if("float"===t.type)e.gl.uniform1fv(r,i);else if("vec2"===t.type)e.gl.uniform2fv(r,i);else if("vec3"===t.type)e.gl.uniform3fv(r,i);else if("vec4"===t.type)e.gl.uniform4fv(r,i);else if("int"===t.type)e.gl.uniform1iv(r,i);else if("ivec2"===t.type)e.gl.uniform2iv(r,i);else if("ivec3"===t.type)e.gl.uniform3iv(r,i);else{if("ivec4"!==t.type)throw Error(`uniform type ${t.type} is not supported yet.`);e.gl.uniform4iv(r,i)}})),e.executeProgram()}(this.gpgpu,x,d,h,r),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const b=t.env().get("WEBGL_FLUSH_THRESHOLD");if(b>0){const e=t.util.now();e-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!t.env().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&!1===o){const e=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),e}return s}compileAndRun(e,t,n,a,r=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!t.env().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=t.tidy((()=>{if(!t.env().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=t.env().getBool("DEBUG");t.env().set("DEBUG",!1);const n=this.abs(t.scalar(1e-8)).dataSync()[0];if(t.env().set("DEBUG",e),n>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const n=this.texData.get(e),{shape:a,dtype:r,values:o,texture:i,usage:s,isPacked:u}=n;if(null!=i)return;const c=null!=this.activeTimers;let d;c&&(d=t.util.now());let p=n.texShape;if(null==p&&(p=X(a,u),n.texShape=p),null!=o){const e=z(a);let i,s=p[1],f=p[0];const x=o instanceof Uint8Array||o instanceof Uint8ClampedArray;!u&&x||([s,f]=h(p[0],p[1])),i=u?new Le(e,x):new Pe(e,x);const m=x?[f,s]:p,g=this.makeTensorInfo(m,r),b=this.texData.get(g.dataId);b.usage=x?l.PIXELS:l.UPLOAD,b.texShape=m,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId),s,f,o);const v=[[f,s]],C=!0,$=this.runWebGLProgram(i,[g],r,v,C),I=this.texData.get($.dataId);n.texShape=I.texShape,n.isPacked=I.isPacked,n.usage=I.usage,t.env().get("ENGINE_COMPILE_ONLY")?this.disposeData($.dataId):(n.texture=I.texture,n.values=null,this.texData.delete($.dataId)),this.disposeIntermediateTensorInfo(g),c&&(this.uploadWaitMs+=t.util.now()-d)}else{const e=this.acquireTexture(p,s,r,u);n.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,n){return e[0]*e[1]*t.util.bytesPerElement(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await t.nextFrame(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw I(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,inShapesLocations:o,inTexShapesLocations:i,outShapeLocation:s,outShapeStridesLocation:u,outTexShapeLocation:l}=Ee(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.inShapesLocations=o,e.inTexShapesLocations=i,e.outShapeLocation=s,e.outShapeStridesLocation=u,e.outTexShapeLocation=l}}}Vn.nextDataId=0;function Wn(){t.env().set("WEBGL_FORCE_F16_TEXTURES",!0)}t.device_util.isBrowser()&&t.registerBackend("webgl",(()=>new Vn),2);const Mn={forceHalfFloat:Wn};class Gn{constructor(e,n,a){this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,a),this.enableShapeUniforms=Ae(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class zn{constructor(e,n,a,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,a);const o=this.outputShape.length;this.enableShapeUniforms=Ae(o);let i="";if(r)if(0===o||1===t.util.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(i=`\n          ${Se(o)} coords = getOutputCoords();\n        `,1===o)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Sn("coords",o);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function Xn(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const Hn={kernelName:t.Identity,backendName:"webgl",kernelFunc:Xn};function jn(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,o=n.makeTensorInfo(a.shape,"complex64"),i=n.texData.get(o.dataId),s=Xn({inputs:{x:a},backend:n}),u=Xn({inputs:{x:r},backend:n});return i.complexTensorInfos={real:s,imag:u},o}const Kn={kernelName:t.Complex,backendName:"webgl",kernelFunc:jn},qn="return (a < 0.) ? b * a : a;",Yn="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const Qn={kernelName:t.LeakyRelu,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{alpha:i}=r,s=a.makeTensorInfo([],"float32",t.util.createScalarValue(i,"float32")),u=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zn(Yn,o.shape,s.shape):new Gn(qn,o.shape,s.shape),l=a.runWebGLProgram(u,[o,s],"float32");return a.disposeIntermediateTensorInfo(s),l}},Zn="return (a < 0.) ? b * a : a;",Jn="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const ea={kernelName:t.Prelu,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r,alpha:o}=n,i=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zn(Jn,r.shape,o.shape):new Gn(Zn,r.shape,o.shape);return a.runWebGLProgram(i,[r,o],"float32")}};function ta({opSnippet:e,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}){return({inputs:o,backend:i})=>{const{x:s}=o,u=i,l=r||s.dtype;if(u.shouldExecuteOnCPU([s])&&null!=a){const e=u.texData.get(s.dataId),t=a(e.values,l);return u.makeTensorInfo(s.shape,l,t)}let c;return c=t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Dn(s.shape,n):new Fn(s.shape,e),u.runWebGLProgram(c,[s],l)}}function na({opSnippet:e,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:i}){return({inputs:s,backend:u})=>{const{a:l,b:c}=s,d=u;if(r&&"complex64"===l.dtype){const n=d.texData.get(l.dataId),a=d.texData.get(c.dataId),[r,o]=[[n.complexTensorInfos.real,a.complexTensorInfos.real],[n.complexTensorInfos.imag,a.complexTensorInfos.imag]].map((n=>{const[a,r]=n,o={dataId:a.dataId,dtype:a.dtype,shape:l.shape},i={dataId:r.dataId,dtype:r.dtype,shape:c.shape},s=new Gn(e,l.shape,c.shape);return d.runWebGLProgram(s,[o,i],t.upcastType(a.dtype,r.dtype))})),i=jn({inputs:{real:r,imag:o},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(o),i}const p=i||t.upcastType(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([l,c]))&&null!=o){const e=d.texData.get(l.dataId).values,n=d.texData.get(c.dataId).values,a="string"===l.dtype?t.backend_util.fromUint8ToStringArray(e):e,r="string"===l.dtype?t.backend_util.fromUint8ToStringArray(n):n,[i,s]=o(l.shape,c.shape,a,r,p),u=d.makeTensorInfo(s,p);return d.texData.get(u.dataId).values=i,u}let h;return h=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new zn(n,l.shape,c.shape,a):new Gn(e,l.shape,c.shape),d.runWebGLProgram(h,[l,c],p)}}function aa(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?Jn:Zn;if("leakyrelu"===e)return t?Yn:qn;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class ra{constructor(e,t,n,a=!1,r=!1,o=!1,i=null,s=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=Ae(this.outputShape.length);const l=a?e[1]:e[2],c=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",h=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",m="";i&&(x=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,m="result = activation(result);");const g=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(v=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${x}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${b};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}const oa="return areal * breal - aimag * bimag;",ia="return areal * bimag + aimag * breal;";class sa{constructor(e,n,a){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,a),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const ua="return a * b;";function la(e){const{inputs:n,backend:a}=e,{a:r,b:o}=n,i=t.backend_util.upcastType(r.dtype,o.dtype);if("complex64"===r.dtype){const e=a.texData.get(r.dataId),t=a.texData.get(o.dataId),n=new sa(oa,r.shape,o.shape),i=new sa(ia,r.shape,o.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape}],u=a.runWebGLProgram(n,s,"float32"),l=a.runWebGLProgram(i,s,"float32"),c=jn({inputs:{real:u,imag:l},backend:a});return a.disposeIntermediateTensorInfo(u),a.disposeIntermediateTensorInfo(l),c}if(a.shouldExecuteOnCPU([r,o])){const e=a.texData.get(r.dataId),t=a.texData.get(o.dataId),[n,s]=tn(r.shape,o.shape,e.values,t.values,i),u=a.makeTensorInfo(s,i);return a.texData.get(u.dataId).values=n,u}let s;return s=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zn(ua,r.shape,o.shape):new Gn(ua,r.shape,o.shape),a.runWebGLProgram(s,[r,o],i)}const ca={kernelName:t.Multiply,backendName:"webgl",kernelFunc:la};function da(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{shape:i}=r,s=a,u=t.util.sizeFromShape(o.shape),l=t.util.inferFromImplicitShape(i,u),c=t.util.sizeFromShape(l);t.util.assert(u===c,(()=>`The new shape (${l}) has ${c} elements and the old shape (${o.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`));const d=s.texData.get(o.dataId);return!d.isPacked||j(o.shape,l)||null!==d.texture&&j(d.shape,l)?(s.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype}):function(e,t,n){const a=[M(e.shape),...G(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[M(t),...G(t)],i=new Rn(o,a),s=[a],u=n.runWebGLProgram(i,[r],e.dtype,s,!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(o,l,s)}const pa={kernelName:t.Reshape,backendName:"webgl",kernelFunc:da};class ha{constructor(e,n){this.variableNames=["x"];const{windowSize:a,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];const s=4*Math.floor(a/4),u=a%4;let l="sumValue += dot(values, ones);";if(null!=n){const e=1/n;l=`sumValue += dot(values * ${t.util.isInt(e)?e.toPrecision(2):e}, ones);`}let c="";o%a>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class fa{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];let i="0.0",s="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",s="min"):"max"===t&&(i="-1.0 / 1e-20",s="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${s}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${s}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}function xa(e,n,a,r){const o=function(e){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const a=n.length?n[n.length-1].outSize:e[1],r=t.backend_util.computeOptimalWindowSize(a);n.push({inSize:a,windowSize:r,outSize:Math.ceil(a/r)})}return n}(e.shape);let i=e;for(let t=0;t<o.length;t++){const{inSize:s,windowSize:u,outSize:l}=o[t];let c,d;c="mean"===a?0===t?new ha({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:l},s):new ha({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:l}):new fa({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:l},a),d=i,i=r.runWebGLProgram(c,[i],n),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return i}class ma{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const a=Se(this.rank),r=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let t=0;t<e.length;t++)a[e[t]]=n[t];return a.join()}(t);this.userCode=`\n    void main() {\n      ${a} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class ga{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const a=Se(this.rank),r=yn("rc",this.rank),o=new Array(this.rank);for(let e=0;e<t.length;e++)o[t[e]]=r[e];const i=`vec2(${o.slice(-2).join()})`,s=`++${r[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${s}) {\n        result[1] = ${u};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${s}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function ba(e,n,a){const r=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ga(e.shape,n):new ma(e.shape,n);return a.runWebGLProgram(r,[e],e.dtype)}function va(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i,keepDims:s}=r;return function(e,n,a,r){const o=n,i=e.shape.length,s=t.util.parseAxisParam(o,e.shape);let u=s;const l=t.backend_util.getAxesPermutation(u,i),c=null!=l;let d=e;c&&(d=ba(e,l,r),u=t.backend_util.getInnerMostAxes(u.length,i)),t.backend_util.assertAxesAreInnerMostDims("sum",u,i);const[p,h]=t.backend_util.computeOutAndReduceShapes(d.shape,u);let f=p;a&&(f=t.backend_util.expandShapeToKeepDim(p,s));const x=t.util.sizeFromShape(h),m=da({inputs:{x:d},attrs:{shape:[t.util.sizeFromShape(e.shape)/x,x]},backend:r}),g=xa(m,t.sumOutType(e.dtype),"sum",r),b=da({inputs:{x:g},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),c&&r.disposeIntermediateTensorInfo(d),b}(o,i,s,a)}const Ca={kernelName:t.Sum,backendName:"webgl",kernelFunc:va};function $a(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:o}=a,i=n,s=r.shape.length,u=new Array(s);for(let e=0;e<u.length;e++)u[e]=r.shape[o[e]];let l;if(i.shouldExecuteOnCPU([r])){const e=i.texData.get(r.dataId).values,t=In(e,r.shape,r.dtype,o,u);l=i.makeTensorInfo(u,r.dtype);i.texData.get(l.dataId).values=t}else l=ba(r,o,i);return l}const Ia={kernelName:t.Transpose,backendName:"webgl",kernelFunc:$a};function ka({a:e,b:n,transposeA:a,transposeB:r,backend:o,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:u=0,activation:l=null}){const c=e.shape.length,d=n.shape.length,p=a?e.shape[c-2]:e.shape[c-1],h=r?n.shape[d-1]:n.shape[d-2],f=a?e.shape[c-1]:e.shape[c-2],x=r?n.shape[d-2]:n.shape[d-1],m=e.shape.slice(0,-2),g=n.shape.slice(0,-2),b=t.util.sizeFromShape(m),v=t.util.sizeFromShape(g),C=t.broadcast_util.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,x]);t.util.assert(p===h,(()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${a} and transposeB=${r} must match.`));const $=a?[b,p,f]:[b,f,p],I=r?[v,x,h]:[v,h,x],k=da({inputs:{x:e},backend:o,attrs:{shape:$}}),y=da({inputs:{x:n},backend:o,attrs:{shape:I}}),S=[k,y],w=Math.max(b,v),R=a?k.shape[1]:k.shape[2],T=null!=i,E=null!=s,N="leakyrelu"===l,A=null!=l?aa(l,!0):null;let F;if((1===f||1===x)&&R>1e3&&!1===(T||E||N||null!=A)){let e=k,t=y;a&&(e=$a({inputs:{x:k},backend:o,attrs:{perm:[0,2,1]}}),S.push(e)),r&&(t=$a({inputs:{x:y},backend:o,attrs:{perm:[0,2,1]}}),S.push(t));const n=1===x;let i=e;1!==x&&(i=da({inputs:{x:e},backend:o,attrs:{shape:[w,R,1]}}),S.push(i));const s=1===x?2:1;let u=t;n&&(u=da({inputs:{x:t},backend:o,attrs:{shape:[w,1,R]}}),S.push(u));const l=la({inputs:{a:i,b:u},backend:o});F=va({inputs:{x:l},backend:o,attrs:{axis:s,keepDims:!0}}),S.push(l)}else{const l=t.upcastType(e.dtype,n.dtype),c=new ra($,I,[w,f,x],a,r,T,A,E,N),d=[k,y];if(null!=i&&d.push(i),E&&d.push(s),N){const e=o.makeTensorInfo([],"float32",t.util.createScalarValue(u,"float32"));d.push(e),S.push(e)}F=o.runWebGLProgram(c,d,l)}const _=da({inputs:{x:F},backend:o,attrs:{shape:C}});S.push(F);for(const e of S)o.disposeIntermediateTensorInfo(e);return _}const ya={kernelName:t._FusedMatMul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o,bias:i,preluActivationWeights:s}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=a;return ka({a:r,b:o,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:s,leakyreluAlpha:d,activation:c})}},Sa="return abs(x);";const wa={kernelName:t.Abs,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r}=n;if(a.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=a.texData.get(r.dataId),t=ln(e.values);return a.makeTensorInfo(r.shape,r.dtype,t)}let o;return o=t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Dn(r.shape,Sa):new Fn(r.shape,Sa),a.runWebGLProgram(o,[r],r.dtype)}},Ra=ta({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Ta={kernelName:t.Acos,backendName:"webgl",kernelFunc:Ra},Ea=ta({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Na={kernelName:t.Acosh,backendName:"webgl",kernelFunc:Ea},Aa="return a + b;",Fa=na({opSnippet:Aa,packedOpSnippet:Aa,supportsComplex:!0,cpuKernelImpl:Dt}),_a={kernelName:t.Add,backendName:"webgl",kernelFunc:Fa};class Oa{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}class Da{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}const Pa={kernelName:t.AddN,backendName:"webgl",kernelFunc:function e(n){const{inputs:a,backend:r}=n,o=a;if(1===o.length)return Xn({inputs:{x:o[0]},backend:r});if(o.length>t.env().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(o.length/2),n=e({inputs:o.slice(0,t),backend:r}),a=e({inputs:o.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const i=o.map((e=>e.dtype)).reduce(((e,n)=>t.upcastType(e,n))),s=o.map((e=>e.shape)),u=t.env().getBool("WEBGL_PACK")?new Da(o[0].shape,s):new Oa(o[0].shape,s);return r.runWebGLProgram(u,o,i)}};const La={kernelName:t.All,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i,keepDims:s}=r,u=o.shape.length,l=t.util.parseAxisParam(i,o.shape);let c=l;const d=t.backend_util.getAxesPermutation(c,u);let p=o;null!=d&&(p=$a({inputs:{x:o},backend:a,attrs:{perm:d}}),c=t.backend_util.getInnerMostAxes(c.length,u)),t.backend_util.assertAxesAreInnerMostDims("all",c,u);const[h,f]=t.backend_util.computeOutAndReduceShapes(p.shape,c),x=da({inputs:{x:p},backend:a,attrs:{shape:[-1,t.util.sizeFromShape(f)]}}),m=xa(x,x.dtype,"all",a);let g;if(s){g=da({inputs:{x:m},backend:a,attrs:{shape:t.backend_util.expandShapeToKeepDim(h,l)}})}else g=da({inputs:{x:m},backend:a,attrs:{shape:h}});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(m),null!=d&&a.disposeIntermediateTensorInfo(p),g}};const Ba={kernelName:t.Any,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i,keepDims:s}=r,u=o.shape.length,l=t.util.parseAxisParam(i,o.shape);let c=l;const d=t.backend_util.getAxesPermutation(c,u);let p=o;null!=d&&(p=$a({inputs:{x:o},backend:a,attrs:{perm:d}}),c=t.backend_util.getInnerMostAxes(c.length,u)),t.backend_util.assertAxesAreInnerMostDims("any",c,u);const[h,f]=t.backend_util.computeOutAndReduceShapes(p.shape,c),x=da({inputs:{x:p},backend:a,attrs:{shape:[-1,t.util.sizeFromShape(f)]}}),m=xa(x,x.dtype,"any",a);let g;if(s){g=da({inputs:{x:m},backend:a,attrs:{shape:t.backend_util.expandShapeToKeepDim(h,l)}})}else g=da({inputs:{x:m},backend:a,attrs:{shape:h}});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(m),null!=d&&a.disposeIntermediateTensorInfo(p),g}};class Ua{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const i="max"===t?">":"<",s=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${s};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class Va{constructor(e,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,t.util.assert(e.length>2,(()=>`Packed arg${a.charAt(0).toUpperCase()+a.slice(1)} supports only inputs with rank above 2.`));const o=e[e.length-1],i=Math.ceil(o/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const s=this.outputShape,u=s.length,l=Se(u),c=Sn("coords",u);let d,p;if(1===i){p=u+1;const e=Se(p);d=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else p=u,d=`\n        ${l} sourceLocR = coords;\n        ++${c[u-1]};\n        ${l} sourceLocG = coords;\n        ++${c[u-2]};\n        ${l} sourceLocA = coords;\n        --${c[u-1]};\n        ${l} sourceLocB = coords;\n        --${c[u-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],x=h.map((e=>"int "+e)),m=Sn("sourceLocR",p-1).concat("inIdx.r"),g=Sn("sourceLocG",p-1).concat("inIdx.g"),b=Sn("sourceLocB",p-1).concat("inIdx.b"),v=Sn("sourceLocA",p-1).concat("inIdx.a"),C="max"===a?"greaterThan":"lessThan",$=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,I=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${x.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${x.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${s[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${s[u-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${n};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${n}; i++) {\n          inIdx = srcIdx;\n          ${$}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Wa(e,n,a,r=null){let o=n.shape[0],i=n.shape[1];null!=r&&(o=r.shape[0],i=r.shape[1]);const s=t.backend_util.computeOptimalWindowSize(i),u={windowSize:s,inSize:i,batchSize:o,outSize:Math.ceil(i/s)},l=new Ua(u,a,null==r),c=[n];null!=r&&c.push(r);const d=e.runWebGLProgram(l,c,"int32");if(1===d.shape[1])return d;const p=Wa(e,n,a,d);return e.disposeIntermediateTensorInfo(d),p}function Ma(e,n,a,r=null){const o=null!=r?r.shape:n.shape,i=o[o.length-1],s=t.backend_util.computeOptimalWindowSize(i),u=new Va(o,s,a,null==r),l=null==r?[n]:[n,r],c=e.runWebGLProgram(u,l,"int32");if(c.shape.length===n.shape.length){const t=Ma(e,n,a,c);return e.disposeIntermediateTensorInfo(c),t}return c}function Ga(e,n,a,r){const o=[a];if(t.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,n.shape.length),!t.env().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const a=[],i=e.texData.get(n.dataId);let s=n;null!==i&&i.isPacked&&(s=e.unpackTensor(n),a.push(s));const[u,l]=t.backend_util.computeOutAndReduceShapes(s.shape,o),c=t.util.sizeFromShape(l),d=da({inputs:{x:s},backend:e,attrs:{shape:[-1,c]}});a.push(d);const p=Wa(e,d,r);a.push(p);const h=da({inputs:{x:p},backend:e,attrs:{shape:u}});return a.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return Ma(e,n,r)}const za={kernelName:t.ArgMax,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i}=r;let s=t.util.parseAxisParam(i,o.shape);const u=t.backend_util.getAxesPermutation(s,o.shape.length);let l=o;const c=[];null!=u&&(l=$a({inputs:{x:o},backend:a,attrs:{perm:u}}),c.push(l),s=t.backend_util.getInnerMostAxes(s.length,l.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMax",[s[0]],l.shape.length);const d=Ga(a,l,s[0],"max");return c.forEach((e=>a.disposeIntermediateTensorInfo(e))),d}};const Xa={kernelName:t.ArgMin,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i}=r;let s=t.util.parseAxisParam(i,o.shape);const u=t.backend_util.getAxesPermutation(s,o.shape.length);let l=o;const c=[];null!=u&&(l=$a({inputs:{x:o},backend:a,attrs:{perm:u}}),c.push(l),s=t.backend_util.getInnerMostAxes(s.length,l.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMin",[s[0]],l.shape.length);const d=Ga(a,l,s[0],"min");return c.forEach((e=>a.disposeIntermediateTensorInfo(e))),d}},Ha=ta({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),ja={kernelName:t.Asin,backendName:"webgl",kernelFunc:Ha},Ka=ta({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),qa={kernelName:t.Asinh,backendName:"webgl",kernelFunc:Ka},Ya=ta({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Qa={kernelName:t.Atan,backendName:"webgl",kernelFunc:Ya},Za=na({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Ja={kernelName:t.Atan2,backendName:"webgl",kernelFunc:Za},er=ta({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),tr={kernelName:t.Atanh,backendName:"webgl",kernelFunc:er};class nr{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,m=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let g="0.0";if(f||(g="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${s});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${a?r?x:m:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / count");const v=4*Math.floor(o/4),C=o%4,$=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${s});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${g};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${g});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${$}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${$}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${$}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${$}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class ar{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,s=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,x=e.padInfo.front,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${s}, ${u});\n        const ivec3 pads = ivec3(${x}, ${m}, ${g});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(C="avgValue / count");const $=4*Math.floor(o/4),I=o%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${s}, ${u});\n      const ivec3 pads = ivec3(${x}, ${m}, ${g});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${$}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${$};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}const rr={kernelName:t.AvgPool,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n;oe(o,"avgPool");const{filterSize:i,strides:s,pad:u,dimRoundingMode:l}=r;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(s,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`));const c=t.backend_util.computePool2DInfo(o.shape,i,s,1,u,l);if(1===c.filterWidth&&1===c.filterHeight&&t.util.arraysEqual(c.inShape,c.outShape))return Xn({inputs:{x:o},backend:a});const d=new nr(c,"avg",!1);return a.runWebGLProgram(d,[o],"float32")}};const or={kernelName:t.AvgPool3D,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{filterSize:i,strides:s,pad:u,dimRoundingMode:l,dataFormat:c}=r,d=t.backend_util.computePool3DInfo(o.shape,i,s,[1,1,1],u,l,c),p=new ar(d,"avg",!1);return a.runWebGLProgram(p,[o],"float32")}};class ir{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=s-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n            wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class sr{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,f=d-1-e.padInfo.top,x=p-1-e.padInfo.left,m=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${x});\n      const float avgMultiplier = float(${m});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const ur={kernelName:t.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:o,input:i}=n,s=i,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,p=t.backend_util.computePool3DInfo(s.shape,u,l,[1,1,1],c,d),h=new sr(p);return a.runWebGLProgram(h,[o],s.dtype)}};const lr={kernelName:t.AvgPoolGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:o,input:i}=n,s=i;oe([o,i],"avgPoolGrad");const{filterSize:u,strides:l,pad:c}=r,d=t.backend_util.computePool2DInfo(s.shape,u,l,1,c),p=new ir(d);return a.runWebGLProgram(p,[o],s.dtype)}};const cr={kernelName:t.BatchMatMul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:o}=t,{transposeA:i,transposeB:s}=a;return ka({a:r,b:o,transposeA:i,transposeB:s,backend:n})}};class dr{constructor(e,n,a,r,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,a);let s="0.0";null!=r&&(t.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let u="1.0";null!=o&&(t.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${s};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class pr{constructor(e,n,a,r,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,a);let s="vec4(0.0)";null!=r&&(t.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=o&&(t.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${s};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const hr={kernelName:t.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:a})=>{const{x:r,mean:o,variance:i,offset:s,scale:u}=e;t.util.assert(o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),t.util.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),t.util.assert(null==u||o.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=a;null==l&&(l=.001);const c=[r,o,i];let d=null;null!=s&&(d=s.shape,c.push(s));let p=null;null!=u&&(p=u.shape,c.push(u));const h=t.env().getBool("WEBGL_PACK_NORMALIZATION")?new pr(r.shape,o.shape,i.shape,d,p,l):new dr(r.shape,o.shape,i.shape,d,p,l);return n.runWebGLProgram(h,c,c[0].dtype)}};class fr{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Se(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return xr.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let a;a=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${xr[t]} = start[${t}] + coords.${xr[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${a}\n        setOutput(getSource(${n}));\n      }\n    `}}const xr=["x","y","z","w","u","v"];class mr{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Se(this.rank),n=Sn("coords",this.rank),a=Sn("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${a.slice(-2).join()})`,o=`getChannel(getSource(${a.join()}), ${r})`,i=`\n      result.x = ${o};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${o};\n        --${a[this.rank-1]};\n      }\n    `,s=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${o};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${a[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${s}\n        setOutput(result);\n      }\n    `}}function gr(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{begin:i,size:s}=r,[u,l]=t.slice_util.parseSliceParams(o,i,s);if(t.slice_util.assertParamsValid(o,u,l),0===t.util.sizeFromShape(l))return a.makeTensorInfo(l,o.dtype,[]);if(a.shouldExecuteOnCPU([o])||"string"===o.dtype){const e=a.texData.get(o.dataId),t=cn(e.values,u,l,o.shape,o.dtype);return a.makeTensorInfo(l,o.dtype,t)}const{isPacked:c}=a.texData.get(o.dataId),d=t.slice_util.isSliceContinous(o.shape,u,l);if(c||!d){const e=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mr(l):new fr(l),n=[u];return a.runWebGLProgram(e,[o],o.dtype,n)}return a.uploadToGPU(o.dataId),function(e,n,a,r){const o=r.texData.get(e.dataId),i=r.makeTensorInfo(a,e.dtype),s=r.texData.get(i.dataId);Object.assign(s,o),s.refCount=1,s.shape=a,s.dtype=e.dtype;let u=t.slice_util.computeFlatOffset(n,t.util.computeStrides(e.shape));o.slice&&(u+=o.slice.flatOffset),s.slice={flatOffset:u,origDataId:o.slice&&o.slice.origDataId||e.dataId};const l=r.dataRefCount.get(s.slice.origDataId)||1;return r.dataRefCount.set(s.slice.origDataId,l+1),i}(o,u,l,a)}const br={kernelName:t.Slice,backendName:"webgl",kernelFunc:gr},vr={kernelName:t.BatchToSpaceND,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{blockShape:i,crops:s}=r;t.util.assert(o.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const u=i.reduce(((e,t)=>e*t)),l=t.backend_util.getReshaped(o.shape,i,u),c=t.backend_util.getPermuted(l.length,i.length),d=t.backend_util.getReshapedPermuted(o.shape,i,u),p=t.backend_util.getSliceBeginCoords(s,i.length),h=t.backend_util.getSliceSize(d,s,i.length),f=[],x=da({inputs:{x:o},backend:a,attrs:{shape:l}}),m=$a({inputs:{x:x},backend:a,attrs:{perm:c}}),g=da({inputs:{x:m},backend:a,attrs:{shape:d}}),b=gr({inputs:{x:g},backend:a,attrs:{begin:p,size:h}});return f.push(x),f.push(m),f.push(g),f.forEach((e=>a.disposeIntermediateTensorInfo(e))),b}};const Cr={kernelName:t.Bincount,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:i}=a,s=n.readSync(r.dataId),u=n.readSync(o.dataId),l=Pt(s,u,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,l)}};const $r={kernelName:t.BroadcastArgs,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{s0:r,s1:o}=n,i=a.readSync(r.dataId),s=a.readSync(o.dataId),u=t.backend_util.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return a.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},Ir=na({opSnippet:"return float(a != b);",cpuKernelImpl:an,dtype:"bool"}),kr={kernelName:t.NotEqual,backendName:"webgl",kernelFunc:Ir};function yr(e){const{inputs:t,backend:n}=e,{input:a}=t;return Xn({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const Sr={kernelName:t.Real,backendName:"webgl",kernelFunc:yr};const wr={kernelName:t.Cast,backendName:"webgl",kernelFunc:function e(n){const{inputs:r,backend:o,attrs:i}=n,{x:s}=r,{dtype:u}=i;if("complex64"===u){if("complex64"===s.dtype)return Xn({inputs:{x:s},backend:o});const t=a.zeros(s.shape),n=e({inputs:{x:s},backend:o,attrs:{dtype:"float32"}}),r=jn({inputs:{real:n,imag:t},backend:o});return t.dispose(),o.disposeIntermediateTensorInfo(n),r}if("complex64"===s.dtype){const t=yr({inputs:{input:s},backend:o}),n=e({inputs:{x:t},backend:o,attrs:{dtype:u}});return o.disposeIntermediateTensorInfo(t),n}if(!t.util.hasEncodingLoss(s.dtype,u)){const e=Xn({inputs:{x:s},backend:o});return{dataId:e.dataId,shape:e.shape,dtype:u}}if("int32"===u)return function(e,t){const n=new Fn(e.shape,"return float(int(x));"),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(s,o);if("bool"===u){const e=o.makeTensorInfo([],"bool",t.util.getTypedArrayFromDType("bool",1)),n=Ir({inputs:{a:s,b:e},backend:o});return o.disposeIntermediateTensorInfo(e),n}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${u}`)}},Rr="return ceil(x);",Tr=ta({opSnippet:Rr,packedOpSnippet:Rr,cpuKernelImpl:Bt}),Er={kernelName:t.Ceil,backendName:"webgl",kernelFunc:Tr};class Nr{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Ar{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Fr={kernelName:t.ClipByValue,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{clipValueMin:i,clipValueMax:s}=r;let u;u=t.env().getBool("WEBGL_PACK_CLIP")?new Ar(o.shape):new Nr(o.shape);const l=[[i],[s]];return a.runWebGLProgram(u,[o],o.dtype,l)}};class _r{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Or(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const Dr={kernelName:t.ComplexAbs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),o=new _r(a.shape),i=[Or(a,r.complexTensorInfos.real),Or(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}};class Pr{constructor(e){this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const n=new Array(e.length-1);n[0]=e[0][1];for(let t=1;t<n.length;t++)n[t]=n[t-1]+e[t][1];const a=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<n.length;e++){const t=n[e-1];a.push(`else if (yC < ${n[e]}) setOutput(getT${e}(yR, yC-${t}));`)}const r=n.length,o=n[n.length-1];a.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${a.join("\n        ")}\n      }\n    `}}class Lr{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(e,n);const a=this.outputShape,r=a.length,o=Se(r),i=Sn("coords",r),s=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const u=new Array(e.length-1);u[0]=e[0][n];for(let t=1;t<u.length;t++)u[t]=u[t-1]+e[t][n];const l=s[n],c=s.slice(-2),d=s.join();let p=`if (${l} < ${u[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let e=1;e<u.length;e++){const t=u[e-1];p+=`\n        if (${l} < ${u[e]}  && ${l} >= ${u[e-1]}) {\n          return getChannel(\n            getT${e}(${Br(s,l,t)}),\n            vec2(${Br(c,l,t)}));\n        }`}const h=u.length,f=u[u.length-1];p+=`\n        return getChannel(\n          getT${h}(${Br(s,l,f)}),\n          vec2(${Br(c,l,f)}));`,this.userCode=`\n      float getValue(${s.map((e=>"int "+e))}) {\n        ${p}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${a[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${a[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${a[r-2]} &&\n            ${i[r-1]} < ${a[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Br(e,t,n){const a=e.indexOf(t);return e.map(((e,t)=>t===a?`${e} - ${n}`:e)).join()}function Ur(e){const{inputs:t,backend:n}=e,{input:a}=t;return Xn({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const Vr={kernelName:t.Imag,backendName:"webgl",kernelFunc:Ur};function Wr(e,n,a){const r=e[0].dtype;if("complex64"===r){const t=e.map((e=>yr({inputs:{input:e},backend:a}))),r=e.map((e=>Ur({inputs:{input:e},backend:a}))),o=Wr(t,n,a),i=Wr(r,n,a),s=jn({inputs:{real:o,imag:i},backend:a});return t.forEach((e=>a.disposeIntermediateTensorInfo(e))),r.forEach((e=>a.disposeIntermediateTensorInfo(e))),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(i),s}let o=a.shouldExecuteOnCPU(e);if("string"===r&&(o=!0),o){const o=e.map((e=>{const r=t.util.sizeFromShape(e.shape.slice(n));return da({inputs:{x:e},backend:a,attrs:{shape:[-1,r]}})})),i=o.map((e=>({vals:a.readSync(e.dataId),shape:e.shape}))),s=t.backend_util.computeOutShape(o.map((e=>e.shape)),1),u=1===o[0].shape[0],l=Ut(i,s,r,u),c=t.backend_util.computeOutShape(e.map((e=>e.shape)),n),d=a.makeTensorInfo(c,r,l);return o.forEach((e=>a.disposeIntermediateTensorInfo(e))),d}if(e.length>t.env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(e.length/2),r=Wr(e.slice(0,t),n,a),o=Wr(e.slice(t),n,a),i=Wr([r,o],n,a);return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(o),i}if(t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const t=new Lr(e.map((e=>e.shape)),n);return a.runWebGLProgram(t,e,r)}const{tensors2D:i,outShape:s}=function(e,n,a){const r=t.backend_util.computeOutShape(e.map((e=>e.shape)),n);return{tensors2D:e.map((e=>da({inputs:{x:e},attrs:{shape:[-1,t.util.sizeFromShape(e.shape.slice(n))]},backend:a}))),outShape:r}}(e,n,a),u=new Pr(i.map((e=>e.shape))),l=a.runWebGLProgram(u,i,r);i.forEach((e=>a.disposeIntermediateTensorInfo(e)));const c=da({inputs:{x:l},attrs:{shape:s},backend:a});return a.disposeIntermediateTensorInfo(l),c}function Mr(e){const{inputs:n,backend:a,attrs:r}=e,{axis:o}=r,i=t.util.parseAxisParam(o,n[0].shape)[0],s=t.backend_util.computeOutShape(n.map((e=>e.shape)),i);if(0===t.util.sizeFromShape(s))return a.makeTensorInfo(s,n[0].dtype,[]);const u=n.filter((e=>t.util.sizeFromShape(e.shape)>0));if(1===u.length)return Xn({inputs:{x:u[0]},backend:a});const l=u.map((e=>e.shape));return t.backend_util.assertParamsConsistent(l,i),Wr(u,i,a)}const Gr={kernelName:t.Concat,backendName:"webgl",kernelFunc:Mr};class zr{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,s=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,x="channelsLast"===e.dataFormat,m=x?1:2,g=x?2:3,b=x?3:1;let v="",C="";n&&(v=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,C="result = activation(result);");const $=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${s}, ${u});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${x}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${x}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${x}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${x}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${$}\n        ${C}\n        setOutput(result);\n      }\n    `}}class Xr{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${o}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${s};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Hr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ae(this.outputShape.length);const{dataFormat:n}=t,a=ue(),r="channelsLast"===n,o=r?0:1,i=r?1:2,s=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let u="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)u+=`\n          blockIndex = rc.y + ${t};\n          pos = rc.x + ${e};\n\n          ${s}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${a.output} = result;\n      }\n    `}}function jr({x:e,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:u=null}){const l=e.shape,c=r.texData.get(e.dataId),d=a.inChannels,p=l[0]*l[1]*l[2],h=a.outChannels,f="channelsLast"===a.dataFormat;let x;const m=[];if(!((1===p||1===h)&&d>1e3)&&c.isPacked&&f&&null!=c.texture&&l[2]%2!=0&&t.util.arraysEqual(c.shape.slice(-3),l.slice(-3))){const d=l[0]*l[1]*(l[2]+1),p={dataId:e.dataId,shape:[1,d,a.inChannels],dtype:e.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,t.util.assert(j(c.shape,p.shape),(()=>`packed reshape ${c.shape} to ${p.shape} isn't free`));const f=da({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});m.push(f);const g=ka({a:p,b:f,backend:r,transposeA:false,transposeB:false,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:s}),b=r.texData.get(g.dataId);t.util.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,b.shape=a.outShape,x=Xn({inputs:{x:g},backend:r}),x.shape=a.outShape,m.push(g)}else{const t=da({inputs:{x:e},backend:r,attrs:{shape:[1,f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],a.inChannels]}}),c=da({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),d=ka({a:t,b:c,transposeA:false,transposeB:false,backend:r,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:s});x=da({inputs:{x:d},backend:r,attrs:{shape:a.outShape}}),m.push(t),m.push(c),m.push(d)}for(const e of m)r.disposeIntermediateTensorInfo(e);return x}function Kr({x:e,filter:n,convInfo:a,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:u=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:p,outHeight:h,dataFormat:f}=a,x="channelsLast"===f,m=l*c*d,g=h*p,b=[m,g],v=[],C=da({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),$=da({inputs:{x:n},backend:r,attrs:{shape:[1,m,t.util.sizeFromShape(n.shape)/m]}});v.push(C),v.push($);const I=new Hr(b,a),k=[C.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],y=r.runWebGLProgram(I,[C],"float32",k),S=da({inputs:{x:y},backend:r,attrs:{shape:[1,b[0],b[1]]}});v.push(y),v.push(S);const w=null!=o,R=null!=i,T="leakyrelu"===u,E=u?aa(u,!0):null,N=new ra(S.shape,$.shape,[1,g,a.outChannels],!0,!1,w,E,R,T),A=[S,$];if(o&&A.push(o),R&&A.push(i),T){const e=r.makeTensorInfo([],"float32",t.util.createScalarValue(s,"float32"));A.push(e),v.push(e)}const F=r.runWebGLProgram(N,A,"float32"),_=da({inputs:{x:F},backend:r,attrs:{shape:x?[1,h,p,a.outChannels]:[1,a.outChannels,h,p]}});v.push(F);for(const e of v)r.disposeIntermediateTensorInfo(e);return _}const qr={kernelName:t.Conv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,filter:i}=n,{strides:s,pad:u,dataFormat:l,dilations:c,dimRoundingMode:d}=r,p=t.backend_util.convertConv2DDataFormat(l),h=t.backend_util.computeConv2DInfo(o.shape,i.shape,s,c,u,d,!1,p);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(t.env().getBool("WEBGL_CONV_IM2COL")&&1===o.shape[0])f=Kr({x:o,filter:i,convInfo:h,backend:a});else{const e=new zr(h);f=a.runWebGLProgram(e,[o,i],"float32")}else f=jr({x:o,filter:i,convInfo:h,backend:a});const x=da({inputs:{x:f},backend:a,attrs:{shape:h.outShape}});return a.disposeIntermediateTensorInfo(f),x}};class Yr{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${o}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Qr{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,s=n-1-e.padInfo.left,u=o?1:2,l=o?2:3,c=o?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Zr{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${o};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${a} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Jr{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${s}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const eo={kernelName:t.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,dy:i}=n,{strides:s,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:d}=r,p=t.backend_util.convertConv2DDataFormat(l),h=t.backend_util.computeConv2DInfo(o.shape,d,s,1,u,c,!1,p),f=new Yr(h);return a.runWebGLProgram(f,[o,i],"float32")}};const to={kernelName:t.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:o,filter:i}=n,{inputShape:s,strides:u,pad:l,dataFormat:c,dimRoundingMode:d}=r,p=t.backend_util.convertConv2DDataFormat(c),h=t.backend_util.computeConv2DInfo(s,i.shape,u,1,l,d,!1,p),f=new Qr(h);return a.runWebGLProgram(f,[o,i],"float32")}};const no={kernelName:t.Conv3D,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,filter:i}=n,{strides:s,pad:u,dilations:l}=r,c=t.backend_util.computeConv3DInfo(o.shape,i.shape,s,l,u),d=new Xr(c);return a.runWebGLProgram(d,[o,i],"float32")}};const ao={kernelName:t.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,dy:i}=n,{strides:s,pad:u,filterShape:l}=r,c=t.backend_util.computeConv3DInfo(o.shape,l,s,1,u),d=new Zr(c);return a.runWebGLProgram(d,[o,i],"float32")}};const ro={kernelName:t.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:o,filter:i}=n,{pad:s,strides:u,inputShape:l}=r,c=t.backend_util.computeConv3DInfo(l,i.shape,u,1,s),d=new Jr(c);return a.runWebGLProgram(d,[o,i],"float32")}},oo=ta({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),io={kernelName:t.Cos,backendName:"webgl",kernelFunc:oo},so=ta({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),uo={kernelName:t.Cosh,backendName:"webgl",kernelFunc:so};class lo{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,s,u]=e,[l]=t,[c,d]=n;this.outputShape=[l,c,d,u];const p="bilinear"===a?1:0,[h,f]=[i-1+".0",s-1+".0"],[x,m,g]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,v,C]=d>1?[""+(s-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${x});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${m};\n        float width_scale = ${v};\n\n        float in_y = ${g};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${C};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const co={kernelName:t.CropAndResize,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:o,boxInd:i}=t,{cropSize:s,method:u,extrapolationValue:l}=a,c=new lo(r.shape,o.shape,s,u,l);return n.runWebGLProgram(c,[r,o,i],"float32")}};class po{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const a=e.length,r=t?"1.0":`getX(${ho(a,"coords")})`,o=e[e.length-1];let i="",s="";t?(i=n?"end != "+(o-1):"end != 0",s=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${o}`:"end >= pow2",s=n?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Se(a)} coords = getOutputCoords();\n        int end = ${fo(a,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${i}) {\n          int idx = ${s};\n          ${fo(a,"coords")} = idx;\n          val *= getX(${ho(a,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function ho(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative product for rank ${e} is not yet supported`)}function fo(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative product for rank ${e} is not yet supported`)}const xo={kernelName:t.Cumprod,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i,exclusive:s,reverse:u}=r,l=o.shape.length,c=t.backend_util.getAxesPermutation([i],l);let d=o;null!=c&&(d=$a({inputs:{x:o},backend:a,attrs:{perm:c}}));const p=t.backend_util.getInnerMostAxes(1,l)[0];if(p!==l-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${o.shape.length-1} but got axis=${i}`);const h=d.shape[p];let f=Xn({inputs:{x:d},backend:a});for(let e=0;e<=Math.ceil(Math.log2(h))-1;e++){const t=new po(d.shape,!1,u),n=[[e]],r=f;f=a.runWebGLProgram(t,[f],f.dtype,n),a.disposeIntermediateTensorInfo(r)}if(s){const e=new po(d.shape,s,u),t=f;f=a.runWebGLProgram(e,[f],f.dtype),a.disposeIntermediateTensorInfo(t)}if(null!=c){const e=$a({inputs:{x:f},backend:a,attrs:{perm:t.backend_util.getUndoAxesPermutation(c)}});return a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(d),e}return f}};class mo{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const a=e.length,r=t?"0.0":`getX(${go(a,"coords")})`,o=e[e.length-1];let i="",s="";t?(i=n?"end != "+(o-1):"end != 0",s=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${o}`:"end >= pow2",s=n?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Se(a)} coords = getOutputCoords();\n        int end = ${bo(a,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${i}) {\n          int idx = ${s};\n          ${bo(a,"coords")} = idx;\n          val += getX(${go(a,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function go(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function bo(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const vo={kernelName:t.Cumsum,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i,exclusive:s,reverse:u}=r,l=o.shape.length,c=t.backend_util.getAxesPermutation([i],l);let d=o;null!=c&&(d=$a({inputs:{x:o},backend:a,attrs:{perm:c}}));const p=t.backend_util.getInnerMostAxes(1,l)[0];if(p!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${i}`);const h=d.shape[p];let f=Xn({inputs:{x:d},backend:a});for(let e=0;e<=Math.ceil(Math.log2(h))-1;e++){const t=new mo(d.shape,!1,u),n=[[e]],r=f;f=a.runWebGLProgram(t,[f],f.dtype,n),a.disposeIntermediateTensorInfo(r)}if(s){const e=new mo(d.shape,s,u),t=f;f=a.runWebGLProgram(e,[f],f.dtype),a.disposeIntermediateTensorInfo(t)}if(null!=c){const e=$a({inputs:{x:f},backend:a,attrs:{perm:t.backend_util.getUndoAxesPermutation(c)}});return a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(d),e}return f}};const Co={kernelName:t.DenseBincount,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:o}=t,{size:i,binaryOutput:s}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(o.dataId),a=Pt(e,t,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(o),a=Lt(e,t,i,s);return n.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class $o{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Io={kernelName:t.DepthToSpace,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:o,dataFormat:i}=a,s=r.shape[0],u=("NHWC"===i?r.shape[1]:r.shape[2])*o,l=("NHWC"===i?r.shape[2]:r.shape[3])*o,c=("NHWC"===i?r.shape[3]:r.shape[1])/(o*o),d=new $o("NHWC"===i?[s,u,l,c]:[s,c,u,l],o,i);return n.runWebGLProgram(d,[r],r.dtype)}};class ko{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ae(this.outputShape.length);const o=e.filterHeight,i=e.filterWidth,s=e.outChannels/e.inChannels;let u="",l="";n&&(u=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,l="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${l}\n        setOutput(result);\n      }\n    `}}class yo{constructor(e,n=!1,a=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ae(this.outputShape.length);const i=e.outChannels/e.inChannels,s=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,p=d;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<d;e++)h+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;h+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<d;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(p+1)/2;e++){const n=2*e;if(h+=`\n          xC = xCCorner + ${n*l};\n          `,1===u){if(n<d&&(s%2==1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,h+=1===l&&n>0?`\n                xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${n} = xTexelC${n};\n                `,n+1<d)){const e=s%2==0?t.util.nearestLargerEven(l):l;l%2==0&&s%2==1||l%2!=0&&s%2!=1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                    xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${n+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+1}Ready = 1;\n                  }\n                  `,l>1&&(h+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),h+=`\n                  xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                  `):h+=1===e?`\n                    xC${n+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                      xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${n+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+1}Ready = 1;\n                    }\n\n                    xC${n+1} = xTexelC${n+1};\n                    `}}else n<d&&(s%2==1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                  xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${n+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+1}Ready = 1;\n                }\n\n                xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n              `,n+1<d&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                  xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${n+1}.zw = vec2(0.);\n                  }\n                  xTexelC${n+1}Ready = 1;\n                }\n\n                xC${n} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+1}.xy);\n              `,n+1<d&&(h+=`\n                  xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                `)));n<d&&(h+=`\n            wTexel = getW(r, ${n}, d1, q);\n            dotProd += xC${n} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<d&&(h+=`\n              wTexel = getW(r, ${n+1}, d1, q);\n              dotProd += xC${n+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let f="",x="";a&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,x="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${x}\n        setOutput(result);\n      }\n    `}}const So={kernelName:t.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,filter:i}=n,{strides:s,pad:u,dilations:l,dimRoundingMode:c}=r;let d=l;null==d&&(d=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(s,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`));const p=t.backend_util.computeConv2DInfo(o.shape,i.shape,s,d,u,c,!0);let h;h=t.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new yo(p):new ko(p);const f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return a.runWebGLProgram(h,[o,i],"float32",f)}};class wo{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${o} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ro{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const To={kernelName:t.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,dy:i}=n,{strides:s,dilations:u,pad:l,dimRoundingMode:c,filterShape:d}=r,p=t.backend_util.computeConv2DInfo(o.shape,d,s,u,l,c,!0),h=new wo(p);return a.runWebGLProgram(h,[o,i],"float32")}};const Eo={kernelName:t.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:o,filter:i}=n,{strides:s,dilations:u,pad:l,dimRoundingMode:c,inputShape:d}=r,p=t.backend_util.computeConv2DInfo(d,i.shape,s,u,l,c,!0),h=new Ro(p);return a.runWebGLProgram(h,[o,i],"float32")}};class No{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Ao={kernelName:t.Diag,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r}=n,o=[...r.shape,...r.shape],i=t.util.sizeFromShape(r.shape),s=da({inputs:{x:r},backend:a,attrs:{shape:[i]}}),u=new No(i),l=a.runWebGLProgram(u,[s],s.dtype),c=da({inputs:{x:l},backend:a,attrs:{shape:o}});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(l),c}};class Fo{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:o,filterHeight:i,filterWidth:s,dilationHeight:u,dilationWidth:l}=e,{top:c,left:d}=a;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${o});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${s}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const _o={kernelName:t.Dilation2D,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,filter:i}=n,{strides:s,pad:u,dilations:l}=r,c=t.backend_util.computeDilation2DInfo(o.shape,i.shape,s,u,"NHWC",l);let d;const p=new Fo(c);d=a.runWebGLProgram(p,[o,i],"float32");const h=da({inputs:{x:d},backend:a,attrs:{shape:c.outShape}});return a.disposeIntermediateTensorInfo(d),h}};const Oo={kernelName:t.Einsum,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{equation:o}=r,i=n,{allDims:s,summedDims:u,idDims:l}=t.backend_util.decodeEinsumEquation(o,i.length);t.backend_util.checkEinsumDimSizes(s.length,l,i);const{path:c,steps:d}=t.backend_util.getEinsumComputePath(u,l),p=d.length;let h=null,f=s.length;const x=[];for(let e=0;e<p;++e){for(const n of d[e]){const{permutationIndices:e,expandDims:r}=t.backend_util.getEinsumPermutation(f,l[n]);let o;t.backend_util.isIdentityPermutation(e)?o=i[n]:(o=$a({inputs:{x:i[n]},backend:a,attrs:{perm:e}}),x.push(o));const s=o.shape.slice();for(let e=0;e<r.length;++e)s.splice(r[e],0,1);t.util.arraysEqual(o.shape,s)||(o=da({inputs:{x:o},backend:a,attrs:{shape:s}}),x.push(o)),null===h?h=o:(h=la({inputs:{a:o,b:h},backend:a}),x.push(h))}e<p-1&&(c[e]>=0&&(h=va({inputs:{x:h},backend:a,attrs:{axis:c[e]-(s.length-f),keepDims:!1}}),x.push(h)),f--)}for(const e of x)e!==h&&a.disposeIntermediateTensorInfo(e);return h}},Do=ta({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Po={kernelName:t.Elu,backendName:"webgl",kernelFunc:Do},Lo={kernelName:t.EluGrad,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:a}=e,{dy:r,y:o}=n,i=t.env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zn("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,o.shape):new Gn("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,o.shape);return a.runWebGLProgram(i,[r,o],r.dtype)}},Bo=na({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Vt}),Uo={kernelName:t.Equal,backendName:"webgl",kernelFunc:Bo},Vo=ta({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${t.backend_util.ERF_P};\n  float a1 = ${t.backend_util.ERF_A1};\n  float a2 = ${t.backend_util.ERF_A2};\n  float a3 = ${t.backend_util.ERF_A3};\n  float a4 = ${t.backend_util.ERF_A4};\n  float a5 = ${t.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Wo={kernelName:t.Erf,backendName:"webgl",kernelFunc:Vo},Mo=ta({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Wt,dtype:"float32"}),Go={kernelName:t.Exp,backendName:"webgl",kernelFunc:Mo};function zo(e){const{inputs:n,attrs:a,backend:r}=e,{dim:o}=a,{input:i}=n,s=i.shape.length,u=i.shape.slice();let l=o;return o<0&&(t.util.assert(-(s+1)<=o,(()=>`Axis must be in the interval [${-(s+1)}, ${s}]`)),l=s+o+1),u.splice(l,0,1),da({inputs:{x:i},backend:r,attrs:{shape:u}})}const Xo={kernelName:t.ExpandDims,backendName:"webgl",kernelFunc:zo},Ho="return exp(x) - 1.0;",jo=ta({opSnippet:Ho,packedOpSnippet:Ho,cpuKernelImpl:Mt}),Ko={kernelName:t.Expm1,backendName:"webgl",kernelFunc:jo};class qo{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${a}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Yo(e,n,a){const r=a.texData.get(e.dataId),o=t.util.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],s=da({inputs:{x:e},backend:a,attrs:{shape:[o/i,i]}}),u=s.shape,l=new qo("real",u,n),c=new qo("imag",u,n),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],p=a.runWebGLProgram(l,d,"float32"),h=a.runWebGLProgram(c,d,"float32"),f=jn({inputs:{real:p,imag:h},backend:a});a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(h);const x=da({inputs:{x:f},backend:a,attrs:{shape:e.shape}});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(f),x}const Qo={kernelName:t.FFT,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Yo(a,!1,n)}};class Zo{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Jo(e){const{backend:n,attrs:a}=e,{shape:r,value:o}=a;let{dtype:i}=a;if(i=i||t.util.inferDtype(o),"string"===i){const e=t.util.getArrayFromDType(i,t.util.sizeFromShape(r));return e.fill(o),n.makeTensorInfo(r,i,e)}{const e=new Zo(r,o),t=[[o]];return n.runWebGLProgram(e,[],i,t)}}const ei={kernelName:t.Fill,backendName:"webgl",kernelFunc:Jo};class ti{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ni={kernelName:t.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,a=t,r=new ti(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},ai="return floor(x);",ri=ta({opSnippet:ai,packedOpSnippet:ai,cpuKernelImpl:Gt}),oi={kernelName:t.Floor,backendName:"webgl",kernelFunc:ri},ii=na({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),si={kernelName:t.FloorDiv,backendName:"webgl",kernelFunc:ii};class ui{constructor(e){this.variableNames=["A"];const t=ue(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class li{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ue(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const ci={kernelName:t.FromPixels,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e;let{pixels:o}=n;const{numChannels:i}=r,s="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,[c,d]=s?[o.videoWidth,o.videoHeight]:[o.width,o.height],p=[d,c],h=[d,c,i];(u||s)&&(null==di&&(di=document.createElement("canvas").getContext("2d")),di.canvas.width=c,di.canvas.height=d,di.drawImage(o,0,0,c,d),o=di.canvas);const f=a.makeTensorInfo(p,"int32");a.texData.get(f.dataId).usage=l.PIXELS,a.gpgpu.uploadPixelDataToTexture(a.getTexture(f.dataId),o);const x=t.env().getBool("WEBGL_PACK")?new li(h):new ui(h),m=a.runWebGLProgram(x,[f],"int32");return a.disposeData(f.dataId),m}};let di;const pi={kernelName:t.FusedConv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,filter:i,bias:s,preluActivationWeights:u}=n,{strides:l,pad:c,dataFormat:d,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:x}=r,m=t.backend_util.convertConv2DDataFormat(d),g=t.backend_util.computeConv2DInfo(o.shape,i.shape,l,p,c,h,!1,m);let b;const v=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(t.env().getBool("WEBGL_CONV_IM2COL")&&1===o.shape[0])b=Kr({x:o,filter:i,convInfo:g,backend:a,bias:s,activation:f,preluActivationWeights:u,leakyreluAlpha:x});else{const e=null!=s,n=null!=u,r="leakyrelu"===f,l=f?aa(f,!1):null,c=new zr(g,e,l,n,r),d=[o,i];if(s&&d.push(s),u&&d.push(u),r){const e=a.makeTensorInfo([],"float32",t.util.createScalarValue(x,"float32"));d.push(e),v.push(e)}b=a.runWebGLProgram(c,d,"float32")}else b=jr({x:o,filter:i,convInfo:g,backend:a,bias:s,activation:f,preluActivationWeights:u,leakyreluAlpha:x});const C=da({inputs:{x:b},backend:a,attrs:{shape:g.outShape}});return v.push(b),v.forEach((e=>a.disposeIntermediateTensorInfo(e))),C}};const hi={kernelName:t.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,filter:i,bias:s,preluActivationWeights:u}=n,{strides:l,pad:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,x=[];let m=d;null==m&&(m=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=t.backend_util.computeConv2DInfo(o.shape,i.shape,l,m,c,p,!0),b=t.env().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,v=h?aa(h,b):null,C=[o,i],$=null!=s,I=null!=u,k="leakyrelu"===h;if($&&C.push(s),I&&C.push(u),k){const e=a.makeTensorInfo([],"float32",t.util.createScalarValue(f,"float32"));C.push(e),x.push(e)}let y;y=b?new yo(g,$,v,I,k):new ko(g,$,v,I,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],w=a.runWebGLProgram(y,C,"float32",S);return x.forEach((e=>a.disposeIntermediateTensorInfo(e))),w}};class fi{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const a=Se(t.length),r=Se(n.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${a} strides = ${a}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${o};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const xi={kernelName:t.GatherNd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{params:r,indices:o}=n,i=o.shape,s=i[i.length-1],u=t.util.sizeFromShape(r.shape),[l,c,d,p]=t.backend_util.prepareAndValidate(r,o),h=da({inputs:{x:o},backend:a,attrs:{shape:[c,s]}}),f=da({inputs:{x:r},backend:a,attrs:{shape:[t.util.sizeFromShape(r.shape)/d,d]}});if(a.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=a.readSync(o.dataId),t=a.bufferSync(r),n=zt(e,t,r.dtype,c,s,d,p,r.shape,u);return a.makeTensorInfo(l,r.dtype,n.values)}const x=new fi(s,p,[c,d]),m=a.runWebGLProgram(x,[f,h],f.dtype),g=da({inputs:{x:m},backend:a,attrs:{shape:l}});return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(m),g}};class mi{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Se(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let t=0;t<e.length;t++)2===t?a.push("index"):a.push(`${n[t]}`);return a.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${a}));\n      }\n    `}}function gi(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,indices:i}=n,{axis:s,batchDims:u}=r,l=t.util.parseAxisParam(s,o.shape)[0];if(t.env().get("DEBUG")){const e=a.readSync(i.dataId),n=o.shape[l];for(let a=0;a<e.length;++a){const r=e[a];t.util.assert(r<=n-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${n-1}]`))}}const c=t.backend_util.segment_util.collectGatherOpShapeInfo(o,i,l,u),d=t.util.sizeFromShape(i.shape),p=[],h=da({inputs:{x:o},backend:a,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=da({inputs:{x:i},backend:a,attrs:{shape:[c.batchSize,d/c.batchSize]}});p.push(h),p.push(f);const x=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(a.shouldExecuteOnCPU([o,i])||"string"===o.dtype){const e=a.bufferSync(f),t=a.bufferSync(h),n=Xt(t,e,x);return p.forEach((e=>a.disposeIntermediateTensorInfo(e))),a.makeTensorInfo(c.outputShape,n.dtype,n.values)}const m=new mi(h.shape,x),g=a.runWebGLProgram(m,[h,f],h.dtype);p.push(g);const b=da({inputs:{x:g},backend:a,attrs:{shape:c.outputShape}});return p.forEach((e=>a.disposeIntermediateTensorInfo(e))),b}const bi={kernelName:t.GatherV2,backendName:"webgl",kernelFunc:gi},vi=na({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Ht,dtype:"bool"}),Ci={kernelName:t.Greater,backendName:"webgl",kernelFunc:vi},$i=na({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:jt}),Ii={kernelName:t.GreaterEqual,backendName:"webgl",kernelFunc:$i};const ki={kernelName:t.IFFT,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return Yo(a,!0,n)}},yi=ta({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Si={kernelName:t.IsFinite,backendName:"webgl",kernelFunc:yi},wi=ta({opSnippet:"return float(isinf(x));",dtype:"bool"}),Ri={kernelName:t.IsInf,backendName:"webgl",kernelFunc:wi},Ti=ta({opSnippet:"return float(isnan(x));",dtype:"bool"}),Ei={kernelName:t.IsNan,backendName:"webgl",kernelFunc:Ti},Ni=na({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Kt,dtype:"bool"}),Ai={kernelName:t.Less,backendName:"webgl",kernelFunc:Ni},Fi=na({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:qt,dtype:"bool"}),_i={kernelName:t.LessEqual,backendName:"webgl",kernelFunc:Fi};const Oi={kernelName:t.LinSpace,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:o}=n,i=Yt(a,r,o);return t.makeTensorInfo([i.length],"float32",i)}},Di=ta({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Qt}),Pi={kernelName:t.Log,backendName:"webgl",kernelFunc:Di},Li=ta({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),Bi={kernelName:t.Log1p,backendName:"webgl",kernelFunc:Li},Ui=na({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Vi={kernelName:t.LogicalAnd,backendName:"webgl",kernelFunc:Ui},Wi=ta({opSnippet:"return float(!(x >= 1.0));"}),Mi={kernelName:t.LogicalNot,backendName:"webgl",kernelFunc:Wi},Gi=na({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),zi={kernelName:t.LogicalOr,backendName:"webgl",kernelFunc:Gi};class Xi{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;let s;this.outputShape=e;const u=`float(${n}) + float(${a}) * sum`;s=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${s};\n        setOutput(val);\n      }\n    `}}class Hi{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;let s;this.outputShape=e;const u=`float(${n}) + float(${a}) * sum`;s=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${s};\n        setOutput(result);\n      }\n    `}}const ji={kernelName:t.LRN,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{depthRadius:i,bias:s,alpha:u,beta:l}=r,c=t.env().getBool("WEBGL_PACK_NORMALIZATION")?new Hi(o.shape,i,s,u,l):new Xi(o.shape,i,s,u,l);return a.runWebGLProgram(c,[o],o.dtype)}};class Ki{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const qi={kernelName:t.LRNGrad,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:o,dy:i}=t,{depthRadius:s,bias:u,alpha:l,beta:c}=a,d=new Ki(r.shape,s,u,l,c);return n.runWebGLProgram(d,[r,o,i],r.dtype)}};function Yi(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{reductionIndices:i,keepDims:s}=r,u=o.shape.length,l=t.util.parseAxisParam(i,o.shape);let c=l;const d=t.backend_util.getAxesPermutation(c,u),p=null!=d,h=a.shouldExecuteOnCPU([o]);let f=o;if(p){if(h){const e=a.texData.get(f.dataId).values,t=new Array(u);for(let e=0;e<t.length;e++)t[e]=o.shape[d[e]];const n=In(e,o.shape,o.dtype,d,t);f=a.makeTensorInfo(t,o.dtype);a.texData.get(f.dataId).values=n}else f=ba(o,d,a);c=t.backend_util.getInnerMostAxes(c.length,u)}t.backend_util.assertAxesAreInnerMostDims("max",c,u);const[x,m]=t.backend_util.computeOutAndReduceShapes(f.shape,c);let g,b=x;if(s&&(b=t.backend_util.expandShapeToKeepDim(x,l)),h){const e=a.texData.get(f.dataId).values,n=Zt(e,t.util.sizeFromShape(m),b,o.dtype);g=a.makeTensorInfo(b,o.dtype);a.texData.get(g.dataId).values=n}else g=function(e,n,a,r){const o=t.util.sizeFromShape(n),i=da({inputs:{x:e},attrs:{shape:[t.util.sizeFromShape(e.shape)/o,o]},backend:r}),s=xa(i,e.dtype,"max",r),u=da({inputs:{x:s},attrs:{shape:a},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(s),u}(f,m,b,a);return p&&a.disposeIntermediateTensorInfo(f),g}const Qi={kernelName:t.Max,backendName:"webgl",kernelFunc:Yi},Zi=na({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Jt}),Ji={kernelName:t.Maximum,backendName:"webgl",kernelFunc:Zi};const es={kernelName:t.MaxPool,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n;oe(o,"maxPool");const{filterSize:i,strides:s,pad:u,dimRoundingMode:l}=r;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(s,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`));const c=t.backend_util.computePool2DInfo(o.shape,i,s,1,u,l);if(1===c.filterWidth&&1===c.filterHeight&&t.util.arraysEqual(c.inShape,c.outShape))return Xn({inputs:{x:o},backend:a});const d=new nr(c,"max",!1);return a.runWebGLProgram(d,[o],o.dtype)}};const ts={kernelName:t.MaxPool3D,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{filterSize:i,strides:s,pad:u,dataFormat:l,dimRoundingMode:c}=r,d=t.backend_util.computePool3DInfo(o.shape,i,s,[1,1,1],u,c,l),p=new ar(d,"max",!1);return a.runWebGLProgram(p,[o],o.dtype)}};class ns{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,i=r-1-e.padInfo.top,s=o-1-e.padInfo.left,u=r*o-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class as{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=s-1-e.padInfo.front,d=u-1-e.padInfo.top,p=l-1-e.padInfo.left,h=s*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${s};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${o}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const rs={kernelName:t.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:o,input:i}=n,s=i,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=r,p=t.backend_util.computePool3DInfo(s.shape,u,l,[1,1,1],c,d),h=new ar(p,"max",!0),f=a.runWebGLProgram(h,[s],s.dtype),x=new as(p),m=a.runWebGLProgram(x,[o,f],s.dtype);return a.disposeIntermediateTensorInfo(f),m}};const os={kernelName:t.MaxPoolGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{dy:o,input:i,output:s}=n,u=i;oe([i,s],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:p}=r,h=t.backend_util.computePool2DInfo(u.shape,l,c,1,d,p),f=new nr(h,"max",!0),x=a.runWebGLProgram(f,[u],u.dtype),m=new ns(h),g=a.runWebGLProgram(m,[o,x],u.dtype);return a.disposeIntermediateTensorInfo(x),g}};const is={kernelName:t.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:a})=>{const{x:r}=e,{filterSize:o,strides:i,pad:s,includeBatchInIndex:u}=n,l=a;t.util.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const c=[1,1];t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=t.backend_util.computePool2DInfo(r.shape,o,i,c,s),[p,h]=function(e,t,n,a){let r=new nr(n,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new nr(n,"max",!0,!0,t),[o,a.runWebGLProgram(r,[e],"float32")]}(r,u,d,l);return[p,h]}};const ss={kernelName:t.Mean,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:a})=>{const{x:r}=e,{keepDims:o,axis:i}=n,s=a,u=r.shape.length,l=t.util.parseAxisParam(i,r.shape);let c=l;const d=t.backend_util.getAxesPermutation(c,u),p=null!=d,h=s.shouldExecuteOnCPU([r]),f=[];let x=r;if(p){if(h){const e=s.texData.get(x.dataId).values,t=new Array(u);for(let e=0;e<t.length;e++)t[e]=r.shape[d[e]];const n=In(e,r.shape,r.dtype,d,t);x=s.makeTensorInfo(t,r.dtype);s.texData.get(x.dataId).values=n}else x=ba(r,d,s);f.push(x),c=t.backend_util.getInnerMostAxes(c.length,u)}t.backend_util.assertAxesAreInnerMostDims("sum",c,u);const[m,g]=t.backend_util.computeOutAndReduceShapes(x.shape,c);let b=m;o&&(b=t.backend_util.expandShapeToKeepDim(m,l));const v=function(e,n,a,r){const o=t.util.sizeFromShape(n),i=da({inputs:{x:e},attrs:{shape:[t.util.sizeFromShape(e.shape)/o,o]},backend:r}),s=xa(i,"float32","mean",r),u=da({inputs:{x:s},attrs:{shape:a},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(s),u}(x,g,b,s);for(const e of f)s.disposeIntermediateTensorInfo(e);return v}};const us={kernelName:t.Min,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i,keepDims:s}=r,u=o.shape.length,l=t.util.parseAxisParam(i,o.shape);let c=l;const d=t.backend_util.getAxesPermutation(c,u);let p=o;null!=d&&(p=$a({inputs:{x:o},backend:a,attrs:{perm:d}}),c=t.backend_util.getInnerMostAxes(c.length,o.shape.length)),t.backend_util.assertAxesAreInnerMostDims("min",c,u);const[h,f]=t.backend_util.computeOutAndReduceShapes(p.shape,c),x=da({inputs:{x:p},backend:a,attrs:{shape:[-1,t.util.sizeFromShape(f)]}}),m=xa(x,x.dtype,"min",a);let g;if(s){g=da({inputs:{x:m},backend:a,attrs:{shape:t.backend_util.expandShapeToKeepDim(h,l)}})}else g=da({inputs:{x:m},backend:a,attrs:{shape:h}});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(m),null!=d&&a.disposeIntermediateTensorInfo(p),g}},ls=na({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:en}),cs={kernelName:t.Minimum,backendName:"webgl",kernelFunc:ls};class ds{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Se(a),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),u="reflect"===n?0:1;this.userCode=1!==a?`\n      ${r} start = ${r}(${o});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${a}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${s}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class ps{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Se(a),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=Sn("rc",a),u=Sn("source",a),l=`${s[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${u.slice(-2).join()})`,d="reflect"===n?0:1;let p="";if(1===a){const e=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${s[a-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${s[a-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${s[a-2]} += 1;\n        if(${s[a-2]} < ${this.outputShape[a-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${s[a-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${o});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const hs={kernelName:t.MirrorPad,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:a})=>{const{x:r}=e,{paddings:o,mode:i}=a,s=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ps(r.shape,o,i):new ds(r.shape,o,i);return n.runWebGLProgram(s,[r],r.dtype)}},fs=na({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),xs={kernelName:t.Mod,backendName:"webgl",kernelFunc:fs};class ms{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const gs=na({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),bs={kernelName:t.RealDiv,backendName:"webgl",kernelFunc:gs},vs="return a - b;",Cs=na({opSnippet:vs,packedOpSnippet:vs,supportsComplex:!0,cpuKernelImpl:vn}),$s={kernelName:t.Sub,backendName:"webgl",kernelFunc:Cs};function Is(e){const{inputs:n,backend:a,attrs:r}=e,{logits:o}=n,{dim:i}=r,s=t.util.parseAxisParam([i],o.shape),u=Yi({inputs:{x:o},backend:a,attrs:{reductionIndices:s,keepDims:!1}}),l=t.backend_util.expandShapeToKeepDim(u.shape,s),c=da({inputs:{x:u},backend:a,attrs:{shape:l}}),d=Cs({inputs:{a:o,b:c},backend:a}),p=Mo({inputs:{x:d},backend:a}),h=va({inputs:{x:p},backend:a,attrs:{axis:s,keepDims:!1}}),f=da({inputs:{x:h},backend:a,attrs:{shape:l}}),x=gs({inputs:{a:p,b:f},backend:a});return a.disposeIntermediateTensorInfo(u),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(f),x}const ks={kernelName:t.Softmax,backendName:"webgl",kernelFunc:Is};const ys={kernelName:t.Multinomial,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:o,seed:i,normalized:s}=a,u=s?r:Is({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new ms(l,c,o),p=[[i]],h=n.runWebGLProgram(d,[u],"int32",p);return s||n.disposeIntermediateTensorInfo(u),h}};const Ss={kernelName:t.Neg,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r}=n;if(a.shouldExecuteOnCPU([r])){const e=a.texData.get(r.dataId),[t,n]=nn(e.values,r.shape,r.dtype);return a.makeTensorInfo(n,r.dtype,t)}let o;return o=t.env().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Dn(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Fn(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),a.runWebGLProgram(o,[r],r.dtype)}},ws=t.kernel_impls.nonMaxSuppressionV3Impl;const Rs={kernelName:t.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:a,attrs:r}=e,{boxes:o,scores:i}=n,{maxOutputSize:s,iouThreshold:u,scoreThreshold:l}=r,c=a.readSync(o.dataId),d=a.readSync(i.dataId),{selectedIndices:p}=ws(c,d,s,u,l);return a.makeTensorInfo([p.length],"int32",new Int32Array(p))}},Ts=t.kernel_impls.nonMaxSuppressionV4Impl;const Es={kernelName:t.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:a,attrs:r}=e,{boxes:o,scores:i}=n,{maxOutputSize:s,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:c}=r,d=a.readSync(o.dataId),p=a.readSync(i.dataId),{selectedIndices:h,validOutputs:f}=Ts(d,p,s,u,l,c);return[a.makeTensorInfo([h.length],"int32",new Int32Array(h)),a.makeTensorInfo([],"int32",new Int32Array([f]))]}},Ns=t.kernel_impls.nonMaxSuppressionV5Impl;const As={kernelName:t.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:a,attrs:r}=e,{boxes:o,scores:i}=n,{maxOutputSize:s,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=r,d=a.readSync(o.dataId),p=a.readSync(i.dataId),h=s,f=u,x=l,m=c,{selectedIndices:g,selectedScores:b}=Ns(d,p,h,f,x,m);return[a.makeTensorInfo([g.length],"int32",new Int32Array(g)),a.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class Fs{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${a}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const _s={kernelName:t.OneHot,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:a,attrs:r}=e,{indices:o}=n,{depth:i,onValue:s,offValue:u}=r,l=t.util.sizeFromShape(o.shape),c=new Fs(l,i,s,u),d=da({inputs:{x:o},backend:a,attrs:{shape:[l]}}),p=a.runWebGLProgram(c,[d],o.dtype);a.disposeIntermediateTensorInfo(d);const h=da({inputs:{x:p},backend:a,attrs:{shape:[...o.shape,i]}});return a.disposeIntermediateTensorInfo(p),h}};function Os(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=yr({inputs:{input:a},backend:n}),t=Os({inputs:{x:e},backend:n}),r=Ur({inputs:{input:a},backend:n}),o=Os({inputs:{x:r},backend:n}),i=jn({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),i}return Jo({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const Ds={kernelName:t.ZerosLike,backendName:"webgl",kernelFunc:Os};const Ps={kernelName:t.OnesLike,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=yr({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),o=Ur({inputs:{input:r},backend:a}),i=Os({inputs:{x:o},backend:a}),s=jn({inputs:{real:n,imag:i},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(i),s}return Jo({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const Ls={kernelName:t.Pack,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{axis:o}=r;if(1===n.length)return zo({inputs:{input:n[0]},backend:a,attrs:{dim:o}});const i=n[0].shape,s=n[0].dtype;n.forEach((e=>{t.util.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(s===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=Mr({inputs:n.map((e=>{const t=zo({inputs:{input:e},backend:a,attrs:{dim:o}});return u.push(t),t})),backend:a,attrs:{axis:o}});return u.forEach((e=>a.disposeIntermediateTensorInfo(e))),l}};class Bs{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Se(a),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?`\n      ${r} start = ${r}(${o});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${s}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Us{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=Se(a),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=Sn("rc",a),u=Sn("source",a),l=`${s[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${u.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${s[a-1]} += 1;\n       if(${l}) {\n      `,1===a?"":`}\n       rc = outputLoc;\n       ${s[a-2]} += 1;\n       if(${s[a-2]} < ${this.outputShape[a-2]}) {`,1===a?"":`  ${s[a-1]} += 1;\n         if(${l}) {`],p=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,t=1===a?2:4;e<t;e++)h+=`\n        ${d[e]}\n        if (${p}) {\n          result[${e}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;h+=1===a?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${o});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const Vs=e=>{const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{paddings:i,constantValue:s}=r;if(0===t.util.sizeFromShape(o.shape)){return Jo({backend:a,attrs:{shape:i.map(((e,t)=>e[0]+o.shape[t]+e[1])),value:s,dtype:o.dtype}})}const u=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Us(o.shape,i,s):new Bs(o.shape,i,s),l=[[s]];return a.runWebGLProgram(u,[o],o.dtype,l)},Ws={kernelName:t.PadV2,backendName:"webgl",kernelFunc:Vs},Ms=na({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Gs={kernelName:t.Pow,backendName:"webgl",kernelFunc:Ms};const zs={kernelName:t.Prod,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{axis:i,keepDims:s}=r,u=o.shape.length,l=[],c=t.util.parseAxisParam(i,o.shape);let d=c;const p=t.backend_util.getAxesPermutation(d,u);let h,f=o;if(null!=p&&(f=$a({inputs:{x:o},backend:a,attrs:{perm:p}}),d=t.backend_util.getInnerMostAxes(d.length,u),l.push(f)),t.backend_util.assertAxesAreInnerMostDims("prod",d,u),a.shouldExecuteOnCPU([f])){const e=a.texData.get(f.dataId).values,{outVals:t,outShape:n,outDtype:r}=rn(f.shape,f.dtype,e,d);h=a.makeTensorInfo(n,r,t)}else{const[e,n]=t.backend_util.computeOutAndReduceShapes(f.shape,d),r=t.util.sizeFromShape(n),i=da({inputs:{x:f},backend:a,attrs:{shape:[-1,r]}}),s=xa(i,t.sumOutType(o.dtype),"prod",a);h=da({inputs:{x:s},backend:a,attrs:{shape:e}}),l.push(i),l.push(s)}if(s){l.push(h);const e=t.backend_util.expandShapeToKeepDim(h.shape,c);h=da({inputs:{x:h},backend:a,attrs:{shape:e}})}return l.forEach((e=>a.disposeIntermediateTensorInfo(e))),h}},Xs=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:o,dtype:i}=n,s=on(a,r,o,i);return t.makeTensorInfo([s.length],i,s)},Hs={kernelName:t.Range,backendName:"webgl",kernelFunc:Xs},js=ta({opSnippet:"return 1.0 / x;"}),Ks={kernelName:t.Reciprocal,backendName:"webgl",kernelFunc:js},qs=ta({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Ys={kernelName:t.Relu,backendName:"webgl",kernelFunc:qs},Qs=ta({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Zs={kernelName:t.Relu6,backendName:"webgl",kernelFunc:Qs};class Js{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const l=[a&&t>1?i-1:i,a&&n>1?s-1:s],c=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class eu{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const l=[a&&t>1?i-1:i,a&&n>1?s-1:s],c=[a&&t>1?t-1:t,a&&n>1?n-1:n];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const tu={kernelName:t.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{images:o}=n,{alignCorners:i,halfPixelCenters:s,size:u}=r,[l,c]=u,d=t.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new eu(o.shape,l,c,i,s):new Js(o.shape,l,c,i,s);return a.runWebGLProgram(d,[o],"float32")}};class nu{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,i]=e,s=[n&&o>1?a-1:a,n&&i>1?r-1:r],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=s[0]/u[0],c=s[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const au={kernelName:t.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:i}=a,s=new nu(o.shape,r.shape,i);return n.runWebGLProgram(s,[o],o.dtype)}};class ru{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const l=[a&&t>1?i-1:i,a&&n>1?s-1:s],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let p;p=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class ou{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const l=[a&&t>1?i-1:i,a&&n>1?s-1:s],c=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?"0.5":"0.0";let p;p=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const iu={kernelName:t.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{images:o}=n,{alignCorners:i,halfPixelCenters:s,size:u}=r,[l,c]=u,d=t.env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ou(o.shape,l,c,i,s):new ru(o.shape,l,c,i,s);return a.runWebGLProgram(d,[o],o.dtype)}};class su{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,o,i]=e,s=[n&&o>1?a-1:a,n&&i>1?r-1:r],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=s[0]/u[0],c=s[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${s[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${s[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const uu={kernelName:t.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:o}=t,{alignCorners:i}=a,s=new su(o.shape,r.shape,i);return n.runWebGLProgram(s,[o],o.dtype)}};class lu{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(a))).join(","),r=Se(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class cu{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const a=Sn("rc",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Se(n);function s(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${a[n]} - 1`:`${a[n]}`}(r,n)));return`getChannel(getX(${a.join(",")}), vec2(${a.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return s(e)}(a.slice())};\n          if(${r}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",s(e)}(a.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",s(e)}(a.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",s(e)}(a.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const du={kernelName:t.Reverse,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{dims:i}=r,s=o.shape.length,u=t.util.parseAxisParam(i,o.shape);if(0===s)return Xn({inputs:{x:o},backend:a});const l=t.env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cu(o.shape,u):new lu(o.shape,u);return a.runWebGLProgram(l,[o],o.dtype)}};class pu{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const hu={kernelName:t.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:a})=>{const{image:r}=e,{radians:o,fillValue:i,center:s}=n,u=a,l=new pu(r.shape,i),[c,d]=t.backend_util.getImageCenter(s,r.shape[1],r.shape[2]),p=[[c,d,Math.sin(o),Math.cos(o)]];return u.runWebGLProgram(l,[r],r.dtype,p)}},fu=ta({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),xu={kernelName:t.Round,backendName:"webgl",kernelFunc:fu},mu=ta({opSnippet:"return inversesqrt(x);",cpuKernelImpl:sn}),gu={kernelName:t.Rsqrt,backendName:"webgl",kernelFunc:mu};class bu{constructor(e,t,n,a,r,o,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const s=Se(r.length),u=Se(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const c=`getIndices(${l})`;let d="";1===a?d="i":2===a&&(d="i, coords[1]");const p=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${s} strides = ${s}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const vu={kernelName:t.ScatterNd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{indices:o,updates:i}=n,{shape:s}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=t.backend_util.calculateShapes(i,o,s),h=[p/c,c];if(0===p)return a.makeTensorInfo(s,o.dtype);const f=da({inputs:{x:o},backend:a,attrs:{shape:[l,u]}}),x=da({inputs:{x:i},backend:a,attrs:{shape:[l,c]}}),m=a.makeTensorInfo([],"float32",new Float32Array([0])),g=new bu(l,u,f.shape.length,x.shape.length,d,h),b=a.runWebGLProgram(g,[x,f,m],x.dtype),v=da({inputs:{x:b},backend:a,attrs:{shape:s}});return a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(m),v}};class Cu{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let a=0;a<t.length;a++)i.push(`${n[a]}`),a<e&&o.push(`${n[a]}`);a=o.join(),r=i.join()}const o=Se(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${a});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const $u={kernelName:t.Select,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{condition:r,t:o,e:i}=n,s=new Cu(r.shape.length,o.shape,o.shape.length);return a.runWebGLProgram(s,[r,o,i],t.upcastType(o.dtype,i.dtype))}},Iu=ta({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${t.backend_util.SELU_SCALEALPHA};\n  float scale = ${t.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),ku={kernelName:t.Selu,backendName:"webgl",kernelFunc:Iu},yu=ta({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:un}),Su={kernelName:t.Sigmoid,backendName:"webgl",kernelFunc:yu},wu=ta({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Ru={kernelName:t.Sign,backendName:"webgl",kernelFunc:wu},Tu=ta({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),Eu={kernelName:t.Sin,backendName:"webgl",kernelFunc:Tu},Nu=ta({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Au={kernelName:t.Sinh,backendName:"webgl",kernelFunc:Nu},Fu=ta({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),_u={kernelName:t.Softplus,backendName:"webgl",kernelFunc:Fu},Ou={kernelName:t.SpaceToBatchND,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{blockShape:i,paddings:s}=r;t.util.assert(o.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const u=i.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...s);for(let e=1+i.length;e<o.shape.length;++e)l.push([0,0]);const c=[],d=Vs({inputs:{x:o},backend:a,attrs:{paddings:l,constantValue:0}}),p=t.backend_util.getReshaped(d.shape,i,u,!1),h=t.backend_util.getPermuted(p.length,i.length,!1),f=t.backend_util.getReshapedPermuted(d.shape,i,u,!1),x=da({inputs:{x:d},backend:a,attrs:{shape:p}}),m=$a({inputs:{x:x},backend:a,attrs:{perm:h}}),g=da({inputs:{x:m},backend:a,attrs:{shape:f}});return c.push(d),c.push(x),c.push(m),c.forEach((e=>a.disposeIntermediateTensorInfo(e))),g}};const Du={kernelName:t.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==a.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${a.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const s=n.readSync(a.dataId),u=n.readSync(r.dataId),l=n.readSync(o.dataId),c=n.readSync(i.dataId)[0],[d,p,h,f,x]=dn(s,a.shape,a.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(p,a.dtype,d),n.makeTensorInfo([p[0]],r.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([x.length],a.dtype,new Int32Array(x))]}};const Pu={kernelName:t.SparseReshape,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:o}=t;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(r.dataId)),s=n.readSync(a.dataId),u=Array.from(n.readSync(o.dataId)),[l,c,d]=pn(s,a.shape,a.dtype,i,u);return[n.makeTensorInfo(c,a.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};const Lu={kernelName:t.SparseSegmentMean,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=n.readSync(a.dataId),s=n.readSync(r.dataId),u=n.readSync(o.dataId),[l,c]=hn(i,a.shape,a.dtype,s,u,!0);return n.makeTensorInfo(c,a.dtype,l)}};const Bu={kernelName:t.SparseSegmentSum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:o}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=n.readSync(a.dataId),s=n.readSync(r.dataId),u=n.readSync(o.dataId),[l,c]=hn(i,a.shape,a.dtype,s,u);return n.makeTensorInfo(c,a.dtype,l)}};const Uu={kernelName:t.SparseToDense,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{sparseIndices:o,sparseValues:i,defaultValue:s}=n,{outputShape:u}=r,{sliceRank:l,numUpdates:c,strides:d,outputSize:p}=t.backend_util.calculateShapes(i,o,u),h=new bu(c,l,o.shape.length,i.shape.length,d,[p,1],!1),f=a.runWebGLProgram(h,[i,o,s],i.dtype),x=da({inputs:{x:f},backend:a,attrs:{shape:u}});return a.disposeIntermediateTensorInfo(f),x}};const Vu={kernelName:t.SplitV,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{numOrSizeSplits:i,axis:s}=r,u=t.util.parseAxisParam(s,o.shape)[0],l=t.backend_util.prepareSplitSize(o,i,u),c=o.shape.length,d=new Array(c).fill(0),p=o.shape.slice();return l.map((e=>{const t=[...p];t[u]=e;const n=gr({inputs:{x:o},backend:a,attrs:{begin:d,size:t}});return d[u]+=e,n}))}},Wu="return sqrt(x);",Mu=ta({opSnippet:Wu,packedOpSnippet:Wu,cpuKernelImpl:fn}),Gu={kernelName:t.Sqrt,backendName:"webgl",kernelFunc:Mu},zu=ta({opSnippet:"return x * x;"}),Xu={kernelName:t.Square,backendName:"webgl",kernelFunc:zu},Hu="return (a - b) * (a - b);",ju=na({opSnippet:Hu,packedOpSnippet:Hu}),Ku={kernelName:t.SquaredDifference,backendName:"webgl",kernelFunc:ju};const qu={kernelName:t.Step,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:a}=e,r=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,o=new Fn(a.shape,r);return n.runWebGLProgram(o,[a],a.dtype)}};class Yu{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=Se(n.length),o=Se(n.length);let i="";if(1===a)i="coords * strides + begin";else{let e=0;i=n.map(((t,a)=>(e++,1===n.length?`coords * strides[${a}] + begin[${a}]`:`coords[${e-1}] * strides[${a}] + begin[${a}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const Qu={kernelName:t.StridedSlice,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{begin:i,end:s,strides:u,beginMask:l,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:x,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:v,end:C,strides:$}=t.slice_util.sliceInfo(o.shape,i,s,u,l,c,d,p,h);let I;if(m)I=da({inputs:{x:o},backend:a,attrs:{shape:x}});else if(g||b){t.util.assert(o.shape.length>=1,(()=>`Input must have rank at least 1, got: ${o.shape.length}`));const e=t.slice_util.computeOutShape(v,C,$),n=gr({inputs:{x:o},backend:a,attrs:{begin:v,size:e}});I=da({inputs:{x:n},backend:a,attrs:{shape:x}}),a.disposeIntermediateTensorInfo(n)}else{if(a.shouldExecuteOnCPU([o])){const e=a.readSync(o.dataId),n=t.buffer(o.shape,o.dtype,e),r=xn(f,n,$,v);I=a.makeTensorInfo(x,o.dtype,r.values)}else{const e=new Yu(v,$,f);I=a.runWebGLProgram(e,[o],o.dtype)}}const k=da({inputs:{x:I},backend:a,attrs:{shape:x}});return a.disposeIntermediateTensorInfo(I),k}};const Zu={kernelName:t.StringNGrams,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:i,rightPad:s,padWidth:u,preserveShortSequences:l}=a,{data:c,dataSplits:d}=t,p=n.readSync(c.dataId),h=n.readSync(d.dataId),[f,x]=mn(p,h,r,o,i,s,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",x)]}};const Ju={kernelName:t.StringSplit,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const s=n.readSync(o.dataId),u=n.readSync(i.dataId)[0],[l,c,d]=gn(s,u,r),p=c.length;return[n.makeTensorInfo([p,2],"int32",l),n.makeTensorInfo([p],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const el={kernelName:t.StringToHashBucketFast,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),s=bn(i,r);return n.makeTensorInfo(o.shape,"int32",s)}},tl=ta({opSnippet:"return tan(x);"}),nl={kernelName:t.Tan,backendName:"webgl",kernelFunc:tl},al=ta({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),rl={kernelName:t.Tanh,backendName:"webgl",kernelFunc:al};class ol{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const a=Se(this.rank),r=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let t=0;t<e.length;t++)a.push(`imod(${n[t]}, ${e[t]})`);return a.join()}(e);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function il(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{reps:i}=r;if("string"===o.dtype||o.shape.length>5){const e=a.readSync(o.dataId),n="string"===o.dtype?e.map((e=>t.util.decodeString(e))):e,r=t.buffer(o.shape,o.dtype,n),s=Cn(r,i);return a.makeTensorInfo(s.shape,s.dtype,s.values)}const s=new ol(o.shape,i);return a.runWebGLProgram(s,[o],o.dtype)}const sl={kernelName:t.Tile,backendName:"webgl",kernelFunc:il};class ul{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class ll{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function cl(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function dl(e){let t=1;for(;t<e;)t*=2;return t}const pl={kernelName:t.TopK,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{k:i,sorted:s}=r,u=t.env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=t.env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=o.shape,d=c[c.length-1];if(a.shouldExecuteOnCPU([o])||d<u||i>l){const e=a.readSync(o.dataId),[t,n]=$n(e,c,o.dtype,i,s);return[a.makeTensorInfo(t.shape,t.dtype,t.values),a.makeTensorInfo(n.shape,n.dtype,n.values)]}if(0===i)return c[c.length-1]=0,[a.makeTensorInfo(c,o.dtype,[]),a.makeTensorInfo(c,"int32",[])];if(1===d)return[o,Jo({attrs:{shape:c,dtype:"int32",value:0},backend:a})];const p=a.texData.get(o.dataId),h=null!==p&&p.isPacked,f=h?a.unpackTensor(o):o,x=t.util.sizeFromShape(c)/d,m=da({inputs:{x:f},attrs:{shape:[x,d]},backend:a});h&&cl(a,f);const g=dl(i),b=dl(d);let v=null;const C=()=>null===v?[m,m]:[m,v],$=(e,t,n)=>{const r=C(),o=new ul(n),i=[[d],[null===v?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],s=v;v=a.runWebGLProgram(o,r,"int32",i),cl(a,s)};for(let e=1;e<g;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)$(t,n,[x,b])}for(let e=b;e>g;e/=2){const t=C(),n=new ll([x,e/2]),r=[[d],[null===v?1:0],[g]],o=v;v=a.runWebGLProgram(n,t,"int32",r),cl(a,o);const i=g/2,s=2*i;for(let e=i;e>=1;e/=2)$(s,e,v.shape)}let I=v;v=gr({inputs:{x:v},backend:a,attrs:{begin:0,size:[x,i]}}),cl(a,I);let k=gi({inputs:{x:m,indices:v},backend:a,attrs:{axis:1,batchDims:1}});cl(a,m);const y=c.slice(0,-1);y.push(i),I=v,v=da({inputs:{x:v},attrs:{shape:y},backend:a}),cl(a,I);const S=k;return k=da({inputs:{x:k},attrs:{shape:y},backend:a}),cl(a,S),[k,v]}};class hl{constructor(e,t,n,a,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i="nearest"===n?1:2;let s;switch(a){case"constant":s=1;break;case"reflect":s=2;break;case"wrap":s=3;break;case"nearest":s=4;break;default:s=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${s} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${s} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const fl={kernelName:t.Transform,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:o}=t,{interpolation:i,fillMode:s,fillValue:u,outputShape:l}=a,[c,d,p,h]=r.shape,[f,x]=null!=l?l:[d,p],m=new hl(d,p,i,s,u,[c,f,x,h]);return n.runWebGLProgram(m,[r,o],"float32")}};const xl={kernelName:t.Unique,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:o}=t;oe(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=a.readSync(o.dataId),{outputValues:s,outputShape:u,indices:l}=kn(i,r,o.shape,o.dtype);return[a.makeTensorInfo(u,o.dtype,s),a.makeTensorInfo([l.length],"int32",l)]}};const ml={kernelName:t.Unpack,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:o}=a;o<0&&(o+=r.shape.length);const i=r,s=i.shape.length,u=r.shape[o],l=new Array(s-1);let c=0;for(let e=0;e<s;e++)e!==o&&(l[c++]=i.shape[e]);const d=[],p=new Array(s).fill(0),h=i.shape.slice();h[o]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[o]=e;const t=gr({inputs:{x:i},backend:n,attrs:{begin:p,size:h}}),a=da({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=a,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class gl{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,i=o*Math.ceil(r/n);this.outputShape=[a,i];const s=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let d="";r%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const bl=[ya,wa,Ta,Na,_a,Pa,La,Ba,za,Xa,ja,qa,Qa,Ja,tr,rr,or,ur,lr,cr,hr,vr,Cr,$r,wr,Er,Fr,Kn,Dr,Gr,qr,eo,to,no,ao,ro,io,uo,co,xo,vo,Co,Io,So,To,Eo,Ao,_o,Oo,Po,Lo,Uo,Wo,Go,Xo,Ko,Qo,ei,ni,oi,si,ci,pi,hi,xi,bi,Ci,Ii,Hn,ki,Vr,Si,Ri,Ei,Qn,Ai,_i,Oi,Pi,Bi,Vi,Mi,zi,ji,qi,Qi,Ji,es,ts,rs,os,is,ss,us,cs,hs,xs,ys,ca,Ss,Rs,Es,As,kr,_s,Ps,Ls,Ws,Gs,ea,zs,Hs,Sr,bs,Ks,Ys,Zs,pa,tu,au,iu,uu,du,hu,xu,gu,vu,$u,ku,Su,Ru,Eu,Au,br,ks,_u,Ou,Du,Pu,Lu,Bu,Uu,Vu,Gu,Xu,Ku,qu,Qu,Zu,Ju,el,$s,Ca,nl,rl,sl,pl,fl,Ia,xl,ml,{kernelName:t.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o,segmentIds:i}=n,{numSegments:s}=r,u=o.shape.length,l=[];let c=0;const d=t.backend_util.getAxesPermutation([c],u);let p=o;null!=d&&(p=$a({inputs:{x:o},backend:a,attrs:{perm:d}}),l.push(p),c=t.backend_util.getInnerMostAxes(1,u)[0]);const h=t.backend_util.segment_util.computeOutShape(p.shape,c,s),f=t.util.sizeFromShape([p.shape[c]]),x=da({inputs:{x:p},backend:a,attrs:{shape:[-1,f]}});l.push(x);const m=t.sumOutType(o.dtype),g=(e,n,r,o,i)=>{const s=e.shape[0],u=e.shape[1],c=t.backend_util.segment_util.segOpComputeOptimalWindowSize(u,i),d=new gl({windowSize:c,inSize:u,batchSize:s,numSegments:i},n),p=a.compileAndRun(d,[e,r],o);if(l.push(p),p.shape[1]===i)return p;const h=Xs({backend:a,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),f=il({inputs:{x:h},backend:a,attrs:{reps:[u/c]}});l.push(h),l.push(f);return g(p,n,f,o,i)},b=da({inputs:{x:g(x,"unsortedSegmentSum",i,m,s)},backend:a,attrs:{shape:h}});let v=b;if(null!=d){l.push(b);const e=t.backend_util.getUndoAxesPermutation(d);v=$a({inputs:{x:v},backend:a,attrs:{perm:e}})}return l.forEach((e=>a.disposeIntermediateTensorInfo(e))),v}},Ds];for(const e of bl)t.registerKernel(e);e.GPGPUContext=st,e.MathBackendWebGL=Vn,e.forceHalfFloat=Wn,e.gpgpu_util=it,e.setWebGLContext=i,e.version_webgl="3.15.0",e.webgl=Mn,e.webgl_util=ie,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-webgl.es2017.min.js.map
