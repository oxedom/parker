/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import*as e from"@tensorflow/tfjs-core";import{util as n,env as t,device_util as a,backend_util as r,buffer as o,upcastType as s,slice_util as i,TensorBuffer as u,kernel_impls as l,KernelBackend as c,DataStorage as d,engine as p,tidy as h,scalar as f,nextFrame as x,registerBackend as m,Identity as g,Complex as b,LeakyRelu as v,Prelu as C,Multiply as $,Reshape as I,sumOutType as y,Sum as w,Transpose as S,broadcast_util as R,_FusedMatMul as k,Abs as T,Acos as E,Acosh as N,Add as A,AddN as F,All as O,Any as _,ArgMax as D,ArgMin as L,Asin as P,Asinh as B,Atan as U,Atan2 as V,Atanh as W,AvgPool as M,AvgPool3D as G,AvgPool3DGrad as z,AvgPoolGrad as X,BatchMatMul as H,FusedBatchNorm as j,Slice as K,BatchToSpaceND as q,Bincount as Y,BroadcastArgs as Q,NotEqual as Z,Real as J,Cast as ee,Ceil as ne,ClipByValue as te,ComplexAbs as ae,Imag as re,Concat as oe,Conv2D as se,Conv2DBackpropFilter as ie,Conv2DBackpropInput as ue,Conv3D as le,Conv3DBackpropFilterV2 as ce,Conv3DBackpropInputV2 as de,Cos as pe,Cosh as he,CropAndResize as fe,Cumprod as xe,Cumsum as me,DenseBincount as ge,DepthToSpace as be,DepthwiseConv2dNative as ve,DepthwiseConv2dNativeBackpropFilter as Ce,DepthwiseConv2dNativeBackpropInput as $e,Diag as Ie,Dilation2D as ye,Einsum as we,Elu as Se,EluGrad as Re,Equal as ke,Erf as Te,Exp as Ee,ExpandDims as Ne,Expm1 as Ae,FFT as Fe,Fill as Oe,FlipLeftRight as _e,Floor as De,FloorDiv as Le,FromPixels as Pe,FusedConv2D as Be,FusedDepthwiseConv2D as Ue,GatherNd as Ve,GatherV2 as We,Greater as Me,GreaterEqual as Ge,IFFT as ze,IsFinite as Xe,IsInf as He,IsNan as je,Less as Ke,LessEqual as qe,LinSpace as Ye,Log as Qe,Log1p as Ze,LogicalAnd as Je,LogicalNot as en,LogicalOr as nn,LRN as tn,LRNGrad as an,Max as rn,Maximum as on,MaxPool as sn,MaxPool3D as un,MaxPool3DGrad as ln,MaxPoolGrad as cn,MaxPoolWithArgmax as dn,Mean as pn,Min as hn,Minimum as fn,MirrorPad as xn,Mod as mn,RealDiv as gn,Sub as bn,Softmax as vn,Multinomial as Cn,Neg as $n,NonMaxSuppressionV3 as In,NonMaxSuppressionV4 as yn,NonMaxSuppressionV5 as wn,OneHot as Sn,ZerosLike as Rn,OnesLike as kn,Pack as Tn,PadV2 as En,Pow as Nn,Prod as An,Range as Fn,Reciprocal as On,Relu as _n,Relu6 as Dn,ResizeBilinear as Ln,ResizeBilinearGrad as Pn,ResizeNearestNeighbor as Bn,ResizeNearestNeighborGrad as Un,Reverse as Vn,RotateWithOffset as Wn,Round as Mn,Rsqrt as Gn,ScatterNd as zn,Select as Xn,Selu as Hn,Sigmoid as jn,Sign as Kn,Sin as qn,Sinh as Yn,Softplus as Qn,SpaceToBatchND as Zn,SparseFillEmptyRows as Jn,SparseReshape as et,SparseSegmentMean as nt,SparseSegmentSum as tt,SparseToDense as at,SplitV as rt,Sqrt as ot,Square as st,SquaredDifference as it,Step as ut,StridedSlice as lt,StringNGrams as ct,StringSplit as dt,StringToHashBucketFast as pt,Tan as ht,Tanh as ft,Tile as xt,TopK as mt,Transform as gt,Unique as bt,Unpack as vt,UnsortedSegmentSum as Ct,registerKernel as $t}from"@tensorflow/tfjs-core";const It={},yt={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function wt(e,n){It[e]=n}function St(e,n){if(!(e in It)||null!=n){const t=function(e,n){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=null==n?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):n;if(t.addEventListener("webglcontextlost",(n=>{n.preventDefault(),delete It[e]}),!1),1===e)return t.getContext("webgl",yt)||t.getContext("experimental-webgl",yt);return t.getContext("webgl2",yt)}(e,n);if(null===t)return console.log("Could not get context for WebGL version",e),null;It[e]=t}const t=It[e];return null==t||t.isContextLost()?(delete It[e],St(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),It[e])}var Rt,kt,Tt;function Et(e,n){return[n,e]}function Nt(e){const t=n.sizeFromShape(e),a=Math.ceil(t/4);return n.sizeToSquarishShape(a)}function At(e,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(e/2))]}function Ft(e,n){const a=e;let r,o,s,i,u,l,c,d,p,h;return 2===t().getNumber("WEBGL_VERSION")?(r=a.R32F,o=a.R16F,s=a.RGBA16F,i=a.RGBA32F,u=a.RED,c=4,d=1,p=a.HALF_FLOAT,h=a.FLOAT,l=a.RGBA8):(r=e.RGBA,o=e.RGBA,s=e.RGBA,i=a.RGBA,u=e.RGBA,c=4,d=4,p=null!=n?n.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:h}}function Ot(e,n){const a=n();return t().getBool("DEBUG")&&function(e){const n=e.getError();if(n!==e.NO_ERROR)throw new Error("WebGL Error: "+Dt(e,n))}(e),a}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(Rt||(Rt={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(kt||(kt={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Tt||(Tt={}));function _t(e){return!!(t().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function Dt(e,n){switch(n){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}function Lt(e,n){return ra(e,(()=>e.getExtension(n)),'Extension "'+n+'" not supported on this browser.')}function Pt(e,n){const t=ra(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(Ot(e,(()=>e.shaderSource(t,n))),Ot(e,(()=>e.compileShader(t))),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Bt(e,n){const a=ra(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(Ot(e,(()=>e.shaderSource(a,n))),Ot(e,(()=>e.compileShader(a))),t().get("ENGINE_COMPILE_ONLY"))return a;if(!1===e.getShaderParameter(a,e.COMPILE_STATUS))throw Vt(n,e.getShaderInfoLog(a)),new Error("Failed to compile fragment shader.");return a}const Ut=/ERROR: [0-9]+:([0-9]+):/g;function Vt(e,t){const a=Ut.exec(t);if(null==a)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+a[1],o=e.split("\n"),s=o.length.toString().length+2,i=o.map(((e,t)=>n.rightPad((t+1).toString(),s)+e));let u=0;for(let e=0;e<i.length;e++)u=Math.max(i[e].length,u);const l=i.slice(0,r-1),c=i.slice(r-1,r),d=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${n.rightPad(c[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function Wt(e){return ra(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function Mt(e,n){if(Ot(e,(()=>e.linkProgram(n))),!t().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function Gt(e,n){if(Ot(e,(()=>e.validateProgram(n))),!1===e.getProgramParameter(n,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function zt(e,n){const t=ra(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Ot(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,t))),Ot(e,(()=>e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW))),t}function Xt(e,n){const t=ra(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Ot(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t))),Ot(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW))),t}function Ht(e){return ra(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function jt(e,n){const a=t().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0){throw new Error("Requested texture size "+`[${e}x${n}]`+" is invalid.")}if(e>a||n>a){throw new Error("Requested texture size "+`[${e}x${n}]`+" greater than WebGL maximum on this browser / GPU "+`[${a}x${a}]`+".")}}function Kt(e){return ra(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function qt(e,n,t,a,r,o,s){const i=e.getAttribLocation(n,t);return-1!==i&&(Ot(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),Ot(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,o,s))),Ot(e,(()=>e.enableVertexAttribArray(i))),!0)}function Yt(e,n,t){oa(e,t),Ot(e,(()=>e.activeTexture(e.TEXTURE0+t))),Ot(e,(()=>e.bindTexture(e.TEXTURE_2D,n)))}function Qt(e,n,t){return ra(e,(()=>e.getUniformLocation(n,t)),'uniform "'+t+'" not present in program.')}function Zt(e,n,t){return e.getUniformLocation(n,t)}function Jt(e,n,t,a){Ot(e,(()=>Yt(e,n,a))),Ot(e,(()=>e.uniform1i(t,a)))}function ea(e,n,t){Ot(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),Ot(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)))}function na(e,n){Ot(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),Ot(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function ta(e){const n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+aa(e,n))}function aa(e,n){switch(n){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}function ra(e,n,t){const a=Ot(e,(()=>n()));if(null==a)throw new Error(t);return a}function oa(e,n){const t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=n+e.TEXTURE0;if(a<e.TEXTURE0||a>t){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${t}]`}.`)}}function sa(e,t=2){return n.sizeFromShape(e.slice(0,e.length-t))}function ia(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function ua(e){let n=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(n=[sa(e),...ia(e)]),n}function la(e,a=!1){let r=t().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(a&&(r*=2,1===(e=e.map(((t,a)=>a>=e.length-2?n.nearestLargerEven(e[a]):e[a]))).length&&(e=[2,e[0]])),2!==e.length){const t=n.squeezeShape(e);e=t.newShape}let o=n.sizeFromShape(e);if(e.length<=1&&o<=r)return[1,o];if(2===e.length&&e[0]<=r&&e[1]<=r)return e;if(3===e.length&&e[0]*e[1]<=r&&e[2]<=r)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=r&&e[1]*e[2]<=r)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=r&&e[3]<=r)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=r&&e[1]*e[2]*e[3]<=r)return[e[0],e[1]*e[2]*e[3]];if(a){const t=sa(e);let a=2,r=2;return e.length&&([a,r]=ia(e)),o=t*(a/2)*(r/2),n.sizeToSquarishShape(o).map((e=>2*e))}return n.sizeToSquarishShape(o)}function ca(e){return e%2==0}function da(e,t){if(e=e.slice(-2),t=t.slice(-2),n.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],a=t.slice(-1)[0];if(n===a)return!0;if(ca(n)&&ca(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&ca(e[0])&&ca(t[0])}let pa,ha;function fa(e){if(null==pa){const n=St(e);pa=n.getParameter(n.MAX_TEXTURE_SIZE)}return pa}function xa(e){if(null==ha){const n=St(e);ha=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ha)}function ma(e){if(0===e)return 0;let n;const t=St(e);return n=ga(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:ga(t,"EXT_disjoint_timer_query")?1:0,n}function ga(e,n){return null!=e.getExtension(n)}function ba(e){try{if(null!=St(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function va(e){if(0===e)return!1;const n=St(e);if(1===e){if(!ga(n,"OES_texture_float"))return!1}else if(!ga(n,"EXT_color_buffer_float"))return!1;return $a(n)}function Ca(e){if(0===e)return!1;const n=St(e);if(1!==e){if(ga(n,"EXT_color_buffer_float"))return $a(n);const e="EXT_color_buffer_half_float";if(ga(n,e)){const t=n.getExtension(e);return function(e,n){const t=Ft(e,n),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatHalfFloat,r,o,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(s),i}(n,t)}return!1}if(!ga(n,"OES_texture_float"))return!1;if(!ga(n,"WEBGL_color_buffer_float"))return!1;return $a(n)}function $a(e){const n=Ft(e),t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(a),r}function Ia(e){if(2!==e)return!1;return null!=St(e).fenceSync}function ya(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&n.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var wa={__proto__:null,callAndCheck:Ot,canBeRepresented:_t,getWebGLErrorMessage:Dt,getExtensionOrThrow:Lt,createVertexShader:Pt,createFragmentShader:Bt,logShaderSourceAndInfoLog:Vt,createProgram:Wt,linkProgram:Mt,validateProgram:Gt,createStaticVertexBuffer:zt,createStaticIndexBuffer:Xt,getNumChannels:function(){return 2===t().getNumber("WEBGL_VERSION")?1:4},createTexture:Ht,validateTextureSize:jt,createFramebuffer:Kt,bindVertexBufferToProgramAttribute:qt,bindTextureUnit:Yt,unbindTextureUnit:function(e,n){oa(e,n),Ot(e,(()=>e.activeTexture(e.TEXTURE0+n))),Ot(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))},getProgramUniformLocationOrThrow:Qt,getProgramUniformLocation:Zt,bindTextureToProgramUniformSampler:Jt,bindCanvasToFramebuffer:function(e){Ot(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),Ot(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),Ot(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))},bindColorTextureToFramebuffer:ea,unbindColorTextureFromFramebuffer:na,validateFramebuffer:ta,getFramebufferErrorMessage:aa,getBatchDim:sa,getRowsCols:ia,getShapeAs3D:ua,getTextureShapeFromLogicalShape:la,isReshapeFree:da,getWebGLMaxTextureSize:fa,resetMaxTextureSize:function(){pa=null},resetMaxTexturesInShader:function(){ha=null},getMaxTexturesInShader:xa,getWebGLDisjointQueryTimerVersion:ma,hasExtension:ga,isWebGLVersionEnabled:ba,isCapableOfRenderingToFloatTexture:va,isDownloadFloatTextureEnabled:Ca,isWebGLFenceEnabled:Ia,assertNotComplex:ya};const Sa=t();function Ra(){let e,n,a,r,o,s,i,u,l,c;return 2===t().getNumber("WEBGL_VERSION")?(e="#version 300 es",n="in",a="out",r="in",o="texture",s="outputColor",i="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",n="attribute",a="varying",r="varying",o="texture2D",s="gl_FragColor",i="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:n,varyingVs:a,varyingFs:r,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function ka(e,t,a="index"){const r=n.computeStrides(t);return r.map(((n,t)=>`${`int ${e[t]} = ${a} / ${n}`}; ${t===r.length-1?`int ${e[t+1]} = ${a} - ${e[t]} * ${n}`:`index -= ${e[t]} * ${n}`};`)).join("")}function Ta(e,t,a="index"){const r=n.computeStrides(t);return r.map(((n,t)=>`${`int ${e[t]} = ${a} / outShapeStrides[${t}]`}; ${t===r.length-1?`int ${e[t+1]} = ${a} - ${e[t]} * outShapeStrides[${t}]`:`index -= ${e[t]} * outShapeStrides[${t}]`};`)).join("")}function Ea(e,n,t="index"){const a=function(e,n){const t=e.length,a=e.map((e=>`${n}[${e}]`)),r=new Array(t-1);r[t-2]=a[t-1];for(let e=t-3;e>=0;--e)r[e]=`(${r[e+1]} * ${a[e+1]})`;return r}(e.map(((e,n)=>n)),n);return a.map(((n,r)=>`${`int ${e[r]} = ${t} / ${a[r]}`}; ${r===a.length-1?`int ${e[r+1]} = ${t} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`};`)).join("")}function Na(e){const t=n.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Sa.registerFlag("HAS_WEBGL",(()=>Sa.getNumber("WEBGL_VERSION")>0)),Sa.registerFlag("WEBGL_VERSION",(()=>ba(2)?2:ba(1)?1:0)),Sa.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),Sa.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===Sa.get("WEBGL_VERSION"))),Sa.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),Sa.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),Sa.registerFlag("WEBGL_PACK",(()=>Sa.getBool("HAS_WEBGL"))),Sa.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_PACK_CLIP",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_PACK_REDUCE",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_LAZILY_UNPACK",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_CONV_IM2COL",(()=>Sa.getBool("WEBGL_PACK"))),Sa.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>fa(Sa.getNumber("WEBGL_VERSION")))),Sa.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>xa(Sa.getNumber("WEBGL_VERSION")))),Sa.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=Sa.getNumber("WEBGL_VERSION");return 0===e?0:ma(e)})),Sa.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>Sa.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!a.isMobile())),Sa.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>va(Sa.getNumber("WEBGL_VERSION")))),Sa.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!Sa.getBool("WEBGL_FORCE_F16_TEXTURES")&&Sa.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),Sa.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>Ca(Sa.getNumber("WEBGL_VERSION")))),Sa.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>Ia(Sa.getNumber("WEBGL_VERSION")))),Sa.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>Sa.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),Sa.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),Sa.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>a.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),Sa.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),Sa.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),Sa.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),Sa.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));const Aa="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Fa}=r;function Oa(e,t,a){const r=[];if(e.forEach((e=>{const t=n.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),a.enableShapeUniforms){const{uniformShape:n}=za(a.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(n.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),a.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}a.customUniforms&&a.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const o=r.join("\n"),s=e.map((e=>function(e,t,a=!1,r){let o="";o+=a?Da(e,r):_a(e,r);const s=e.shapeInfo.logicalShape,i=t.logicalShape;s.length<=i.length&&(o+=a?function(e,t){const a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),o="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,u=Fa(e.shapeInfo.logicalShape,t.logicalShape),l=Ga(i),c=i-s;let d;const p=["x","y","z","w","u","v"];d=0===s?"":i<2&&u.length>=1?"coords = 0;":u.map((e=>`coords.${p[e+c]} = 0;`)).join("\n");let h="";h=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${p[n+c]}`)).join(", ");let f="return outputValue;";const x=1===n.sizeFromShape(e.shapeInfo.logicalShape),m=1===n.sizeFromShape(t.logicalShape);if(1!==s||x||m){if(x&&!m)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){const e=s-2,n=s-1;u.indexOf(e)>-1&&u.indexOf(n)>-1?f="return vec4(outputValue.x);":u.indexOf(e)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(n)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(e,t):function(e,t){const a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),o="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,u=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&u===l&&null==e.shapeInfo.flatOffset&&n.arraysEqual(i,s))return`\n      float ${o}() {\n        return sampleTexture(${a}, resultUV);\n      }\n    `;const c=Ga(l),d=Fa(e.shapeInfo.logicalShape,t.logicalShape),p=l-u;let h;const f=["x","y","z","w","u","v"];h=0===u?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${f[e+p]} = 0;`)).join("\n");let x="";x=l<2&&u>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${f[n+p]}`)).join(", ");return`\n    float ${o}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${r}(${x});\n    }\n  `}(e,t));return o}(e,t,a.packedInputs,a.enableShapeUniforms))).join("\n"),i=t.texShape,u=Ra(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,d,p=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${La}\n    ${Pa}\n    ${Ba}\n  `}(u);t.isPacked?(c=function(e,t,a){switch(e.length){case 0:return Va();case 1:return function(e,n,t){const a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(1===a[0])return t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${a[1]}.0);\n      }\n    `;if(1===a[1])return t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${a[0]}.0);\n      }\n    `;if(t)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);\n    }\n  `}(0,t,a);case 2:return function(e,t,a){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(n.arraysEqual(e,t))return a?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const o=Math.ceil(e[1]/2);if(a)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,a);case 3:return function(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[2]/2),o=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,a);default:return function(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],r=Math.ceil(e[e.length-1]/2),o=r*Math.ceil(e[e.length-2]/2);let s=o,i="",u="b, r, c";for(let n=2;n<e.length-1;n++)s*=e[e.length-n-1],i=`\n      int b${n} = index / ${s};\n      index -= b${n} * ${s};\n    `+i,u=`b${n}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,t,a)}}(t.logicalShape,i,a.enableShapeUniforms),d=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t,a){switch(e.length){case 0:return Va();case 1:return function(e,n,t){if(1===n[0])return t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `;if(t)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,t,a);case 2:return function(e,t,a){if(n.arraysEqual(e,t))return a?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return a?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return a?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(a)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,a);case 3:return function(e,n,t){if(t){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Ta(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const a=ka(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${a}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,a);case 4:return function(e,n,t){if(t){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Ta(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const a=ka(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${a}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,a);case 5:return function(e,n){const t=ka(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,n){const t=ka(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,a.enableShapeUniforms),d=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),a.packedInputs&&(p+=Ua);return[p,l,d,o,c,s,a.userCode].join("\n")}function _a(e,t=!1){const a=e.shapeInfo.logicalShape;switch(a.length){case 0:return function(e,n){const t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${t};}`;const[r,o]=e.shapeInfo.texShape;if(1===r&&1===o)return`\n      float ${a}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const s=Wa(t);if(n)return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[i,u]=e.shapeInfo.texShape;return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${i}, ${u}, ${s});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,t);case 1:return function(e,n){const t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${a}(int index) {\n        ${Ma(e)}\n      }\n    `;const r=e.shapeInfo.texShape,o=r[0],s=r[1];if(1===s&&1===o)return`\n      float ${a}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const i=Wa(t);if(1===s)return n?`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${o}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===o)return n?`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${s}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(n)return`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `;return`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${s}, index + ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&n.arraysEqual(a,s)){if(t)return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:u}=n.squeezeShape(a),l=i;if(l.length<a.length){const n=["row","col"];return`\n      ${_a(Xa(e,l),t)}\n      float ${o}(int row, int col) {\n        return ${o}(${Ha(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${a[1]}, 1)));\n        ${Ma(e)}\n      }\n    `;const c=s[0],d=s[1],p=Wa(r);if(1===d)return t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${a[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===c)return t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${a[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${a[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=a[1]*a[2],i=a[2],{newShape:u,keptDims:l}=n.squeezeShape(a),c=u;if(c.length<a.length){const n=["row","col","depth"];return`\n        ${_a(Xa(e,c),t)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${Ha(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${Ma(e)}\n      }\n    `;const d=e.shapeInfo.texShape,p=d[0],h=d[1],f=e.shapeInfo.flatOffset;if(h===s&&null==f)return t?`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==f)return t?`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${a[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const x=Wa(r);if(t)return`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${s} + col * ${i} + depth + ${x};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${x};\n        vec2 uv = uvFromFlat(${p}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=a[3],i=a[2]*s,u=a[1]*i,{newShape:l,keptDims:c}=n.squeezeShape(a);if(l.length<a.length){const n=["row","col","depth","depth2"];return`\n      ${_a(Xa(e,l),t)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${Ha(n,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${u}, ${i}, ${s}, 1)));\n        ${Ma(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1],x=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===u&&null==d)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${x}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===s&&null==d)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${a[1]*a[2]}, ${a[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const b=Wa(r);if(t)return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${x}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,u=t[1]*i,{newShape:l,keptDims:c}=n.squeezeShape(t);if(l.length<t.length){const n=["row","col","depth","depth2","depth3"];return`\n      ${_a(Xa(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Ha(n,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${i}, ${s}, ${o})) +\n          depth3;\n        ${Ma(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===u&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;const x=Wa(a);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${i} + depth * ${s} +\n          depth2 * ${o} + depth3 + ${x};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${a}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),{newShape:o,keptDims:s}=n.squeezeShape(t);if(o.length<t.length){const n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${_a(Xa(e,o))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Ha(n,s)});\n      }\n    `}const i=t[5],u=t[4]*i,l=t[3]*u,c=t[2]*l,d=t[1]*c;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${l}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Ma(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,f=h[0],x=h[1];if(x===d&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${u}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${f}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;if(x===i&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${f}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;const m=Wa(a);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${l} +\n          depth2 * ${u} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${f}, ${x}, index);\n      return sampleTexture(${a}, uv);\n    }\n  `}(e);default:throw new Error(`${a.length}-D input sampling is not yet supported`)}}function Da(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),a=Ra();return`\n    vec4 ${t}() {\n      return ${a.texture2D}(${n}, halfCR);\n    }\n  `}(e);case 1:return function(e,n){const t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,o=Ra();if(n)return`\n    vec4 ${a}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `;const s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${a}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const a=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],u=s[1],l=Ra();if(null!=s&&n.arraysEqual(a,s))return t?`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],d=Math.ceil(a[1]/2);return`\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,s=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===t[0]){const a=[1,2],o=["b","row","col"];return`\n        ${Da(Xa(e,t.slice(1)),n)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Ha(o,a)});\n        }\n      `}const i=Ra();if(n)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${a}, uv);\n    }\n  `;const u=s[0],l=s[1],c=Math.ceil(t[2]/2),d=c*Math.ceil(t[1]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${d}, ${c}, b, row, col);\n      return ${i.texture2D}(${a}, uv);\n    }\n  `}(e,t);default:return function(e,n){const t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Ra();if(n)return`\n    vec4 ${a}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${t}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);\n    }\n  `;const o=e.shapeInfo.logicalShape,s=o.length,i=e.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],c=u[1],d=Math.ceil(o[s-1]/2);let p=d*Math.ceil(o[s-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<s-1;e++)h=`int b${e}, `+h,p*=o[s-e-1],f=`b${e} * ${p} + `+f;return`\n    vec4 ${a}(${h}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${r.texture2D}(${t}, uv);\n    }\n  `}(e,t)}}const La="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Pa="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ba="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ua="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Va(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Wa(e){return`offset${e}`}function Ma(e){const t=e.name,a=n.sizeFromShape(e.shapeInfo.logicalShape);return a<2?`return ${t};`:`\n    for (int i = 0; i < ${a}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Ga(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function za(e,t,a){const{newShape:r,keptDims:o}=n.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],u=i?t.slice(1):r,l=!e&&s>1&&!n.arraysEqual(t,a)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?u:t,keptDims:o}}function Xa(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function Ha(e,n){return n.map((n=>e[n])).join(", ")}function ja(e,n,a){const r={},o={},s={},i=[];let u,l,c,d=null,p=null;p=e.getUniformLocation(a,"NAN",!1),1===t().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(a,"INFINITY",!1));const h=!1;for(let t=0;t<n.variableNames.length;t++){const i=n.variableNames[t];r[i]=e.getUniformLocation(a,i,h),r[`offset${i}`]=e.getUniformLocation(a,`offset${i}`,h),n.enableShapeUniforms&&(o[`${i}Shape`]=e.getUniformLocation(a,`${i}Shape`,h),s[`${i}TexShape`]=e.getUniformLocation(a,`${i}TexShape`,h))}return n.enableShapeUniforms&&(u=e.getUniformLocation(a,"outShape",h),c=e.getUniformLocation(a,"outShapeStrides",h),l=e.getUniformLocation(a,"outTexShape",h)),n.customUniforms&&n.customUniforms.forEach(((n,t)=>{i[t]=e.getUniformLocation(a,n.name,h)})),{uniformLocations:r,customUniformLocations:i,infLoc:d,nanLoc:p,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:u,outShapeStridesLocation:c,outTexShapeLocation:l}}function Ka(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,a)=>{const r=e.logicalShape,o=t[a],s=o.shape;if(!n.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&o.isUniform)return;const i=e.texShape,u=o.isUniform?null:o.texData.texShape;if(!n.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)}))}function qa(e){return t().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class Ya{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Rt.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ra();this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ta(["r","c","d"],e):ka(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Qa{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Rt.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Ra();this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ta(["r","c","d"],e):ka(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class Za{constructor(e){this.variableNames=["A"],this.outTexUsage=kt.DOWNLOAD;const n=Ra();this.outputShape=e,this.userCode=`\n      ${Aa}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${n.output} = encode_float(x);\n      }\n    `}}class Ja{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=kt.DOWNLOAD;const n=Ra();this.outputShape=e,this.userCode=`\n      ${Aa}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${n.output} = encode_float(x);\n      }\n    `}}class er{constructor(e,n=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ra();this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Na(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${t.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${t.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class nr{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ra();this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length);let a="",r="result";n&&(r="floor(result * 255. + 0.5)");for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){const o=2*n+r;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${r} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${r};\n          if (localCoords[1] + ${n} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${n};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${t.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Na(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${t.output} = ${r};\n        }\n    `}}function tr(e){const n=Ra();return Pt(e,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function ar(e){return zt(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function rr(e){return Xt(e,new Uint16Array([0,1,2,2,1,3]))}function or(e,n,a,r,o,s){jt(n,a);const i=Ht(e),u=e.TEXTURE_2D;return Ot(e,(()=>e.bindTexture(u,i))),Ot(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),Ot(e,(()=>e.texParameteri(u,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),Ot(e,(()=>e.texParameteri(u,e.TEXTURE_MIN_FILTER,e.NEAREST))),Ot(e,(()=>e.texParameteri(u,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===t().getNumber("WEBGL_VERSION")?Ot(e,(()=>e.texImage2D(u,0,r,n,a,0,o,s,null))):Ot(e,(()=>e.texStorage2D(u,1,r,n,a))),Ot(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[a,n]}}function sr(e){return e.internalFormatFloat}function ir(e,n,t,a){const[r,o]=Et(n,t);return or(e,r,o,sr(a),a.textureFormatFloat,e.FLOAT)}function ur(e){return e.internalFormatHalfFloat}function lr(e,n,t,a){const[r,o]=Et(n,t);return or(e,r,o,ur(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function cr(e){return e.downloadTextureFormat}function dr(e,n,t,a){const[r,o]=Et(n,t);return or(e,r,o,cr(a),e.RGBA,e.UNSIGNED_BYTE)}function pr(e){return e.internalFormatPackedFloat}function hr(e,n,t,a){const[r,o]=At(n,t);return or(e,r,o,pr(a),e.RGBA,e.FLOAT)}function fr(e){return e.internalFormatPackedHalfFloat}function xr(e,n,t,a){const[r,o]=At(n,t);return or(e,r,o,fr(a),e.RGBA,a.textureTypeHalfFloat)}function mr(e,n,t){Ot(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,t)));return qt(e,n,"clipSpacePos",t,3,20,0)&&qt(e,n,"uv",t,2,20,12)}function gr(e,n,a,r,o,s){let i,u,l;Ot(e,(()=>e.bindTexture(e.TEXTURE_2D,n))),o instanceof Uint8Array?(i=new Uint8Array(a*r*4),u=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(a*r*4),u=e.FLOAT,l=s.internalFormatPackedFloat),i.set(o),2===t().getNumber("WEBGL_VERSION")?Ot(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,a,r,e.RGBA,u,i))):Ot(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,a,r,0,e.RGBA,u,i))),Ot(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function br(e,n,a){Ot(e,(()=>e.bindTexture(e.TEXTURE_2D,n))),a.data instanceof Uint8Array?2===t().getNumber("WEBGL_VERSION")?Ot(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,a.width,a.height,e.RGBA,e.UNSIGNED_BYTE,a.data))):Ot(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a.width,a.height,0,e.RGBA,e.UNSIGNED_BYTE,a.data))):2===t().getNumber("WEBGL_VERSION")?Ot(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,a))):Ot(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,a))),Ot(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function vr(e,n,t,a){const r=e.createBuffer();Ot(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const o=16*n*t;return Ot(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),Ot(e,(()=>e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,0))),Ot(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}function Cr(e,n,t){const a=e,r=new Float32Array(t);return a.bindBuffer(a.PIXEL_PACK_BUFFER,n),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function $r(e,n,t,a){const[r,o]=Et(n,t),s=new Uint8Array(n*t*4);return Ot(e,(()=>e.readPixels(0,0,r,o,a.downloadTextureFormat,e.UNSIGNED_BYTE,s))),new Float32Array(s.buffer)}function Ir(e,n,t,a,r,o,s,i){const u=e,l=new Float32Array(function(e,n){const[t,a]=At(e,n);return t*a*4}(o,s));return u.bindBuffer(u.PIXEL_PACK_BUFFER,n),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function yr(e,n,t){const a=new Float32Array(n*t*4);return Ot(e,(()=>e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,a))),a}var wr={__proto__:null,createVertexShader:tr,createVertexBuffer:ar,createIndexBuffer:rr,getInternalFormatForFloat32MatrixTexture:sr,createFloat32MatrixTexture:ir,getInternalFormatForFloat16MatrixTexture:ur,createFloat16MatrixTexture:lr,getInternalFormatForUnsignedBytesMatrixTexture:cr,createUnsignedBytesMatrixTexture:dr,getInternalFormatForPackedMatrixTexture:pr,createPackedMatrixTexture:hr,getInternalFormatForFloat16PackedMatrixTexture:fr,createFloat16PackedMatrixTexture:xr,bindVertexProgramAttributeStreams:mr,uploadDenseMatrixToTexture:gr,uploadPixelDataToTexture:br,createBufferFromOutputTexture:vr,downloadFloat32MatrixFromBuffer:Cr,downloadByteEncodedFloatMatrixFromOutputTexture:$r,downloadPackedMatrixFromBuffer:Ir,downloadMatrixFromPackedOutputTexture:yr};class Sr{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const n=t().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,wt(n,e)):this.gl=St(n);let a="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===t().getNumber("WEBGL_VERSION")){const e="OES_texture_float",n="OES_texture_half_float";if(this.textureFloatExtension=Lt(this.gl,e),ga(this.gl,n))this.textureHalfFloatExtension=Lt(this.gl,n);else if(t().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(a),ga(this.gl,r))this.colorBufferHalfFloatExtension=Lt(this.gl,r);else if(t().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(a="EXT_color_buffer_float",ga(this.gl,a))this.colorBufferFloatExtension=this.gl.getExtension(a);else{if(!ga(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=ar(this.gl),this.indexBuffer=rr(this.gl),this.framebuffer=Kt(this.gl),this.textureConfig=Ft(this.gl,this.textureHalfFloatExtension)}get debug(){return t().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ot(e,(()=>e.finish())),Ot(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),Ot(e,(()=>e.deleteFramebuffer(this.framebuffer))),Ot(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),Ot(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),Ot(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),ir(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),lr(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),dr(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),br(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,t,a){this.throwIfDisposed(),gr(this.gl,e,n,t,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),xr(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),hr(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(na(this.gl,this.framebuffer),this.outputTexture=null),Ot(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,t){return this.downloadMatrixDriver(e,(()=>$r(this.gl,n,t,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,n,t,a,r,o){return Ir(this.gl,e,0,0,0,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return Cr(this.gl,e,n)}createBufferFromTexture(e,n,t){this.bindTextureToFrameBuffer(e);const a=vr(this.gl,n,t,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,a;if(t().getBool("WEBGL_FENCE_API_ENABLED")){const t=e,r=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),a=()=>{const e=t.clientWaitSync(r,0,0);return e===t.ALREADY_SIGNALED||e===t.CONDITION_SATISFIED},n=r}else t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),a=()=>this.isQueryAvailable(n,t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):a=()=>!0;return{query:n,isFencePassed:a}}downloadMatrixFromPackedTexture(e,n,t){return this.downloadMatrixDriver(e,(()=>yr(this.gl,n,t)))}createProgram(e){this.throwIfDisposed();const n=this.gl;null==this.vertexShader&&(this.vertexShader=tr(n));const t=Wt(n);return Ot(n,(()=>n.attachShader(t,this.vertexShader))),Ot(n,(()=>n.attachShader(t,e))),Mt(n,t),this.debug&&Gt(n,t),this.vertexAttrsAreBound||(this.setProgram(t),this.vertexAttrsAreBound=mr(n,this.program,this.vertexBuffer)),t}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&Ot(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&Gt(this.gl,this.program),Ot(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,n,t=!0){return this.throwIfDisposed(),t?Qt(this.gl,e,n):Zt(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),Ot(this.gl,(()=>this.gl.getAttribLocation(e,n)))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,t){this.throwIfDisposed(),this.throwIfNoProgram(),Jt(this.gl,e,n,t)}setOutputMatrixTexture(e,n,t){this.setOutputMatrixTextureDriver(e,t,n)}setOutputPackedMatrixTexture(e,n,t){this.throwIfDisposed();const[a,r]=At(n,t);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,n,t,a){this.setOutputMatrixWriteRegionDriver(t,e,a,n)}setOutputPackedMatrixWriteRegion(e,n,t,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Gt(this.gl,this.program),ta(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),Ot(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ot(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Lt(this.gl,2===t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),t=e.createQuery();return e.beginQuery(n.TIME_ELAPSED_EXT,t),t}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(2===t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,n=this.getQueryTimerExtensionWebGL2();return void e.endQuery(n.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await n.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(0===n)return null;if(2===n){const n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}{const n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(0===n)return!0;if(2===n){const n=this.gl,t=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const n=this.getQueryTimerExtensionWebGL1(),t=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),t&&!this.disjoint}}pollFence(e){return new Promise((n=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>n()))}))}pollItems(){const e=function(e){let n=0;for(;n<e.length;++n){if(!e[n]())break}return n-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let n=0;n<=e;++n){const{resolveFn:e}=this.itemsToPoll[n];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||n.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),ea(this.gl,e,this.framebuffer),this.debug&&ta(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(ea(this.gl,this.outputTexture,this.framebuffer),this.debug&&ta(this.gl)):na(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const t=n();return this.unbindTextureToFrameBuffer(),t}setOutputMatrixTextureDriver(e,n,t){this.throwIfDisposed();const a=this.gl;ea(a,e,this.framebuffer),this.debug&&ta(a),this.outputTexture=e,Ot(a,(()=>a.viewport(0,0,n,t))),Ot(a,(()=>a.scissor(0,0,n,t)))}setOutputMatrixWriteRegionDriver(e,n,t,a){this.throwIfDisposed(),Ot(this.gl,(()=>this.gl.scissor(e,n,t,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Rr(e){return(t,a,o,s,i)=>{const u=r.assertAndGetBroadcastShape(t,a),l=u.length,c=n.computeStrides(u),d=n.sizeFromShape(u),p=n.getTypedArrayFromDType(i,d),h=t.length,f=a.length,x=n.computeStrides(t),m=n.computeStrides(a),g=r.getBroadcastDims(t,u),b=r.getBroadcastDims(a,u);if(g.length+b.length===0)for(let n=0;n<p.length;++n)p[n]=e(o[n%o.length],s[n%s.length]);else for(let t=0;t<p.length;++t){const a=n.indexToLoc(t,l,c),r=a.slice(-h);g.forEach((e=>r[e]=0));const i=n.locToIndex(r,h,x),u=a.slice(-f);b.forEach((e=>u[e]=0));const d=n.locToIndex(u,f,m);p[t]=e(o[i],s[d])}return[p,u]}}const kr=Rr(((e,n)=>e+n));function Tr(e){return(t,a,r)=>{const o=n.getTypedArrayFromDType(a,t.length);for(let n=0;n<t.length;++n)o[n]=e(t[n],r);return o}}const Er=Tr((e=>Math.ceil(e)));const Nr=Rr(((e,n)=>e===n?1:0)),Ar=Tr((e=>Math.exp(e))),Fr=Tr((e=>Math.expm1(e))),Or=Tr((e=>Math.floor(e)));const _r=Rr(((e,n)=>e>n?1:0)),Dr=Rr(((e,n)=>e>=n?1:0)),Lr=Rr(((e,n)=>e<n?1:0)),Pr=Rr(((e,n)=>e<=n?1:0));const Br=Tr((e=>Math.log(e)));const Ur=Rr(((e,n)=>Math.max(e,n))),Vr=Rr(((e,n)=>Math.min(e,n))),Wr=Rr(((e,n)=>e*n));const Mr=Rr(((e,n)=>e!==n?1:0));const Gr=Tr((e=>1/Math.sqrt(e))),zr=Tr((e=>1/(1+Math.exp(-e))));const Xr=Tr((e=>Math.sqrt(e))),Hr=Rr(((e,n)=>{const t=e-n;return t*t}));class jr{constructor(e,t,a,r,o,s){this.separator=n.encodeString(e),this.nGramWidths=t,this.leftPad=n.encodeString(a),this.rightPad=n.encodeString(r),this.padWidth=o,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const t=this.getPadWidth(n);return Math.max(0,e+2*t-n+1)}createNGrams(e,n,t,a,r,o){for(let s=0;s<r;++s){const i=this.getPadWidth(o),u=Math.max(0,i-s),l=Math.max(0,i-(r-(s+1))),c=o-(u+l),d=n+(u>0?0:s-i);let p=0;p+=u*this.leftPad.length;for(let n=0;n<c;++n)p+=e[d+n].length;p+=l*this.rightPad.length;p+=(u+l+c-1)*this.separator.length,t[a+s]=new Uint8Array(p);const h=t[a+s];let f=0;const x=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<u;++e)x(this.leftPad),x(this.separator);for(let n=0;n<c-1;++n)x(e[d+n]),x(this.separator);if(c>0){x(e[d+c-1]);for(let e=0;e<l;++e)x(this.separator),x(this.rightPad)}else{for(let e=0;e<l-1;++e)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){const a=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let n=1;n<r;++n){let r=t[n]>=e;if(r=r&&t[n]<=a,!r)throw new Error(`Invalid split value ${t[n]}, must be in [${e}, ${a}]`);e=t[n]}if(e!==a)throw new Error(`Last split value must be data size. Expected ${a}, got ${e}`)}const o=r-1,s=n.getArrayFromDType("int32",r);if(0===a||0===r){const e=new Array(a);for(let e=0;e<=o;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=o;++e){const n=t[e]-t[e-1];let a=0;this.nGramWidths.forEach((e=>{a+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===a&&(a=1),s[e]=s[e-1]+a}const i=new Array(s[o]);for(let n=0;n<o;++n){const a=t[n];let r=s[n];if(this.nGramWidths.forEach((o=>{const s=t[n+1]-t[n],u=this.getNumNGrams(s,o);this.createNGrams(e,a,i,r,u,o),r+=u})),this.preserveShort&&r===s[n]){const o=t[n+1]-t[n];if(0===o)continue;const s=o+2*this.padWidth,u=1;this.createNGrams(e,a,i,r,u,s)}}return[i,s]}}function Kr(e,n,t,a){if(!e.length)return;if(0===n.length){for(let n=0;n<e.length;++n)a.push(e.subarray(n,n+1));return}if(1===n.length){const r=n[0];let o=e.indexOf(r);for(;-1!==o;){const n=e.subarray(0,o);t&&0===n.length||a.push(n),o=(e=e.subarray(o+1)).indexOf(r)}return void(t&&0===e.length||a.push(e))}let r=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==n.indexOf(e[o])){const n=e.subarray(r,o);t&&0===n.length||a.push(n),r=o+1}}const qr=Rr(((e,n)=>e-n));const Yr=(e,n)=>{const t=n.value-e.value;return 0===t?e.index-n.index:t};function Qr(e,t,a=0,r=e.length-1){for(;r>a;){if(r-a>600){const n=r-a+1,o=t-a+1,s=Math.log(n),i=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*i*(n-i)/n)*Math.sign(o-n/2);Qr(e,t,Math.max(a,Math.floor(t-o*i/n+u)),Math.min(r,Math.floor(t+(n-o)*i/n+u)))}const o=e[t];let s=a,i=r;for(n.swap(e,a,t),Yr(e[r],o)>0&&n.swap(e,a,r);s<i;){for(n.swap(e,s,i),s++,i--;Yr(e[s],o)<0;)s+=1;for(;Yr(e[i],o)>0;)i-=1}0===Yr(e[a],o)?n.swap(e,a,i):(i+=1,n.swap(e,i,r)),i<=t&&(a=i+1),t<=i&&(r=i-1)}}var Zr={__proto__:null,simpleAbsImpl:function(e){const n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=Math.abs(e[t]);return n},addImpl:kr,bincountImpl:function(e,t,a,r,o){const s=n.sizeFromShape(r),i=n.makeZerosTypedArray(o,a);for(let n=0;n<e.length;n++){const a=e[n];if(a<0)throw new Error("Input x must be non-negative!");a>=o||(i[a]+=s>0?t[n]:1)}return i},bincountReduceImpl:function(e,n,t,a=!1){const r=e.shape[0],s=e.shape[1],i=o([r,t],n.dtype);for(let o=0;o<r;o++)for(let r=0;r<s;r++){const s=e.get(o,r);if(s<0)throw new Error("Input x must be non-negative!");s>=t||(a?i.set(1,o,s):n.size>0?i.set(i.get(o,s)+n.get(o,r),o,s):i.set(i.get(o,s)+1,o,s))}return i},ceilImpl:Er,concatImpl:function(e,t,a,o){const s=n.getArrayFromDType(a,n.sizeFromShape(t));if(o&&"string"!==a){let t=0;e.forEach((e=>{const a=n.sizeFromShape(e.shape);s.set(e.vals,t),t+=a}))}else{let n=0;e.forEach((e=>{const o="string"===a?r.fromUint8ToStringArray(e.vals):e.vals;let i=0;for(let a=0;a<e.shape[0];++a){const r=a*t[1]+n;for(let n=0;n<e.shape[1];++n)s[r+n]=o[i++]}n+=e.shape[1]}))}return s},equalImpl:Nr,expImpl:Ar,expm1Impl:Fr,floorImpl:Or,gatherNdImpl:function(e,n,t,a,r,s,i,u,l){const c=o([a,s],t);for(let t=0;t<a;t++){const a=[];let o=0;for(let n=0;n<r;n++){const s=e[t*r+n];o+=s*i[n],a.push(s)}if(o<0||o>=l/s)throw new Error(`Invalid indices: ${a} does not index into ${u}`);for(let e=0;e<s;e++)c.values[t*s+e]=n.get(...n.indexToLoc(o*s+e))}return c},gatherV2Impl:function(e,n,t){const a=o(t,e.dtype);for(let t=0;t<a.size;++t){const r=a.indexToLoc(t).slice(),o=r[0],s=r[2],i=n.locToIndex([o,s]);r[2]=n.values[i];const u=e.locToIndex(r);0<=u&&u<e.values.length&&(a.values[t]=e.values[u])}return a},greaterImpl:_r,greaterEqualImpl:Dr,lessImpl:Lr,lessEqualImpl:Pr,linSpaceImpl:function(e,t,a){const r=(t-e)/(a-1),o=n.makeZerosTypedArray(a,"float32");o[0]=e;for(let e=1;e<o.length;e++)o[e]=o[e-1]+r;return o},logImpl:Br,maxImpl:function(e,t,a,r){const o=n.getTypedArrayFromDType(r,n.sizeFromShape(a));for(let n=0;n<o.length;++n){const a=n*t;let r=e[a];for(let n=0;n<t;++n){const t=e[a+n];(Number.isNaN(t)||t>r)&&(r=t)}o[n]=r}return o},maximumImpl:Ur,minimumImpl:Vr,multiplyImpl:Wr,negImpl:function(e,t,a){const r=n.createScalarValue(-1,a);return Wr([],t,r,e,a)},notEqualImpl:Mr,prodImpl:function(e,t,a,o){const[i,u]=r.computeOutAndReduceShapes(e,o),l=s(t,"int32"),c=n.makeZerosTypedArray(n.sizeFromShape(i),l),d=n.sizeFromShape(u);for(let e=0;e<c.length;++e){const n=e*d;let t=1;for(let e=0;e<d;++e)t*=a[n+e];c[e]=t}return{outVals:c,outShape:i,outDtype:l}},rangeImpl:function(e,t,a,r){if(e===t||e<t&&a<0||t<e&&a>1)return n.makeZerosTypedArray(0,r);const o=Math.abs(Math.ceil((t-e)/a)),s=n.makeZerosTypedArray(o,r);t<e&&1===a&&(a=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+a;return s},rsqrtImpl:Gr,sigmoidImpl:zr,sliceImpl:function(e,t,a,s,u){const l=i.isSliceContinous(s,t,a),c=n.sizeFromShape(a),d=n.computeStrides(s);if(l){const n=i.computeFlatOffset(t,d);return"string"===u?e.slice(n,n+c):e.subarray(n,n+c)}const p="string"===u?r.fromUint8ToStringArray(e):e,h=o(s,u,p),f=o(a,u);for(let e=0;e<f.size;++e){const n=f.indexToLoc(e),a=n.map(((e,n)=>e+t[n]));f.set(h.get(...a),...n)}return"string"===u?r.fromStringArrayToUint8(f.values):f.values},sparseFillEmptyRowsImpl:function(e,t,a,o,s,i,u){const l=t[0],c=i[0],d=new Array(c),p=new Array(l),h=t[1];if(0===c){if(0!==l)throw new Error(r.getSparseFillEmptyRowsIndicesDenseShapeMismatch(l));return[n.getArrayFromDType(a,0),[0,h],n.getArrayFromDType(s,0),d,p]}let f=!0,x=0;const m=new Array(c).fill(0);for(let n=0;n<l;++n){const t=e[n*h];if(t<0)throw new Error(r.getSparseFillEmptyRowsNegativeIndexErrorMessage(n,t));if(t>=c)throw new Error(r.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(n,t,c));++m[t],f=f&&t>=x,x=t}let g=!0;for(let e=0;e<c;++e){const n=0===m[e];d[e]=n,g=g&&!n,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&f){const n=e,t=o;for(let e=0;e<l;++e)p[e]=e;return[n,[l,h],t,d,p]}{const t=m[c-1],r=n.getArrayFromDType(a,t*h),i=n.getArrayFromDType(s,t),f=new Array(c).fill(0);for(let n=0;n<l;++n){const t=e[n*h],a=f[t],s=(0===t?0:m[t-1])+a;f[t]++;for(let t=0;t<h;++t)r[s*h+t]=e[n*h+t];i[s]=o[n],p[n]=s}for(let e=0;e<c;++e){if(0===f[e]){const n=0===e?0:m[e-1];r[n*h+0]=e;for(let e=1;e<h;++e)r[n*h+e]=0;i[n]=u}}return[r,[t,h],i,d,p]}},sparseReshapeImpl:function(e,t,a,o,s){const i=n.sizeFromShape(o),u=t[0],l=s.length,c=[];let d=1,p=-1;for(let e=0;e<l;++e){const n=s[e];if(-1===n){if(-1!==p)throw new Error(r.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,e));p=e,c.push(1)}else{if(n<0)throw new Error(r.getSparseReshapeNegativeOutputDimErrorMessage(e,n));d*=n,c.push(n)}}if(-1!==p){if(d<=0)throw new Error(r.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(i/d);if(d*e!==i)throw new Error(r.getSparseReshapeInputOutputMultipleErrorMessage(o,c));c[p]=e}if(n.sizeFromShape(c)!==i)throw new Error(r.getSparseReshapeInputOutputMismatchErrorMessage(o,c));const h=o.length,f=[];if(h>0){f[h-1]=1;for(let e=h-2;e>=0;--e)f[e]=f[e+1]*o[e+1]}const x=[];if(l>0){x[l-1]=1;for(let e=l-2;e>=0;--e)x[e]=x[e+1]*c[e+1]}const m=n.getArrayFromDType(a,u*l);for(let n=0;n<u;++n){let t=0;for(let a=0;a<h;++a)t+=e[n*h+a]*f[a];for(let e=0;e<l;++e)m[n*l+e]=Math.trunc(t/x[e]),t%=x[e]}return[m,[u,l],c]},sparseSegmentReductionImpl:function(e,t,a,o,s,i=!1,u=0){const l=o.length,c=[t[0],e.length/t[0]],d=c[1],p=l>0?s[l-1]+1:0;if(p<0)throw new Error(r.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const h=t.slice();h[0]=p;const f=h.reduce(((e,n)=>e*n),1),x=n.getArrayFromDType(a,f);if(0===l)return p>0&&x.fill(u),[x,h];if(p<=0)throw new Error(r.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,b=0,v=s[m];for(;;){let n=0;if(g<l){if(n=s[g],v===n){++g;continue}if(v>=n)throw new Error(r.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(v<0||v>=p)throw new Error(r.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v,p));v>b&&x.fill(u,b*d,v*d);for(let n=m;n<g;++n){const t=o[n];if(t<0||t>=c[0])throw new Error(r.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,o[n],c[0]));for(let n=0;n<d;n++)x[v*d+n]+=e[t*d+n]}if(i)for(let e=0;e<d;e++)x[v*d+e]/=g-m;if(m=g,++g,b=v+1,v=n,g>l)break}return b<p&&x.fill(u,b*d,p*d),[x,h]},sqrtImpl:Xr,squaredDifferenceImpl:Hr,stridedSliceImpl:function(e,n,t,a){const r=o(e,n.dtype);for(let e=0;e<r.size;e++){const o=r.indexToLoc(e),s=new Array(o.length);for(let e=0;e<s.length;e++)s[e]=o[e]*t[e]+a[e];r.set(n.get(...s),...o)}return r},stringNGramsImpl:function(e,n,t,a,r,o,s,i){return new jr(t,a,r,o,s,i).compute(e,n)},stringSplitImpl:function(e,t,a){const r=e.length,o=[];let s=0,i=0;const u=new Array(r);for(let n=0;n<r;++n){const r=o.length;Kr(e[n],t,a,o);const l=o.length-r;u[n]=l,s+=l,i=Math.max(i,l)}const l=n.getArrayFromDType("int32",2*s),c=new Array(s),d=[r,i];let p=0;for(let e=0;e<r;++e)for(let n=0;n<u[e];++n)l[2*p]=e,l[2*p+1]=n,c[p]=o[p],++p;return[l,c,d]},stringToHashBucketFastImpl:function(e,t){const a=n.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)a[r]=n.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return a},subImpl:qr,tileImpl:function(e,n){const t=new Array(e.rank);for(let a=0;a<t.length;a++)t[a]=e.shape[a]*n[a];const a=o(t,e.dtype);for(let n=0;n<a.values.length;++n){const t=a.indexToLoc(n),r=new Array(e.rank);for(let n=0;n<r.length;n++)r[n]=t[n]%e.shape[n];const o=e.locToIndex(r);a.values[n]=e.values[o]}return a},topKImpl:function(e,t,a,r,s){const i=t[t.length-1],[u,l]=[e.length/i,i],c=n.getTypedArrayFromDType(a,u*r),d=n.getTypedArrayFromDType("int32",u*r);for(let n=0;n<u;n++){const t=n*l,a=e.subarray(t,t+l);let o=new Array(a.length);a.forEach(((e,n)=>o[n]={value:e,index:n})),r<o.length&&(Qr(o,r),o=o.slice(0,r)),s&&o.sort(Yr);const i=n*r,u=c.subarray(i,i+r),p=d.subarray(i,i+r);for(let e=0;e<r;e++)u[e]=o[e].value,p[e]=o[e].index}const p=t.slice();return p[p.length-1]=r,[o(p,a,c),o(p,"int32",d)]},transposeImpl:function(e,t,a,r,o){const s=t.length,i=n.sizeFromShape(t),u=n.computeStrides(t),l=n.computeStrides(o),c=n.getTypedArrayFromDType(a,n.sizeFromShape(o));for(let t=0;t<i;++t){const a=n.indexToLoc(t,s,u),o=new Array(a.length);for(let e=0;e<o.length;e++)o[e]=a[r[e]];c[n.locToIndex(o,s,l)]=e[t]}return c},uniqueImpl:function(e,t,a,r){const o=n.parseAxisParam(t,a)[0],s=[1,a[0],1];for(let e=0;e<o;e++)s[0]*=a[e];s[1]=a[o];for(let e=o+1;e<a.length;e++)s[2]*=a[e];const i={},l=new Int32Array(a[o]),c=new u(s,r,e),d=[],p=1===s[0]&&1===s[2];for(let n=0;n<a[o];n++){let t;if(p)t=e[n].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let a=0;a<s[2];a++)e.push(c.get(t,n,a));t=e.join(",")}if(void 0!==i[t])l[n]=i[t];else{const e=Object.keys(i).length;i[t]=e,l[n]=e,d.push(n)}}const h=s.slice();h[1]=Object.keys(i).length;const f=new u(h,r);d.forEach(((e,n)=>{for(let t=0;t<s[0];t++)for(let a=0;a<s[2];a++)f.set(c.get(t,e,a),t,n,a)}));const x=a.slice();return x[o]=h[1],{outputValues:f.values,outputShape:x,indices:l}}};const{addImpl:Jr,bincountImpl:eo,bincountReduceImpl:no,ceilImpl:to,concatImpl:ao,equalImpl:ro,expImpl:oo,expm1Impl:so,floorImpl:io,gatherNdImpl:uo,gatherV2Impl:lo,greaterImpl:co,greaterEqualImpl:po,lessImpl:ho,lessEqualImpl:fo,linSpaceImpl:xo,logImpl:mo,maxImpl:go,maximumImpl:bo,minimumImpl:vo,multiplyImpl:Co,negImpl:$o,notEqualImpl:Io,prodImpl:yo,rangeImpl:wo,rsqrtImpl:So,sigmoidImpl:Ro,simpleAbsImpl:ko,sliceImpl:To,sparseFillEmptyRowsImpl:Eo,sparseReshapeImpl:No,sparseSegmentReductionImpl:Ao,sqrtImpl:Fo,stridedSliceImpl:Oo,stringNGramsImpl:_o,stringSplitImpl:Do,stringToHashBucketFastImpl:Lo,subImpl:Po,tileImpl:Bo,topKImpl:Uo,transposeImpl:Vo,uniqueImpl:Wo}=Zr;function Mo(e,n){return["x","y","z","w","u","v"].slice(0,n).map((n=>`${e}.${n}`))}function Go(e,n){return 1===n?[e]:Mo(e,n)}class zo{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=qa(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Go("rc",this.rank),n=Ga(this.rank),t=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${t}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${r}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const n=[];for(let t=0;t<=1;t++)for(let a=0;a<=1;a++){let r=`${0===t?"r":"rp1"}, ${0===a?"c":"cp1"}`;for(let n=2;n<this.rank;n++)r=`${e[e.length-1-n]},`+r;n.push(r)}return n}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let t=this.rank-2;t<this.rank;t++)n+=`${e[t]} >= ${this.enableShapeUniforms?`outShape[${t}]`:this.outputShape[t]}`,t<this.rank-1&&(n+="||");return n}getSetup(e){if(1===this.rank)return"";const n=e.slice(-2),t=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${n[0]};\n      int c = ${n[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${t};\n      bool rEdge = rp1 >= ${a};\n    `}getOutput(e){const n=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${n[0]}),\n            cEdge ? 0. : getA(${n[1]}),\n            rEdge ? 0. : getA(${n[2]}),\n            rEdge || cEdge ? 0. : getA(${n[3]})`}}class Xo{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length);let t="";for(let e=0;e<4;e++){let n="thisRC = rc;";e%2==1&&(n+="thisRC.z += 1;"),e>1&&(n+="thisRC.y += 1;"),t+=`\n        ${n}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var a,r;this.userCode=`\n      ${a=n,r=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${r?Ea(["r","c","d"],"inputShape"):ka(["r","c","d"],a)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Na(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${t}\n\n        setOutput(result);\n      }\n    `}}class Ho{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,n,t){const a=Ko(n,t),r=qo(e,a,t);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=jo(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,t);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[r].shift();return this.usedTextures[r].push(e),e}let s;return a===Tt.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===Tt.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===Tt.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===Tt.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===Tt.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),s}releaseTexture(e,n,a,r){if(null==this.freeTextures)return;const o=Ko(a,r),s=qo(n,o,r);s in this.freeTextures||(this.freeTextures[s]=[]);const i=jo(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=t().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[s],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function jo(e,n,t,a,r){const o=function(e,n){switch(e){case Tt.PACKED_2X2_FLOAT32:return pr(n);case Tt.PACKED_2X2_FLOAT16:return fr(n);case Tt.UNPACKED_FLOAT32:return sr(n);case Tt.UNPACKED_FLOAT16:return ur(n);case Tt.PACKED_4X1_UNSIGNED_BYTE:return cr(n);default:throw new Error(`Unknown physical texture type ${e}`)}}(n,a);let s;if(r){const[n,t]=At(e[0],e[1]);s=n*t}else{const[n,t]=Et(e[0],e[1]);s=n*t}return s*function(e,n){const t=e;if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===e.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(t,o)}function Ko(e,n){if(e===kt.UPLOAD)return Tt.PACKED_2X2_FLOAT32;if(e===kt.RENDER||null==e)return function(e){return t().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?Tt.PACKED_2X2_FLOAT32:Tt.UNPACKED_FLOAT32:e?Tt.PACKED_2X2_FLOAT16:Tt.UNPACKED_FLOAT16}(n);if(e===kt.DOWNLOAD||e===kt.PIXELS)return Tt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function qo(e,n,t){return`${e[0]}_${e[1]}_${n}_${t}`}class Yo{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${n}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Qo="return x;";class Zo{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${n}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Jo{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length);const n=e.length,t=Go("rc",n),a=Ga(n),r=function(e,n){if(1===e)return"rc";let t="";for(let a=0;a<e;a++)t+=n[a],a<e-1&&(t+=",");return t}(n,t),o=t.slice(-2),s=n<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${s}));\n      }\n    `}}const es=l.whereImpl,ns={};const ts=t().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class as extends c{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!t().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(null!=e){if(e instanceof Sr)n=e;else{const a=St(t().getNumber("WEBGL_VERSION"),e);n=new Sr(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=St(t().getNumber("WEBGL_VERSION"));n=new Sr(e),this.binaryCache=((a=t().getNumber("WEBGL_VERSION"))in ns||(ns[a]={}),ns[a]),this.gpgpuCreatedLocally=!0}var a;this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Ho(this.gpgpu),this.numMBBeforeWarning=null==t().global.screen?1024:t().global.screen.height*t().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new d(this,p())}nextDataId(){return as.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,n,a){if((t().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||t().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===a&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:e,usage:kt.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,n,a,r,o){if(t().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:a,dtype:r,values:n,usage:kt.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:a,dtype:o,complexTensorInfos:s,slice:i,shape:u,isPacked:l}=t;if(null!=i){let n;n=l?new Zo(u,Qo):new Yo(u,Qo);const t=this.runWebGLProgram(n,[{dataId:e,shape:u,dtype:o}],o),a=this.readSync(t.dataId);return this.disposeIntermediateTensorInfo(t),a}if(null!=a)return this.convertAndCacheOnCPU(e);if("string"===o)return a;const c=null!=this.activeTimers;let d,p;if(c&&(d=n.now()),"complex64"===o){const e=this.readSync(s.real.dataId),n=this.readSync(s.imag.dataId);p=r.mergeRealAndImagArrays(e,n)}else p=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=n.now()-d),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const n=this.pendingRead.get(e);return new Promise((e=>n.push(e)))}const a=this.texData.get(e),{values:o,shape:s,slice:i,dtype:u,complexTensorInfos:l,isPacked:c}=a;if(null!=i){let n;n=c?new Zo(s,Qo):new Yo(s,Qo);const t=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:u}],u),a=this.read(t.dataId);return this.disposeIntermediateTensorInfo(t),a}if(null!=o)return this.convertAndCacheOnCPU(e);if(t().getBool("DEBUG")&&!t().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===t().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d,h,f=null;if("complex64"!==u&&t().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const n=this.texData.get(d.dataId);f=this.gpgpu.createBufferFromTexture(n.texture.texture,...Nt(s))}if(this.pendingRead.set(e,[]),"complex64"!==u&&await this.gpgpu.createAndWaitForFence(),"complex64"===u){const e=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),n=e[0],t=e[1];h=r.mergeRealAndImagArrays(n,t)}else if(null==f)h=this.getValuesFromTexture(e);else{const e=n.sizeFromShape(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(f,e)}if(null!=d&&this.disposeIntermediateTensorInfo(d),null!=f){const e=this.gpgpu.gl;Ot(e,(()=>e.deleteBuffer(f)))}const x=this.convertAndCacheOnCPU(e,h),m=this.pendingRead.get(e);return this.pendingRead.delete(e),m.forEach((e=>e(x))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&p().removeDataId(e,this),this.pendingDeletes--),x}readToGPU(e,n={}){const t=this.texData.get(e),{values:a,shape:r,slice:o,dtype:s,isPacked:i,texture:u}=t;if("complex64"===s)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let t;t=i?new Zo(r,Qo):new Yo(r,Qo);const a=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),o=this.readToGPU(a,n);return this.disposeIntermediateTensorInfo(a),o}if(null==u)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,n.customTexShape),c=p().makeTensorFromDataId(l.dataId,l.shape,l.dtype),d=this.texData.get(l.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);let a=t;if("string"===e.dtype)try{a=t.map((e=>n.decodeString(e)))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return o(e.shape,e.dtype,a)}checkNumericalProblems(e){if(null!=e)for(let n=0;n<e.length;n++){const a=e[n];if(!_t(a)){if(t().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${a} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:a,dtype:r,isPacked:o}=this.texData.get(e),s=n.sizeFromShape(a);if(t().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),t=this.texData.get(n.dataId),r=this.gpgpu.downloadMatrixFromPackedTexture(t.texture.texture,...Nt(a)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),r}const i=t().getBool("WEBGL_PACK")&&!0===o,u=i?ua(a):a,l=i?new Ja(u):new Za(u),c=this.runWebGLProgram(l,[{shape:u,dtype:r,dataId:e}],"float32"),d=this.texData.get(c.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),p}timerAvailable(){return t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const a=this.activeTimers,r=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=r,o=!0):this.activeTimers.push(r),this.activeTimers=r,e();const s=n.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=n.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=a,o&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);u.kernelMs=n.sum(e),u.getExtraProfileInfo=()=>e.map(((e,n)=>({name:i[n],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:n.now(),endMs:null}}endTimer(e){return t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=n.now(),e)}async getQueryTime(e){if(t().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:t}=this.texData.get(e);return null!=t&&(this.disposeData(t.real.dataId,n),this.disposeData(t.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:t,texShape:a,usage:r,isPacked:o,slice:s}=this.texData.get(e),i=s&&s.origDataId||e,u=this.dataRefCount.get(i);u>1?this.dataRefCount.set(i,u-1):(this.dataRefCount.delete(i),null!=n&&(this.numBytesInGPU-=this.computeBytes(a,t),this.textureManager.releaseTexture(n,a,r,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,a=ts){return t().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&n.sizeFromShape(e.shape)<a))}getGPGPUContext(){return this.gpgpu}where(e){r.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return es(e.shape,n)}packedUnaryOp(e,n,t){const a=new Zo(e.shape,n),r=this.compileAndRun(a,[e],t);return p().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const n=ko(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,n)}if(t().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,"return abs(x);",e.dtype);const n=new Yo(e.shape,"return abs(x);"),a=this.compileAndRun(n,[e]);return p().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}makeTensorInfo(e,t,a){let r;if("string"===t&&null!=a&&a.length>0&&n.isString(a[0])){const o=a.map((e=>n.encodeString(e)));r=this.write(o,e,t)}else r=this.write(a,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,n,t){const{dataId:a}=this.makeTensorInfo(e,n,t);return p().makeTensorFromDataId(a,e,n,this)}unpackTensor(e){const n=new Jo(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new zo(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const t=[sa(e.shape),...ia(e.shape)],a={dtype:e.dtype,shape:t,dataId:e.dataId},r=[sa(n),...ia(n)],o=new Xo(r,t),s=[t],i=this.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:i.dataId,shape:n,dtype:i.dtype}}decode(e,t){const a=this.texData.get(e),{isPacked:r,shape:o,dtype:s}=a;if(null!=t){const e=n.sizeFromShape(o),a=t[0]*t[1]*4;n.assert(e<=a,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=ua(o);let u;u=r?new Qa(i):new Ya(i);const l=[null!=t?t:Nt(i)];return{dtype:s,shape:o,dataId:this.runWebGLProgram(u,[{shape:i,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,a,o,s,i=!1,u){const l=this.makeTensorInfo(e.outputShape,o),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Rt.DENSE){const n=null!=u?u:Nt(e.outputShape);c.texShape=n.map((e=>2*e))}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===n.sizeFromShape(l.shape))return c.values=n.getTypedArrayFromDType(l.dtype,0),l;const d=[],p=a.map((a=>{if("complex64"===a.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let r=this.texData.get(a.dataId);if(null==r.texture){if(!e.packedInputs&&n.sizeFromShape(a.shape)<=t().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:a.shape,texData:null,isUniform:!0,uniformValues:r.values};e.packedInputs&&(r.isPacked=!0,r.shape=a.shape)}if(this.uploadToGPU(a.dataId),!!r.isPacked!=!!e.packedInputs)a=r.isPacked?this.unpackTensor(a):this.packTensor(a),d.push(a),r=this.texData.get(a.dataId);else if(r.isPacked&&!da(r.shape,a.shape)){const e=a,n=a.shape;a.shape=r.shape,a=this.packedReshape(a,n),d.push(a),r=this.texData.get(a.dataId),e.shape=n}return{shape:a.shape,texData:r,isUniform:!1}}));this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:c,isUniform:!1},f=function(e,a,o){let s="";a.concat(o).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const i=t.texData.texShape,{useSqueezeShape:u,uniformShape:l,keptDims:c}=za(e.packedInputs,t.shape,i);let d="",p="",h="";if(1===l.length&&e.packedInputs){const e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];d=`${e[0]>1}_${e[1]>1}`}else if(2!==l.length||e.packedInputs){if(l.length>2&&!e.packedInputs){const e=n.computeStrides(l);h=`${e[0]===i[1]}_${e[e.length-1]===i[1]}`}}else p=`${l[0]>1}_${l[1]>1}`;const f=t.shape.length,x=2===l.length&&n.arraysEqual(t.shape,i),m=1===n.sizeFromShape(t.shape),g=r.getBroadcastDims(t.shape,o.shape),b=!e.packedInputs&&f===o.shape.length&&n.arraysEqual(i,o.texData.texShape),v=e.packedInputs||l.length>2?"":`${i[0]>1}_${i[1]>1}`;s+=`${f}_${b}_${u?c:""}_${l.length}_${m}_${g}_${x}_${d}_${p}_${h}_${v}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;s+=`${t.shape}_${e}_${a}`}}));const i=e.userCode;let u=e.constructor.name;return u+="_"+s+"_"+i+`${t().getNumber("WEBGL_VERSION")}`,u}(e,p,h),x=this.getAndSaveBinary(f,(()=>function(e,n,a,r){const o=a.map(((e,t)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:n.variableNames[t],shapeInfo:a}})),s=o.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=Oa(o,i,n),l=Bt(e.gl,u),c=e.createProgram(l);return t().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:n,fragmentShader:l,source:u,webGLProgram:c,inShapeInfos:s,outShapeInfo:i},ja(e,n,c))}(this.gpgpu,e,p,h))),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),t().get("ENGINE_COMPILE_ONLY")||function(e,a,r,o,s){a.program.enableShapeUniforms||(Ka(a.inShapeInfos,r),Ka([a.outShapeInfo],[o]));const i=o.texData.texture,u=o.texData.texShape;o.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,u[0],u[1]):e.setOutputMatrixTexture(i.texture,u[0],u[1]),e.setProgram(a.webGLProgram),1===t().getNumber("WEBGL_VERSION")&&null!==a.infLoc&&e.gl.uniform1f(a.infLoc,1/0),null!==a.nanLoc&&e.gl.uniform1f(a.nanLoc,NaN),r.forEach(((t,r)=>{const o=a.program.variableNames[r],s=a.uniformLocations[o],i=a.uniformLocations[`offset${o}`],u=a.inShapesLocations[`${o}Shape`],l=a.inTexShapesLocations[`${o}TexShape`];if(u){const{uniformShape:n}=za(a.program.packedInputs,t.shape,t.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(u,new Int32Array(n));break;case 2:e.gl.uniform2iv(u,new Int32Array(n));break;case 3:e.gl.uniform3iv(u,new Int32Array(n));break;case 4:e.gl.uniform4iv(u,new Int32Array(n))}}if(l&&e.gl.uniform2i(l,t.texData.texShape[0],t.texData.texShape[1]),null!=s)if(t.isUniform)if(n.sizeFromShape(t.shape)<2)e.gl.uniform1f(s,t.uniformValues[0]);else{let n=t.uniformValues;n instanceof Float32Array||(n=new Float32Array(n)),e.gl.uniform1fv(s,n)}else null!=t.texData.slice&&null!=i&&e.gl.uniform1i(i,t.texData.slice.flatOffset),e.setInputMatrixTexture(t.texData.texture.texture,s,r)}));const l=a.outShapeLocation;if(l)switch(o.shape.length){case 1:e.gl.uniform1iv(l,new Int32Array(o.shape));break;case 2:e.gl.uniform2iv(l,new Int32Array(o.shape));break;case 3:e.gl.uniform3iv(l,new Int32Array(o.shape));break;case 4:e.gl.uniform4iv(l,new Int32Array(o.shape))}if(a.outShapeStridesLocation){const t=n.computeStrides(o.shape);switch(o.shape.length){case 2:e.gl.uniform1iv(a.outShapeStridesLocation,new Int32Array(t));break;case 3:e.gl.uniform2iv(a.outShapeStridesLocation,new Int32Array(t));break;case 4:e.gl.uniform3iv(a.outShapeStridesLocation,new Int32Array(t))}}a.outTexShapeLocation&&e.gl.uniform2i(a.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),a.program.customUniforms&&s&&a.program.customUniforms.forEach(((n,t)=>{const r=a.customUniformLocations[t],o=s[t];if("float"===n.type)e.gl.uniform1fv(r,o);else if("vec2"===n.type)e.gl.uniform2fv(r,o);else if("vec3"===n.type)e.gl.uniform3fv(r,o);else if("vec4"===n.type)e.gl.uniform4fv(r,o);else if("int"===n.type)e.gl.uniform1iv(r,o);else if("ivec2"===n.type)e.gl.uniform2iv(r,o);else if("ivec3"===n.type)e.gl.uniform3iv(r,o);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,o)}})),e.executeProgram()}(this.gpgpu,x,p,h,s),d.forEach((e=>this.disposeIntermediateTensorInfo(e))),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const b=t().get("WEBGL_FLUSH_THRESHOLD");if(b>0){const e=n.now();e-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!t().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===i){const e=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),e}return l}compileAndRun(e,n,t,a,r=!1){t=t||n[0].dtype;return this.runWebGLProgram(e,n,t,a,r)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!t().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=h((()=>{if(!t().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=t().getBool("DEBUG");t().set("DEBUG",!1);const n=this.abs(f(1e-8)).dataSync()[0];if(t().set("DEBUG",e),n>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const a=this.texData.get(e),{shape:r,dtype:o,values:s,texture:i,usage:u,isPacked:l}=a;if(null!=i)return;const c=null!=this.activeTimers;let d;c&&(d=n.now());let p=a.texShape;if(null==p&&(p=la(r,l),a.texShape=p),null!=s){const e=ua(r);let i,u=p[1],h=p[0];const f=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!l&&f||([u,h]=At(p[0],p[1])),i=l?new nr(e,f):new er(e,f);const x=f?[h,u]:p,m=this.makeTensorInfo(x,o),g=this.texData.get(m.dataId);g.usage=f?kt.PIXELS:kt.UPLOAD,g.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId),u,h,s);const b=[[h,u]],v=!0,C=this.runWebGLProgram(i,[m],o,b,v),$=this.texData.get(C.dataId);a.texShape=$.texShape,a.isPacked=$.isPacked,a.usage=$.usage,t().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(a.texture=$.texture,a.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(m),c&&(this.uploadWaitMs+=n.now()-d)}else{const e=this.acquireTexture(p,u,o,l);a.texture=e}}convertAndCacheOnCPU(e,n){const t=this.texData.get(e),{dtype:a}=t;return this.releaseGPUData(e),null!=n&&(t.values=function(e,n){if("float32"===n||"complex64"===n)return e;if("int32"===n||"bool"===n){const t="int32"===n?new Int32Array(e.length):new Uint8Array(e.length);for(let n=0;n<t.length;++n)t[n]=Math.round(e[n]);return t}throw new Error(`Unknown dtype ${n}`)}(n,a)),t.values}acquireTexture(e,n,t,a){if(this.numBytesInGPU+=this.computeBytes(e,t),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,a)}computeBytes(e,t){return e[0]*e[1]*n.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}for(const[,n]of Object.entries(this.binaryCache)){const t=new Promise((e=>{try{this.checkCompletion_(n),e(!0)}catch(e){throw e}}));e.push(t)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await x(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw Vt(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:n,customUniformLocations:t,infLoc:a,nanLoc:r,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:l}=ja(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=n,e.customUniformLocations=t,e.infLoc=a,e.nanLoc=r,e.inShapesLocations=o,e.inTexShapesLocations=s,e.outShapeLocation=i,e.outShapeStridesLocation=u,e.outTexShapeLocation=l}}}as.nextDataId=0;const rs="3.15.0";function os(){t().set("WEBGL_FORCE_F16_TEXTURES",!0)}a.isBrowser()&&m("webgl",(()=>new as),2);const ss={forceHalfFloat:os};class is{constructor(e,n,t){this.variableNames=["A","B"],this.outputShape=r.assertAndGetBroadcastShape(n,t),this.enableShapeUniforms=qa(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class us{constructor(e,t,a,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r.assertAndGetBroadcastShape(t,a);const s=this.outputShape.length;this.enableShapeUniforms=qa(s);let i="";if(o)if(0===s||1===n.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(i=`\n          ${Ga(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Go("coords",s);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function ls(e){const{inputs:n,backend:t}=e,{x:a}=n;return t.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const cs={kernelName:g,backendName:"webgl",kernelFunc:ls};function ds(e){const{inputs:n,backend:t}=e,{real:a,imag:r}=n,o=t.makeTensorInfo(a.shape,"complex64"),s=t.texData.get(o.dataId),i=ls({inputs:{x:a},backend:t}),u=ls({inputs:{x:r},backend:t});return s.complexTensorInfos={real:i,imag:u},o}const ps={kernelName:b,backendName:"webgl",kernelFunc:ds},hs="return (a < 0.) ? b * a : a;",fs="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const xs={kernelName:v,backendName:"webgl",kernelFunc:function(e){const{inputs:a,backend:r,attrs:o}=e,{x:s}=a,{alpha:i}=o,u=r.makeTensorInfo([],"float32",n.createScalarValue(i,"float32")),l=t().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new us(fs,s.shape,u.shape):new is(hs,s.shape,u.shape),c=r.runWebGLProgram(l,[s,u],"float32");return r.disposeIntermediateTensorInfo(u),c}},ms="return (a < 0.) ? b * a : a;",gs="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const bs={kernelName:C,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r,alpha:o}=n,s=t().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new us(gs,r.shape,o.shape):new is(ms,r.shape,o.shape);return a.runWebGLProgram(s,[r,o],"float32")}};function vs({opSnippet:e,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}){return({inputs:o,backend:s})=>{const{x:i}=o,u=s,l=r||i.dtype;if(u.shouldExecuteOnCPU([i])&&null!=a){const e=u.texData.get(i.dataId),n=a(e.values,l);return u.makeTensorInfo(i.shape,l,n)}let c;return c=t().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Zo(i.shape,n):new Yo(i.shape,e),u.runWebGLProgram(c,[i],l)}}function Cs({opSnippet:e,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:o=!1,cpuKernelImpl:i,dtype:u}){return({inputs:l,backend:c})=>{const{a:d,b:p}=l,h=c;if(o&&"complex64"===d.dtype){const n=h.texData.get(d.dataId),t=h.texData.get(p.dataId),[a,r]=[[n.complexTensorInfos.real,t.complexTensorInfos.real],[n.complexTensorInfos.imag,t.complexTensorInfos.imag]].map((n=>{const[t,a]=n,r={dataId:t.dataId,dtype:t.dtype,shape:d.shape},o={dataId:a.dataId,dtype:a.dtype,shape:p.shape},i=new is(e,d.shape,p.shape);return h.runWebGLProgram(i,[r,o],s(t.dtype,a.dtype))})),o=ds({inputs:{real:a,imag:r},backend:h});return h.disposeIntermediateTensorInfo(a),h.disposeIntermediateTensorInfo(r),o}const f=u||s(d.dtype,p.dtype);if(("string"===d.dtype||"string"===p.dtype||h.shouldExecuteOnCPU([d,p]))&&null!=i){const e=h.texData.get(d.dataId).values,n=h.texData.get(p.dataId).values,t="string"===d.dtype?r.fromUint8ToStringArray(e):e,a="string"===d.dtype?r.fromUint8ToStringArray(n):n,[o,s]=i(d.shape,p.shape,t,a,f),u=h.makeTensorInfo(s,f);return h.texData.get(u.dataId).values=o,u}let x;return x=t().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new us(n,d.shape,p.shape,a):new is(e,d.shape,p.shape),h.runWebGLProgram(x,[d,p],f)}}function $s(e,n=!1){if("linear"===e)return"return x;";if("relu"===e)return n?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return n?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return n?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return n?gs:ms;if("leakyrelu"===e)return n?fs:hs;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Is{constructor(e,n,t,a=!1,r=!1,o=!1,s=null,i=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=qa(this.outputShape.length);const l=a?e[1]:e[2],c=Math.ceil(l/2),d=a?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",h=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",m="";s&&(x=i?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,m="result = activation(result);");const g=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<n[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:n[0]<e[0]&&(v=`int(min(float(rc.x), ${n[0]-1}.))`),this.userCode=`\n      ${x}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${b};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}const ys="return areal * breal - aimag * bimag;",ws="return areal * bimag + aimag * breal;";class Ss{constructor(e,n,t){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=r.assertAndGetBroadcastShape(n,t),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Rs="return a * b;";function ks(e){const{inputs:n,backend:a}=e,{a:o,b:s}=n,i=r.upcastType(o.dtype,s.dtype);if("complex64"===o.dtype){const e=a.texData.get(o.dataId),n=a.texData.get(s.dataId),t=new Ss(ys,o.shape,s.shape),r=new Ss(ws,o.shape,s.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:o.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:s.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:s.shape}],u=a.runWebGLProgram(t,i,"float32"),l=a.runWebGLProgram(r,i,"float32"),c=ds({inputs:{real:u,imag:l},backend:a});return a.disposeIntermediateTensorInfo(u),a.disposeIntermediateTensorInfo(l),c}if(a.shouldExecuteOnCPU([o,s])){const e=a.texData.get(o.dataId),n=a.texData.get(s.dataId),[t,r]=Co(o.shape,s.shape,e.values,n.values,i),u=a.makeTensorInfo(r,i);return a.texData.get(u.dataId).values=t,u}let u;return u=t().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new us(Rs,o.shape,s.shape):new is(Rs,o.shape,s.shape),a.runWebGLProgram(u,[o,s],i)}const Ts={kernelName:$,backendName:"webgl",kernelFunc:ks};function Es(e){const{inputs:t,backend:a,attrs:r}=e,{x:o}=t,{shape:s}=r,i=a,u=n.sizeFromShape(o.shape),l=n.inferFromImplicitShape(s,u),c=n.sizeFromShape(l);n.assert(u===c,(()=>`The new shape (${l}) has ${c} elements and the old shape (${o.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`));const d=i.texData.get(o.dataId);return!d.isPacked||da(o.shape,l)||null!==d.texture&&da(d.shape,l)?(i.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype}):function(e,n,t){const a=[sa(e.shape),...ia(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[sa(n),...ia(n)],s=new Xo(o,a),i=[a],u=t.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:u.dataId,shape:n,dtype:u.dtype}}(o,l,i)}const Ns={kernelName:I,backendName:"webgl",kernelFunc:Es};class As{constructor(e,t){this.variableNames=["x"];const{windowSize:a,batchSize:r,inSize:o,outSize:s}=e;this.outputShape=[r,s];const i=4*Math.floor(a/4),u=a%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${n.isInt(e)?e.toPrecision(2):e}, ones);`}let c="";o%a>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Fs{constructor(e,n){this.variableNames=["x"];const{windowSize:t,batchSize:a,inSize:r,outSize:o}=e;this.outputShape=[a,o];let s="0.0",i="";"prod"===n?s="1.0":"min"===n?(s="1.0 / 1e-20",i="min"):"max"===n&&(s="-1.0 / 1e-20",i="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===n?u="sumValue":"prod"===n?u="prodValue":"all"===n?u="allValue":"any"===n&&(u="anyValue");const l=4*Math.floor(t/4),c=t%4;let d=`\n      if (${"sum"===n}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===n}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${"min"===n} || ${"max"===n}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===n?(s="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===n&&(s="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";r%t>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${t};\n\n        vec4 minMaxValue = vec4(${s});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${u});\n      }\n    `}}function Os(e,n,t,a){const o=function(e){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const t=n.length?n[n.length-1].outSize:e[1],a=r.computeOptimalWindowSize(t);n.push({inSize:t,windowSize:a,outSize:Math.ceil(t/a)})}return n}(e.shape);let s=e;for(let r=0;r<o.length;r++){const{inSize:i,windowSize:u,outSize:l}=o[r];let c,d;c="mean"===t?0===r?new As({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},i):new As({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l}):new Fs({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},t),d=s,s=a.runWebGLProgram(c,[s],n),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return s}class _s{constructor(e,n){this.variableNames=["A"];const t=new Array(e.length);for(let a=0;a<t.length;a++)t[a]=e[n[a]];this.outputShape=t,this.rank=t.length;const a=Ga(this.rank),r=function(e){const n=e.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(n);for(let n=0;n<e.length;n++)a[e[n]]=t[n];return a.join()}(n);this.userCode=`\n    void main() {\n      ${a} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class Ds{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const t=new Array(e.length);for(let a=0;a<t.length;a++)t[a]=e[n[a]];if(this.outputShape=t,this.rank=t.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const a=Ga(this.rank),r=Mo("rc",this.rank),o=new Array(this.rank);for(let e=0;e<n.length;e++)o[n[e]]=r[e];const s=`vec2(${o.slice(-2).join()})`,i=`++${r[this.rank-1]} < ${t[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Ls(e,n,a){const r=t().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ds(e.shape,n):new _s(e.shape,n);return a.runWebGLProgram(r,[e],e.dtype)}function Ps(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{axis:i,keepDims:u}=o;return function(e,t,a,o){const s=t,i=e.shape.length,u=n.parseAxisParam(s,e.shape);let l=u;const c=r.getAxesPermutation(l,i),d=null!=c;let p=e;d&&(p=Ls(e,c,o),l=r.getInnerMostAxes(l.length,i)),r.assertAxesAreInnerMostDims("sum",l,i);const[h,f]=r.computeOutAndReduceShapes(p.shape,l);let x=h;a&&(x=r.expandShapeToKeepDim(h,u));const m=n.sizeFromShape(f),g=Es({inputs:{x:p},attrs:{shape:[n.sizeFromShape(e.shape)/m,m]},backend:o}),b=Os(g,y(e.dtype),"sum",o),v=Es({inputs:{x:b},attrs:{shape:x},backend:o});return o.disposeIntermediateTensorInfo(g),o.disposeIntermediateTensorInfo(b),d&&o.disposeIntermediateTensorInfo(p),v}(s,i,u,a)}const Bs={kernelName:w,backendName:"webgl",kernelFunc:Ps};function Us(e){const{inputs:n,backend:t,attrs:a}=e,{x:r}=n,{perm:o}=a,s=t,i=r.shape.length,u=new Array(i);for(let e=0;e<u.length;e++)u[e]=r.shape[o[e]];let l;if(s.shouldExecuteOnCPU([r])){const e=s.texData.get(r.dataId).values,n=Vo(e,r.shape,r.dtype,o,u);l=s.makeTensorInfo(u,r.dtype);s.texData.get(l.dataId).values=n}else l=Ls(r,o,s);return l}const Vs={kernelName:S,backendName:"webgl",kernelFunc:Us};function Ws({a:e,b:t,transposeA:a,transposeB:r,backend:o,bias:i=null,preluActivationWeights:u=null,leakyreluAlpha:l=0,activation:c=null}){const d=e.shape.length,p=t.shape.length,h=a?e.shape[d-2]:e.shape[d-1],f=r?t.shape[p-1]:t.shape[p-2],x=a?e.shape[d-1]:e.shape[d-2],m=r?t.shape[p-2]:t.shape[p-1],g=e.shape.slice(0,-2),b=t.shape.slice(0,-2),v=n.sizeFromShape(g),C=n.sizeFromShape(b),$=R.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([x,m]);n.assert(h===f,(()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${a} and transposeB=${r} must match.`));const I=a?[v,h,x]:[v,x,h],y=r?[C,m,f]:[C,f,m],w=Es({inputs:{x:e},backend:o,attrs:{shape:I}}),S=Es({inputs:{x:t},backend:o,attrs:{shape:y}}),k=[w,S],T=Math.max(v,C),E=a?w.shape[1]:w.shape[2],N=null!=i,A=null!=u,F="leakyrelu"===c,O=null!=c?$s(c,!0):null;let _;if((1===x||1===m)&&E>1e3&&!1===(N||A||F||null!=O)){let e=w,n=S;a&&(e=Us({inputs:{x:w},backend:o,attrs:{perm:[0,2,1]}}),k.push(e)),r&&(n=Us({inputs:{x:S},backend:o,attrs:{perm:[0,2,1]}}),k.push(n));const t=1===m;let s=e;1!==m&&(s=Es({inputs:{x:e},backend:o,attrs:{shape:[T,E,1]}}),k.push(s));const i=1===m?2:1;let u=n;t&&(u=Es({inputs:{x:n},backend:o,attrs:{shape:[T,1,E]}}),k.push(u));const l=ks({inputs:{a:s,b:u},backend:o});_=Ps({inputs:{x:l},backend:o,attrs:{axis:i,keepDims:!0}}),k.push(l)}else{const c=s(e.dtype,t.dtype),d=new Is(I,y,[T,x,m],a,r,N,O,A,F),p=[w,S];if(null!=i&&p.push(i),A&&p.push(u),F){const e=o.makeTensorInfo([],"float32",n.createScalarValue(l,"float32"));p.push(e),k.push(e)}_=o.runWebGLProgram(d,p,c)}const D=Es({inputs:{x:_},backend:o,attrs:{shape:$}});k.push(_);for(const e of k)o.disposeIntermediateTensorInfo(e);return D}const Ms={kernelName:k,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{a:r,b:o,bias:s,preluActivationWeights:i}=n,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:d}=a;return Ws({a:r,b:o,transposeA:u,transposeB:l,backend:t,bias:s,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}},Gs="return abs(x);";const zs={kernelName:T,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r}=n;if(a.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=a.texData.get(r.dataId),n=ko(e.values);return a.makeTensorInfo(r.shape,r.dtype,n)}let o;return o=t().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Zo(r.shape,Gs):new Yo(r.shape,Gs),a.runWebGLProgram(o,[r],r.dtype)}},Xs={kernelName:E,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"})},Hs={kernelName:N,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"})},js="return a + b;",Ks={kernelName:A,backendName:"webgl",kernelFunc:Cs({opSnippet:js,packedOpSnippet:js,supportsComplex:!0,cpuKernelImpl:Jr})};class qs{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map(((e,n)=>`T${n}`));const t=[];this.variableNames.forEach((e=>{t.push(`float v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${t.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}class Ys{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map(((e,n)=>`T${n}`));const t=[];this.variableNames.forEach((e=>{t.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const a=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${t.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}const Qs={kernelName:F,backendName:"webgl",kernelFunc:function e(n){const{inputs:a,backend:r}=n,o=a;if(1===o.length)return ls({inputs:{x:o[0]},backend:r});if(o.length>t().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(o.length/2),t=e({inputs:o.slice(0,n),backend:r}),a=e({inputs:o.slice(n),backend:r});return e({inputs:[t,a],backend:r})}const i=o.map((e=>e.dtype)).reduce(((e,n)=>s(e,n))),u=o.map((e=>e.shape)),l=t().getBool("WEBGL_PACK")?new Ys(o[0].shape,u):new qs(o[0].shape,u);return r.runWebGLProgram(l,o,i)}};const Zs={kernelName:O,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{axis:i,keepDims:u}=o,l=s.shape.length,c=n.parseAxisParam(i,s.shape);let d=c;const p=r.getAxesPermutation(d,l);let h=s;null!=p&&(h=Us({inputs:{x:s},backend:a,attrs:{perm:p}}),d=r.getInnerMostAxes(d.length,l)),r.assertAxesAreInnerMostDims("all",d,l);const[f,x]=r.computeOutAndReduceShapes(h.shape,d),m=Es({inputs:{x:h},backend:a,attrs:{shape:[-1,n.sizeFromShape(x)]}}),g=Os(m,m.dtype,"all",a);let b;if(u){b=Es({inputs:{x:g},backend:a,attrs:{shape:r.expandShapeToKeepDim(f,c)}})}else b=Es({inputs:{x:g},backend:a,attrs:{shape:f}});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),null!=p&&a.disposeIntermediateTensorInfo(h),b}};const Js={kernelName:_,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{axis:i,keepDims:u}=o,l=s.shape.length,c=n.parseAxisParam(i,s.shape);let d=c;const p=r.getAxesPermutation(d,l);let h=s;null!=p&&(h=Us({inputs:{x:s},backend:a,attrs:{perm:p}}),d=r.getInnerMostAxes(d.length,l)),r.assertAxesAreInnerMostDims("any",d,l);const[f,x]=r.computeOutAndReduceShapes(h.shape,d),m=Es({inputs:{x:h},backend:a,attrs:{shape:[-1,n.sizeFromShape(x)]}}),g=Os(m,m.dtype,"any",a);let b;if(u){b=Es({inputs:{x:g},backend:a,attrs:{shape:r.expandShapeToKeepDim(f,c)}})}else b=Es({inputs:{x:g},backend:a,attrs:{shape:f}});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),null!=p&&a.disposeIntermediateTensorInfo(h),b}};class ei{constructor(e,n,t){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:o}=e;t||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const s="max"===n?">":"<",i=t?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${i};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${s} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class ni{constructor(e,t,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,n.assert(e.length>2,(()=>`Packed arg${a.charAt(0).toUpperCase()+a.slice(1)} supports only inputs with rank above 2.`));const o=e[e.length-1],s=Math.ceil(o/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,l=Ga(u),c=Go("coords",u);let d,p;if(1===s){p=u+1;const e=Ga(p);d=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else p=u,d=`\n        ${l} sourceLocR = coords;\n        ++${c[u-1]};\n        ${l} sourceLocG = coords;\n        ++${c[u-2]};\n        ${l} sourceLocA = coords;\n        --${c[u-1]};\n        ${l} sourceLocB = coords;\n        --${c[u-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],x=h.map((e=>"int "+e)),m=Go("sourceLocR",p-1).concat("inIdx.r"),g=Go("sourceLocG",p-1).concat("inIdx.g"),b=Go("sourceLocB",p-1).concat("inIdx.b"),v=Go("sourceLocA",p-1).concat("inIdx.a"),C="max"===a?"greaterThan":"lessThan",$=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,I=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,y=r?"":`\n      float getBestIndicesAChannel(${x.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${x.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${y}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${i[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${i[u-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${$}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function ti(e,n,t,a=null){let o=n.shape[0],s=n.shape[1];null!=a&&(o=a.shape[0],s=a.shape[1]);const i=r.computeOptimalWindowSize(s),u={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},l=new ei(u,t,null==a),c=[n];null!=a&&c.push(a);const d=e.runWebGLProgram(l,c,"int32");if(1===d.shape[1])return d;const p=ti(e,n,t,d);return e.disposeIntermediateTensorInfo(d),p}function ai(e,n,t,a=null){const o=null!=a?a.shape:n.shape,s=o[o.length-1],i=r.computeOptimalWindowSize(s),u=new ni(o,i,t,null==a),l=null==a?[n]:[n,a],c=e.runWebGLProgram(u,l,"int32");if(c.shape.length===n.shape.length){const a=ai(e,n,t,c);return e.disposeIntermediateTensorInfo(c),a}return c}function ri(e,a,o,s){const i=[o];if(r.assertAxesAreInnerMostDims("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,a.shape.length),!t().getBool("WEBGL_PACK_REDUCE")||a.shape.length<=2){const t=[],o=e.texData.get(a.dataId);let u=a;null!==o&&o.isPacked&&(u=e.unpackTensor(a),t.push(u));const[l,c]=r.computeOutAndReduceShapes(u.shape,i),d=n.sizeFromShape(c),p=Es({inputs:{x:u},backend:e,attrs:{shape:[-1,d]}});t.push(p);const h=ti(e,p,s);t.push(h);const f=Es({inputs:{x:h},backend:e,attrs:{shape:l}});return t.forEach((n=>e.disposeIntermediateTensorInfo(n))),f}return ai(e,a,s)}const oi={kernelName:D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{axis:i}=o;let u=n.parseAxisParam(i,s.shape);const l=r.getAxesPermutation(u,s.shape.length);let c=s;const d=[];null!=l&&(c=Us({inputs:{x:s},backend:a,attrs:{perm:l}}),d.push(c),u=r.getInnerMostAxes(u.length,c.shape.length)),r.assertAxesAreInnerMostDims("argMax",[u[0]],c.shape.length);const p=ri(a,c,u[0],"max");return d.forEach((e=>a.disposeIntermediateTensorInfo(e))),p}};const si={kernelName:L,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{axis:i}=o;let u=n.parseAxisParam(i,s.shape);const l=r.getAxesPermutation(u,s.shape.length);let c=s;const d=[];null!=l&&(c=Us({inputs:{x:s},backend:a,attrs:{perm:l}}),d.push(c),u=r.getInnerMostAxes(u.length,c.shape.length)),r.assertAxesAreInnerMostDims("argMin",[u[0]],c.shape.length);const p=ri(a,c,u[0],"min");return d.forEach((e=>a.disposeIntermediateTensorInfo(e))),p}},ii={kernelName:P,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"})},ui={kernelName:B,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"})},li={kernelName:U,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"})},ci={kernelName:V,backendName:"webgl",kernelFunc:Cs({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})},di={kernelName:W,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"})};class pi{constructor(e,n,t,a=!1,r=!1){if(this.variableNames=["x"],"avg"===n&&t)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideHeight,i=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===n,x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,m=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let g="0.0";if(f||(g="-1.0 / 1e-20"),t){const n=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${s}, ${i});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${n} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${a?r?x:m:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===n&&(b="avgValue / count");const v=4*Math.floor(o/4),C=o%4,$=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${g};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${g});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${$}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${$}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${$}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${$}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class hi{constructor(e,n,t,a=!1,r=!1){if(this.variableNames=["x"],"avg"===n&&t)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,x=e.padInfo.front,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===n;let v="0.0";if(b||(v="-1.0 / 1e-20"),t){const n=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${s}, ${i}, ${u});\n        const ivec3 pads = ivec3(${x}, ${m}, ${g});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${n} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let C=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===n&&(C="avgValue / count");const $=4*Math.floor(o/4),I=o%4,y=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${s}, ${i}, ${u});\n      const ivec3 pads = ivec3(${x}, ${m}, ${g});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${$}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${y}\n            }\n\n            int xC = xCCorner + ${$};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${y}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${y}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${y}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}const fi={kernelName:M,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t;ya(s,"avgPool");const{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=o;n.assert(r.eitherStridesOrDilationsAreOne(u,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`));const d=r.computePool2DInfo(s.shape,i,u,1,l,c);if(1===d.filterWidth&&1===d.filterHeight&&n.arraysEqual(d.inShape,d.outShape))return ls({inputs:{x:s},backend:a});const p=new pi(d,"avg",!1);return a.runWebGLProgram(p,[s],"float32")}};const xi={kernelName:G,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o}=n,{filterSize:s,strides:i,pad:u,dimRoundingMode:l,dataFormat:c}=a,d=r.computePool3DInfo(o.shape,s,i,[1,1,1],u,l,c),p=new hi(d,"avg",!1);return t.runWebGLProgram(p,[o],"float32")}};class mi{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,t=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=i-1-e.padInfo.top,c=u-1-e.padInfo.left,d=1/(n*t);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n            wR += ${o}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${s}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gi{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,t=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=c-1-e.padInfo.front,f=d-1-e.padInfo.top,x=p-1-e.padInfo.left,m=1/(n*t*a);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${x});\n      const float avgMultiplier = float(${m});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const bi={kernelName:z,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{dy:o,input:s}=n,i=s,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=a,p=r.computePool3DInfo(i.shape,u,l,[1,1,1],c,d),h=new gi(p);return t.runWebGLProgram(h,[o],i.dtype)}};const vi={kernelName:X,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{dy:o,input:s}=n,i=s;ya([o,s],"avgPoolGrad");const{filterSize:u,strides:l,pad:c}=a,d=r.computePool2DInfo(i.shape,u,l,1,c),p=new mi(d);return t.runWebGLProgram(p,[o],i.dtype)}};const Ci={kernelName:H,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{a:r,b:o}=n,{transposeA:s,transposeB:i}=a;return Ws({a:r,b:o,transposeA:s,transposeB:i,backend:t})}};class $i{constructor(e,n,t,a,o,s){this.outputShape=[],this.variableNames=["x","mean","variance"],r.assertAndGetBroadcastShape(e,n),r.assertAndGetBroadcastShape(e,t);let i="0.0";null!=a&&(r.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";null!=o&&(r.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Ii{constructor(e,n,t,a,o,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],r.assertAndGetBroadcastShape(e,n),r.assertAndGetBroadcastShape(e,t);let i="vec4(0.0)";null!=a&&(r.assertAndGetBroadcastShape(e,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=o&&(r.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const yi={kernelName:j,backendName:"webgl",kernelFunc:({inputs:e,backend:a,attrs:r})=>{const{x:o,mean:s,variance:i,offset:u,scale:l}=e;n.assert(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),n.assert(null==u||s.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),n.assert(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=r;null==c&&(c=.001);const d=[o,s,i];let p=null;null!=u&&(p=u.shape,d.push(u));let h=null;null!=l&&(h=l.shape,d.push(l));const f=t().getBool("WEBGL_PACK_NORMALIZATION")?new Ii(o.shape,s.shape,i.shape,p,h,c):new $i(o.shape,s.shape,i.shape,p,h,c);return a.runWebGLProgram(f,d,d[0].dtype)}};class wi{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Ga(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=function(e){if(1===e)return"sourceLoc";if(e<=6)return Si.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let a;a=`\n        ${n} sourceLoc;\n        ${n} coords = getOutputCoords();\n        ${e.map(((e,n)=>`sourceLoc.${Si[n]} = start[${n}] + coords.${Si[n]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${a}\n        setOutput(getSource(${t}));\n      }\n    `}}const Si=["x","y","z","w","u","v"];class Ri{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Ga(this.rank),t=Go("coords",this.rank),a=Go("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${a.slice(-2).join()})`,o=`getChannel(getSource(${a.join()}), ${r})`,s=`\n      result.x = ${o};\n      if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${o};\n        --${a[this.rank-1]};\n      }\n    `,i=1===this.rank?"":`\n      --${t[this.rank-1]};\n      if (++${t[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${o};\n        if (++${t[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${n}(${e.map(((e,n)=>`start[${n}]`)).join()});`:e.map(((e,n)=>`${a[n]} = ${t[n]} + start[${n}];`)).join("\n");this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        ${n} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${s}\n        ${i}\n        setOutput(result);\n      }\n    `}}function ki(e){const{inputs:a,backend:r,attrs:o}=e,{x:s}=a,{begin:u,size:l}=o,[c,d]=i.parseSliceParams(s,u,l);if(i.assertParamsValid(s,c,d),0===n.sizeFromShape(d))return r.makeTensorInfo(d,s.dtype,[]);if(r.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=r.texData.get(s.dataId),n=To(e.values,c,d,s.shape,s.dtype);return r.makeTensorInfo(d,s.dtype,n)}const{isPacked:p}=r.texData.get(s.dataId),h=i.isSliceContinous(s.shape,c,d);if(p||!h){const e=t().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ri(d):new wi(d),n=[c];return r.runWebGLProgram(e,[s],s.dtype,n)}return r.uploadToGPU(s.dataId),function(e,t,a,r){const o=r.texData.get(e.dataId),s=r.makeTensorInfo(a,e.dtype),u=r.texData.get(s.dataId);Object.assign(u,o),u.refCount=1,u.shape=a,u.dtype=e.dtype;let l=i.computeFlatOffset(t,n.computeStrides(e.shape));o.slice&&(l+=o.slice.flatOffset),u.slice={flatOffset:l,origDataId:o.slice&&o.slice.origDataId||e.dataId};const c=r.dataRefCount.get(u.slice.origDataId)||1;return r.dataRefCount.set(u.slice.origDataId,c+1),s}(s,c,d,r)}const Ti={kernelName:K,backendName:"webgl",kernelFunc:ki},Ei={kernelName:q,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{blockShape:i,crops:u}=o;n.assert(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const l=i.reduce(((e,n)=>e*n)),c=r.getReshaped(s.shape,i,l),d=r.getPermuted(c.length,i.length),p=r.getReshapedPermuted(s.shape,i,l),h=r.getSliceBeginCoords(u,i.length),f=r.getSliceSize(p,u,i.length),x=[],m=Es({inputs:{x:s},backend:a,attrs:{shape:c}}),g=Us({inputs:{x:m},backend:a,attrs:{perm:d}}),b=Es({inputs:{x:g},backend:a,attrs:{shape:p}}),v=ki({inputs:{x:b},backend:a,attrs:{begin:h,size:f}});return x.push(m),x.push(g),x.push(b),x.forEach((e=>a.disposeIntermediateTensorInfo(e))),v}};const Ni={kernelName:Y,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:r,weights:o}=n,{size:s}=a,i=t.readSync(r.dataId),u=t.readSync(o.dataId),l=eo(i,u,o.dtype,o.shape,s);return t.makeTensorInfo([s],o.dtype,l)}};const Ai={kernelName:Q,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{s0:a,s1:o}=n,s=t.readSync(a.dataId),i=t.readSync(o.dataId),u=r.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},Fi=Cs({opSnippet:"return float(a != b);",cpuKernelImpl:Io,dtype:"bool"}),Oi={kernelName:Z,backendName:"webgl",kernelFunc:Fi};function _i(e){const{inputs:n,backend:t}=e,{input:a}=n;return ls({inputs:{x:t.texData.get(a.dataId).complexTensorInfos.real},backend:t})}const Di={kernelName:J,backendName:"webgl",kernelFunc:_i};const Li={kernelName:ee,backendName:"webgl",kernelFunc:function t(a){const{inputs:r,backend:o,attrs:s}=a,{x:i}=r,{dtype:u}=s;if("complex64"===u){if("complex64"===i.dtype)return ls({inputs:{x:i},backend:o});const n=e.zeros(i.shape),a=t({inputs:{x:i},backend:o,attrs:{dtype:"float32"}}),r=ds({inputs:{real:a,imag:n},backend:o});return n.dispose(),o.disposeIntermediateTensorInfo(a),r}if("complex64"===i.dtype){const e=_i({inputs:{input:i},backend:o}),n=t({inputs:{x:e},backend:o,attrs:{dtype:u}});return o.disposeIntermediateTensorInfo(e),n}if(!n.hasEncodingLoss(i.dtype,u)){const e=ls({inputs:{x:i},backend:o});return{dataId:e.dataId,shape:e.shape,dtype:u}}if("int32"===u)return function(e,n){const t=new Yo(e.shape,"return float(int(x));"),a=n.runWebGLProgram(t,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(i,o);if("bool"===u){const e=o.makeTensorInfo([],"bool",n.getTypedArrayFromDType("bool",1)),t=Fi({inputs:{a:i,b:e},backend:o});return o.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${u}`)}},Pi="return ceil(x);",Bi={kernelName:ne,backendName:"webgl",kernelFunc:vs({opSnippet:Pi,packedOpSnippet:Pi,cpuKernelImpl:to})};class Ui{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Vi{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Wi={kernelName:te,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{clipValueMin:s,clipValueMax:i}=r;let u;u=t().getBool("WEBGL_PACK_CLIP")?new Vi(o.shape):new Ui(o.shape);const l=[[s],[i]];return a.runWebGLProgram(u,[o],o.dtype,l)}};class Mi{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Gi(e,n){return{dataId:n.dataId,dtype:n.dtype,shape:e.shape}}const zi={kernelName:ae,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{x:a}=n,r=t.texData.get(a.dataId),o=new Mi(a.shape),s=[Gi(a,r.complexTensorInfos.real),Gi(a,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,s,s[0].dtype)}};class Xi{constructor(e){this.outputShape=[],this.outputShape=r.computeOutShape(e,1),this.variableNames=e.map(((e,n)=>`T${n}`));const n=new Array(e.length-1);n[0]=e[0][1];for(let t=1;t<n.length;t++)n[t]=n[t-1]+e[t][1];const t=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<n.length;e++){const a=n[e-1];t.push(`else if (yC < ${n[e]}) setOutput(getT${e}(yR, yC-${a}));`)}const a=n.length,o=n[n.length-1];t.push(`else setOutput(getT${a}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${t.join("\n        ")}\n      }\n    `}}class Hi{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=r.computeOutShape(e,n);const t=this.outputShape,a=t.length,o=Ga(a),s=Go("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,n)=>`T${n}`));const u=new Array(e.length-1);u[0]=e[0][n];for(let t=1;t<u.length;t++)u[t]=u[t-1]+e[t][n];const l=i[n],c=i.slice(-2),d=i.join();let p=`if (${l} < ${u[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let e=1;e<u.length;e++){const n=u[e-1];p+=`\n        if (${l} < ${u[e]}  && ${l} >= ${u[e-1]}) {\n          return getChannel(\n            getT${e}(${ji(i,l,n)}),\n            vec2(${ji(c,l,n)}));\n        }`}const h=u.length,f=u[u.length-1];p+=`\n        return getChannel(\n          getT${h}(${ji(i,l,f)}),\n          vec2(${ji(c,l,f)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${p}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[a-1]} = ${s[a-1]} + 1;\n        if (${s[a-1]} < ${t[a-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[a-2]} = ${s[a-2]} + 1;\n        if (${s[a-2]} < ${t[a-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[a-1]} = ${s[a-1]} - 1;\n        if (${s[a-2]} < ${t[a-2]} &&\n            ${s[a-1]} < ${t[a-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function ji(e,n,t){const a=e.indexOf(n);return e.map(((e,n)=>n===a?`${e} - ${t}`:e)).join()}function Ki(e){const{inputs:n,backend:t}=e,{input:a}=n;return ls({inputs:{x:t.texData.get(a.dataId).complexTensorInfos.imag},backend:t})}const qi={kernelName:re,backendName:"webgl",kernelFunc:Ki};function Yi(e,a,o){const s=e[0].dtype;if("complex64"===s){const n=e.map((e=>_i({inputs:{input:e},backend:o}))),t=e.map((e=>Ki({inputs:{input:e},backend:o}))),r=Yi(n,a,o),s=Yi(t,a,o),i=ds({inputs:{real:r,imag:s},backend:o});return n.forEach((e=>o.disposeIntermediateTensorInfo(e))),t.forEach((e=>o.disposeIntermediateTensorInfo(e))),o.disposeIntermediateTensorInfo(r),o.disposeIntermediateTensorInfo(s),i}let i=o.shouldExecuteOnCPU(e);if("string"===s&&(i=!0),i){const t=e.map((e=>{const t=n.sizeFromShape(e.shape.slice(a));return Es({inputs:{x:e},backend:o,attrs:{shape:[-1,t]}})})),i=t.map((e=>({vals:o.readSync(e.dataId),shape:e.shape}))),u=r.computeOutShape(t.map((e=>e.shape)),1),l=1===t[0].shape[0],c=ao(i,u,s,l),d=r.computeOutShape(e.map((e=>e.shape)),a),p=o.makeTensorInfo(d,s,c);return t.forEach((e=>o.disposeIntermediateTensorInfo(e))),p}if(e.length>t().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(e.length/2),t=Yi(e.slice(0,n),a,o),r=Yi(e.slice(n),a,o),s=Yi([t,r],a,o);return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(r),s}if(t().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const n=new Hi(e.map((e=>e.shape)),a);return o.runWebGLProgram(n,e,s)}const{tensors2D:u,outShape:l}=function(e,t,a){const o=r.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Es({inputs:{x:e},attrs:{shape:[-1,n.sizeFromShape(e.shape.slice(t))]},backend:a}))),outShape:o}}(e,a,o),c=new Xi(u.map((e=>e.shape))),d=o.runWebGLProgram(c,u,s);u.forEach((e=>o.disposeIntermediateTensorInfo(e)));const p=Es({inputs:{x:d},attrs:{shape:l},backend:o});return o.disposeIntermediateTensorInfo(d),p}function Qi(e){const{inputs:t,backend:a,attrs:o}=e,{axis:s}=o,i=n.parseAxisParam(s,t[0].shape)[0],u=r.computeOutShape(t.map((e=>e.shape)),i);if(0===n.sizeFromShape(u))return a.makeTensorInfo(u,t[0].dtype,[]);const l=t.filter((e=>n.sizeFromShape(e.shape)>0));if(1===l.length)return ls({inputs:{x:l[0]},backend:a});const c=l.map((e=>e.shape));return r.assertParamsConsistent(c,i),Yi(l,i,a)}const Zi={kernelName:oe,backendName:"webgl",kernelFunc:Qi};class Ji{constructor(e,n=!1,t=null,a=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,s=e.padInfo.left,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,x="channelsLast"===e.dataFormat,m=x?1:2,g=x?2:3,b=x?3:1;let v="",C="";t&&(v=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${t}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${t}\n        }`:`\n          float activation(float x) {\n            ${t}\n          }\n        `,C="result = activation(result);");const $=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${i}, ${u});\n      const ivec2 pads = ivec2(${o}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${x}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${x}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${x}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${x}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${$}\n        ${C}\n        setOutput(result);\n      }\n    `}}class eu{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,t=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${o}, ${s});\n      const ivec3 pads = ivec3(${n}, ${t}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${i};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class nu{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=qa(this.outputShape.length);const{dataFormat:t}=n,a=Ra(),r="channelsLast"===t,o=r?0:1,s=r?1:2,i=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let u="";for(let e=0;e<=1;e++)for(let n=0;n<=1;n++)u+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${e};\n\n          ${i}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${s}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${a.output} = result;\n      }\n    `}}function tu({x:e,filter:t,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:u=null}){const l=e.shape,c=r.texData.get(e.dataId),d=a.inChannels,p=l[0]*l[1]*l[2],h=a.outChannels,f="channelsLast"===a.dataFormat;let x;const m=[];if(!((1===p||1===h)&&d>1e3)&&c.isPacked&&f&&null!=c.texture&&l[2]%2!=0&&n.arraysEqual(c.shape.slice(-3),l.slice(-3))){const d=l[0]*l[1]*(l[2]+1),p={dataId:e.dataId,shape:[1,d,a.inChannels],dtype:e.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,n.assert(da(c.shape,p.shape),(()=>`packed reshape ${c.shape} to ${p.shape} isn't free`));const f=Es({inputs:{x:t},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});m.push(f);const g=Ws({a:p,b:f,backend:r,transposeA:false,transposeB:false,bias:o,activation:u,preluActivationWeights:s,leakyreluAlpha:i}),b=r.texData.get(g.dataId);n.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,b.shape=a.outShape,x=ls({inputs:{x:g},backend:r}),x.shape=a.outShape,m.push(g)}else{const n=Es({inputs:{x:e},backend:r,attrs:{shape:[1,f?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],a.inChannels]}}),c=Es({inputs:{x:t},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),d=Ws({a:n,b:c,transposeA:false,transposeB:false,backend:r,bias:o,activation:u,preluActivationWeights:s,leakyreluAlpha:i});x=Es({inputs:{x:d},backend:r,attrs:{shape:a.outShape}}),m.push(n),m.push(c),m.push(d)}for(const e of m)r.disposeIntermediateTensorInfo(e);return x}function au({x:e,filter:t,convInfo:a,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:u=null}){const{filterWidth:l,filterHeight:c,inChannels:d,outWidth:p,outHeight:h,dataFormat:f}=a,x="channelsLast"===f,m=l*c*d,g=h*p,b=[m,g],v=[],C=Es({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),$=Es({inputs:{x:t},backend:r,attrs:{shape:[1,m,n.sizeFromShape(t.shape)/m]}});v.push(C),v.push($);const I=new nu(b,a),y=[C.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],w=r.runWebGLProgram(I,[C],"float32",y),S=Es({inputs:{x:w},backend:r,attrs:{shape:[1,b[0],b[1]]}});v.push(w),v.push(S);const R=null!=o,k=null!=s,T="leakyrelu"===u,E=u?$s(u,!0):null,N=new Is(S.shape,$.shape,[1,g,a.outChannels],!0,!1,R,E,k,T),A=[S,$];if(o&&A.push(o),k&&A.push(s),T){const e=r.makeTensorInfo([],"float32",n.createScalarValue(i,"float32"));A.push(e),v.push(e)}const F=r.runWebGLProgram(N,A,"float32"),O=Es({inputs:{x:F},backend:r,attrs:{shape:x?[1,h,p,a.outChannels]:[1,a.outChannels,h,p]}});v.push(F);for(const e of v)r.disposeIntermediateTensorInfo(e);return O}const ru={kernelName:se,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:o}=e,{x:s,filter:i}=n,{strides:u,pad:l,dataFormat:c,dilations:d,dimRoundingMode:p}=o,h=r.convertConv2DDataFormat(c),f=r.computeConv2DInfo(s.shape,i.shape,u,d,l,p,!1,h);let x;if(1!==f.filterHeight||1!==f.filterWidth||1!==f.dilationHeight||1!==f.dilationWidth||1!==f.strideHeight||1!==f.strideWidth||"SAME"!==f.padInfo.type&&"VALID"!==f.padInfo.type)if(t().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])x=au({x:s,filter:i,convInfo:f,backend:a});else{const e=new Ji(f);x=a.runWebGLProgram(e,[s,i],"float32")}else x=tu({x:s,filter:i,convInfo:f,backend:a});const m=Es({inputs:{x:x},backend:a,attrs:{shape:f.outShape}});return a.disposeIntermediateTensorInfo(x),m}};class ou{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,t=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${n} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${t} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${o}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class su{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,t=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o="channelsLast"===e.dataFormat,s=n-1-e.padInfo.top,i=t-1-e.padInfo.left,u=o?1:2,l=o?2:3,c=o?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${t}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${t} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class iu{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,t=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,s=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${n} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${t} - ${o};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${a} - ${s};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class uu{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,t=e.filterHeight,a=e.filterWidth,r=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=n-1-e.padInfo.front,u=t-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${i}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${n}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${n} - 1 - wF;\n\n          for (int wR = 0; wR < ${t}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${t} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const lu={kernelName:ie,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o,dy:s}=n,{strides:i,pad:u,dataFormat:l,dimRoundingMode:c,filterShape:d}=a,p=r.convertConv2DDataFormat(l),h=r.computeConv2DInfo(o.shape,d,i,1,u,c,!1,p),f=new ou(h);return t.runWebGLProgram(f,[o,s],"float32")}};const cu={kernelName:ue,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{dy:o,filter:s}=n,{inputShape:i,strides:u,pad:l,dataFormat:c,dimRoundingMode:d}=a,p=r.convertConv2DDataFormat(c),h=r.computeConv2DInfo(i,s.shape,u,1,l,d,!1,p),f=new su(h);return t.runWebGLProgram(f,[o,s],"float32")}};const du={kernelName:le,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o,filter:s}=n,{strides:i,pad:u,dilations:l}=a,c=r.computeConv3DInfo(o.shape,s.shape,i,l,u),d=new eu(c);return t.runWebGLProgram(d,[o,s],"float32")}};const pu={kernelName:ce,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o,dy:s}=n,{strides:i,pad:u,filterShape:l}=a,c=r.computeConv3DInfo(o.shape,l,i,1,u),d=new iu(c);return t.runWebGLProgram(d,[o,s],"float32")}};const hu={kernelName:de,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{dy:o,filter:s}=n,{pad:i,strides:u,inputShape:l}=a,c=r.computeConv3DInfo(l,s.shape,u,1,i),d=new uu(c);return t.runWebGLProgram(d,[o,s],"float32")}},fu={kernelName:pe,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"})},xu={kernelName:he,backendName:"webgl",kernelFunc:vs({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"})};class mu{constructor(e,n,t,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,s,i,u]=e,[l]=n,[c,d]=t;this.outputShape=[l,c,d,u];const p="bilinear"===a?1:0,[h,f]=[s-1+".0",i-1+".0"],[x,m,g]=c>1?[""+(s-1)/(c-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,v,C]=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${x});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${m};\n        float width_scale = ${v};\n\n        float in_y = ${g};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${C};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const gu={kernelName:fe,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:a}=e,{image:r,boxes:o,boxInd:s}=n,{cropSize:i,method:u,extrapolationValue:l}=a,c=new mu(r.shape,o.shape,i,u,l);return t.runWebGLProgram(c,[r,o,s],"float32")}};class bu{constructor(e,n,t){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const a=e.length,r=n?"1.0":`getX(${vu(a,"coords")})`,o=e[e.length-1];let s="",i="";n?(s=t?"end != "+(o-1):"end != 0",i=t?"end + 1":"end - 1"):(s=t?`end + pow2 < ${o}`:"end >= pow2",i=t?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Ga(a)} coords = getOutputCoords();\n        int end = ${Cu(a,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${s}) {\n          int idx = ${i};\n          ${Cu(a,"coords")} = idx;\n          val *= getX(${vu(a,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function vu(e,n){if(1===e)return`${n}`;if(2===e)return`${n}.x, ${n}.y`;if(3===e)return`${n}.x, ${n}.y, ${n}.z`;if(4===e)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw Error(`Cumulative product for rank ${e} is not yet supported`)}function Cu(e,n){if(1===e)return`${n}`;if(2===e)return`${n}.y`;if(3===e)return`${n}.z`;if(4===e)return`${n}.w`;throw Error(`Cumulative product for rank ${e} is not yet supported`)}const $u={kernelName:xe,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o}=n,{axis:s,exclusive:i,reverse:u}=a,l=o.shape.length,c=r.getAxesPermutation([s],l);let d=o;null!=c&&(d=Us({inputs:{x:o},backend:t,attrs:{perm:c}}));const p=r.getInnerMostAxes(1,l)[0];if(p!==l-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);const h=d.shape[p];let f=ls({inputs:{x:d},backend:t});for(let e=0;e<=Math.ceil(Math.log2(h))-1;e++){const n=new bu(d.shape,!1,u),a=[[e]],r=f;f=t.runWebGLProgram(n,[f],f.dtype,a),t.disposeIntermediateTensorInfo(r)}if(i){const e=new bu(d.shape,i,u),n=f;f=t.runWebGLProgram(e,[f],f.dtype),t.disposeIntermediateTensorInfo(n)}if(null!=c){const e=Us({inputs:{x:f},backend:t,attrs:{perm:r.getUndoAxesPermutation(c)}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),e}return f}};class Iu{constructor(e,n,t){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const a=e.length,r=n?"0.0":`getX(${yu(a,"coords")})`,o=e[e.length-1];let s="",i="";n?(s=t?"end != "+(o-1):"end != 0",i=t?"end + 1":"end - 1"):(s=t?`end + pow2 < ${o}`:"end >= pow2",i=t?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Ga(a)} coords = getOutputCoords();\n        int end = ${wu(a,"coords")};\n        float val = ${r};\n        int pow2 = int(pow(2.0, index));\n        if (${s}) {\n          int idx = ${i};\n          ${wu(a,"coords")} = idx;\n          val += getX(${yu(a,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function yu(e,n){if(1===e)return`${n}`;if(2===e)return`${n}.x, ${n}.y`;if(3===e)return`${n}.x, ${n}.y, ${n}.z`;if(4===e)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function wu(e,n){if(1===e)return`${n}`;if(2===e)return`${n}.y`;if(3===e)return`${n}.z`;if(4===e)return`${n}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const Su={kernelName:me,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o}=n,{axis:s,exclusive:i,reverse:u}=a,l=o.shape.length,c=r.getAxesPermutation([s],l);let d=o;null!=c&&(d=Us({inputs:{x:o},backend:t,attrs:{perm:c}}));const p=r.getInnerMostAxes(1,l)[0];if(p!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);const h=d.shape[p];let f=ls({inputs:{x:d},backend:t});for(let e=0;e<=Math.ceil(Math.log2(h))-1;e++){const n=new Iu(d.shape,!1,u),a=[[e]],r=f;f=t.runWebGLProgram(n,[f],f.dtype,a),t.disposeIntermediateTensorInfo(r)}if(i){const e=new Iu(d.shape,i,u),n=f;f=t.runWebGLProgram(e,[f],f.dtype),t.disposeIntermediateTensorInfo(n)}if(null!=c){const e=Us({inputs:{x:f},backend:t,attrs:{perm:r.getUndoAxesPermutation(c)}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),e}return f}};const Ru={kernelName:ge,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:r,weights:o}=n,{size:s,binaryOutput:i}=a;if(1===r.shape.length){const e=t.readSync(r.dataId),n=t.readSync(o.dataId),a=eo(e,n,o.dtype,o.shape,s);return t.makeTensorInfo([s],o.dtype,a)}if(2===r.shape.length){const e=t.bufferSync(r),n=t.bufferSync(o),a=no(e,n,s,i);return t.makeTensorInfo(a.shape,o.dtype,a.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class ku{constructor(e,n,t){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=t,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${n};\n      int offset_h = imod(h, ${n});\n      int in_w = w / ${n};\n      int offset_w = imod(w, ${n});\n      int offset_d = (offset_h * ${n} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Tu={kernelName:be,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:r}=n,{blockSize:o,dataFormat:s}=a,i=r.shape[0],u=("NHWC"===s?r.shape[1]:r.shape[2])*o,l=("NHWC"===s?r.shape[2]:r.shape[3])*o,c=("NHWC"===s?r.shape[3]:r.shape[1])/(o*o),d=new ku("NHWC"===s?[i,u,l,c]:[i,c,u,l],o,s);return t.runWebGLProgram(d,[r],r.dtype)}};class Eu{constructor(e,n=!1,t=null,a=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qa(this.outputShape.length);const o=e.filterHeight,s=e.filterWidth,i=e.outChannels/e.inChannels;let u="",l="";t&&(u=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${t}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${t}\n        }`:`\n          float activation(float x) {\n            ${t}\n          }\n        `,l="result = activation(result);");const c=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${l}\n        setOutput(result);\n      }\n    `}}class Nu{constructor(e,t=!1,a=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qa(this.outputShape.length);const s=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,p=d;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<d;e++)h+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;h+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<d;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(p+1)/2;e++){const t=2*e;if(h+=`\n          xC = xCCorner + ${t*l};\n          `,1===u){if(t<d&&(i%2==1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,h+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<d)){const e=i%2==0?n.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,l>1&&(h+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                      xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${t}Ready = 1;\n                    }\n                    `),h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                  `):h+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<d&&(i%2==1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<d&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<d&&(h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<d&&(h+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<d&&(h+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let f="",x="";a&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,x="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${x}\n        setOutput(result);\n      }\n    `}}const Au={kernelName:ve,backendName:"webgl",kernelFunc:function(e){const{inputs:a,backend:o,attrs:s}=e,{x:i,filter:u}=a,{strides:l,pad:c,dilations:d,dimRoundingMode:p}=s;let h=d;null==h&&(h=[1,1]),n.assert(r.eitherStridesOrDilationsAreOne(l,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`));const f=r.computeConv2DInfo(i.shape,u.shape,l,h,c,p,!0);let x;x=t().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels==1?new Nu(f):new Eu(f);const m=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return o.runWebGLProgram(x,[i,u],"float32",m)}};class Fu{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,t=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${o} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${n} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${t} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Ou{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,t=e.filterWidth,a=e.strideHeight,r=e.strideWidth,o=n-1-e.padInfo.top,s=t-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${t}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${t} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${i}; dm++) {\n              int d2 = d1 * ${i} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const _u={kernelName:Ce,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o,dy:s}=n,{strides:i,dilations:u,pad:l,dimRoundingMode:c,filterShape:d}=a,p=r.computeConv2DInfo(o.shape,d,i,u,l,c,!0),h=new Fu(p);return t.runWebGLProgram(h,[o,s],"float32")}};const Du={kernelName:$e,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{dy:o,filter:s}=n,{strides:i,dilations:u,pad:l,dimRoundingMode:c,inputShape:d}=a,p=r.computeConv2DInfo(d,s.shape,i,u,l,c,!0),h=new Ou(p);return t.runWebGLProgram(h,[o,s],"float32")}};class Lu{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Pu={kernelName:Ie,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a}=e,{x:r}=t,o=[...r.shape,...r.shape],s=n.sizeFromShape(r.shape),i=Es({inputs:{x:r},backend:a,attrs:{shape:[s]}}),u=new Lu(s),l=a.runWebGLProgram(u,[i],i.dtype),c=Es({inputs:{x:l},backend:a,attrs:{shape:o}});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(l),c}};class Bu{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:t,padInfo:a,strideHeight:r,strideWidth:o,filterHeight:s,filterWidth:i,dilationHeight:u,dilationWidth:l}=e,{top:c,left:d}=a;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${o});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${s}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${n}) {\n            for (int w = 0; w < ${i}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${t}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const Uu={kernelName:ye,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o,filter:s}=n,{strides:i,pad:u,dilations:l}=a,c=r.computeDilation2DInfo(o.shape,s.shape,i,u,"NHWC",l);let d;const p=new Bu(c);d=t.runWebGLProgram(p,[o,s],"float32");const h=Es({inputs:{x:d},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(d),h}};const Vu={kernelName:we,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{equation:s}=o,i=t,{allDims:u,summedDims:l,idDims:c}=r.decodeEinsumEquation(s,i.length);r.checkEinsumDimSizes(u.length,c,i);const{path:d,steps:p}=r.getEinsumComputePath(l,c),h=p.length;let f=null,x=u.length;const m=[];for(let e=0;e<h;++e){for(const t of p[e]){const{permutationIndices:e,expandDims:o}=r.getEinsumPermutation(x,c[t]);let s;r.isIdentityPermutation(e)?s=i[t]:(s=Us({inputs:{x:i[t]},backend:a,attrs:{perm:e}}),m.push(s));const u=s.shape.slice();for(let e=0;e<o.length;++e)u.splice(o[e],0,1);n.arraysEqual(s.shape,u)||(s=Es({inputs:{x:s},backend:a,attrs:{shape:u}}),m.push(s)),null===f?f=s:(f=ks({inputs:{a:s,b:f},backend:a}),m.push(f))}e<h-1&&(d[e]>=0&&(f=Ps({inputs:{x:f},backend:a,attrs:{axis:d[e]-(u.length-x),keepDims:!1}}),m.push(f)),x--)}for(const e of m)e!==f&&a.disposeIntermediateTensorInfo(e);return f}},Wu={kernelName:Se,backendName:"webgl",kernelFunc:vs({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"})},Mu={kernelName:Re,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:a}=e,{dy:r,y:o}=n,s=t().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new us("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,o.shape):new is("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,o.shape);return a.runWebGLProgram(s,[r,o],r.dtype)}},Gu={kernelName:ke,backendName:"webgl",kernelFunc:Cs({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:ro})},zu={kernelName:Te,backendName:"webgl",kernelFunc:vs({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${r.ERF_P};\n  float a1 = ${r.ERF_A1};\n  float a2 = ${r.ERF_A2};\n  float a3 = ${r.ERF_A3};\n  float a4 = ${r.ERF_A4};\n  float a5 = ${r.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`})},Xu=vs({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:oo,dtype:"float32"}),Hu={kernelName:Ee,backendName:"webgl",kernelFunc:Xu};function ju(e){const{inputs:t,attrs:a,backend:r}=e,{dim:o}=a,{input:s}=t,i=s.shape.length,u=s.shape.slice();let l=o;return o<0&&(n.assert(-(i+1)<=o,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+o+1),u.splice(l,0,1),Es({inputs:{x:s},backend:r,attrs:{shape:u}})}const Ku={kernelName:Ne,backendName:"webgl",kernelFunc:ju},qu="return exp(x) - 1.0;",Yu={kernelName:Ae,backendName:"webgl",kernelFunc:vs({opSnippet:qu,packedOpSnippet:qu,cpuKernelImpl:so})};class Qu{constructor(e,n,t){this.variableNames=["real","imag"];const a=n[1];this.outputShape=n;const r=t?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=t?`${a}.0`:"1.0";let s;if("real"===e)s="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);s="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${s}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Zu(e,t,a){const r=a.texData.get(e.dataId),o=n.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=Es({inputs:{x:e},backend:a,attrs:{shape:[o/s,s]}}),u=i.shape,l=new Qu("real",u,t),c=new Qu("imag",u,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],p=a.runWebGLProgram(l,d,"float32"),h=a.runWebGLProgram(c,d,"float32"),f=ds({inputs:{real:p,imag:h},backend:a});a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(h);const x=Es({inputs:{x:f},backend:a,attrs:{shape:e.shape}});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(f),x}const Ju={kernelName:Fe,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{input:a}=n;return Zu(a,!1,t)}};class el{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function nl(e){const{backend:t,attrs:a}=e,{shape:r,value:o}=a;let{dtype:s}=a;if(s=s||n.inferDtype(o),"string"===s){const e=n.getArrayFromDType(s,n.sizeFromShape(r));return e.fill(o),t.makeTensorInfo(r,s,e)}{const e=new el(r,o),n=[[o]];return t.runWebGLProgram(e,[],s,n)}}const tl={kernelName:Oe,backendName:"webgl",kernelFunc:nl};class al{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${n} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${n}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const rl={kernelName:_e,backendName:"webgl",kernelFunc:({inputs:e,backend:n})=>{const{image:t}=e,a=n,r=new al(t.shape);return a.runWebGLProgram(r,[t],t.dtype)}},ol="return floor(x);",sl={kernelName:De,backendName:"webgl",kernelFunc:vs({opSnippet:ol,packedOpSnippet:ol,cpuKernelImpl:io})},il={kernelName:Le,backendName:"webgl",kernelFunc:Cs({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"})};class ul{constructor(e){this.variableNames=["A"];const n=Ra(),[t,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${t}.0);\n\n        vec4 values = ${n.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class ll{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Ra(),[t,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${t}.0);\n            vec4 values = ${n.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${n.output} = result;\n      }\n    `}}const cl={kernelName:Pe,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e;let{pixels:o}=n;const{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,[l,c]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],d=[c,l],p=[c,l,s];(u||i)&&(null==dl&&(dl=document.createElement("canvas").getContext("2d")),dl.canvas.width=l,dl.canvas.height=c,dl.drawImage(o,0,0,l,c),o=dl.canvas);const h=a.makeTensorInfo(d,"int32");a.texData.get(h.dataId).usage=kt.PIXELS,a.gpgpu.uploadPixelDataToTexture(a.getTexture(h.dataId),o);const f=t().getBool("WEBGL_PACK")?new ll(p):new ul(p),x=a.runWebGLProgram(f,[h],"int32");return a.disposeData(h.dataId),x}};let dl;const pl={kernelName:Be,backendName:"webgl",kernelFunc:function(e){const{inputs:a,backend:o,attrs:s}=e,{x:i,filter:u,bias:l,preluActivationWeights:c}=a,{strides:d,pad:p,dataFormat:h,dilations:f,dimRoundingMode:x,activation:m,leakyreluAlpha:g}=s,b=r.convertConv2DDataFormat(h),v=r.computeConv2DInfo(i.shape,u.shape,d,f,p,x,!1,b);let C;const $=[];if(1!==v.filterHeight||1!==v.filterWidth||1!==v.dilationHeight||1!==v.dilationWidth||1!==v.strideHeight||1!==v.strideWidth||"SAME"!==v.padInfo.type&&"VALID"!==v.padInfo.type)if(t().getBool("WEBGL_CONV_IM2COL")&&1===i.shape[0])C=au({x:i,filter:u,convInfo:v,backend:o,bias:l,activation:m,preluActivationWeights:c,leakyreluAlpha:g});else{const e=null!=l,t=null!=c,a="leakyrelu"===m,r=m?$s(m,!1):null,s=new Ji(v,e,r,t,a),d=[i,u];if(l&&d.push(l),c&&d.push(c),a){const e=o.makeTensorInfo([],"float32",n.createScalarValue(g,"float32"));d.push(e),$.push(e)}C=o.runWebGLProgram(s,d,"float32")}else C=tu({x:i,filter:u,convInfo:v,backend:o,bias:l,activation:m,preluActivationWeights:c,leakyreluAlpha:g});const I=Es({inputs:{x:C},backend:o,attrs:{shape:v.outShape}});return $.push(C),$.forEach((e=>o.disposeIntermediateTensorInfo(e))),I}};const hl={kernelName:Ue,backendName:"webgl",kernelFunc:function(e){const{inputs:a,backend:o,attrs:s}=e,{x:i,filter:u,bias:l,preluActivationWeights:c}=a,{strides:d,pad:p,dilations:h,dimRoundingMode:f,activation:x,leakyreluAlpha:m}=s,g=[];let b=h;null==b&&(b=[1,1]),n.assert(r.eitherStridesOrDilationsAreOne(d,b),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${b}'`));const v=r.computeConv2DInfo(i.shape,u.shape,d,b,p,f,!0),C=t().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels==1,$=x?$s(x,C):null,I=[i,u],y=null!=l,w=null!=c,S="leakyrelu"===x;if(y&&I.push(l),w&&I.push(c),S){const e=o.makeTensorInfo([],"float32",n.createScalarValue(m,"float32"));I.push(e),g.push(e)}let R;R=C?new Nu(v,y,$,w,S):new Eu(v,y,$,w,S);const k=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],T=o.runWebGLProgram(R,I,"float32",k);return g.forEach((e=>o.disposeIntermediateTensorInfo(e))),T}};class fl{constructor(e,n,t){this.sliceDim=e,this.strides=n,this.variableNames=["x","indices"],this.outputShape=t;const a=Ga(n.length),r=Ga(t.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${a} strides = ${a}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${o};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const xl={kernelName:Ve,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a}=e,{params:o,indices:s}=t,i=s.shape,u=i[i.length-1],l=n.sizeFromShape(o.shape),[c,d,p,h]=r.prepareAndValidate(o,s),f=Es({inputs:{x:s},backend:a,attrs:{shape:[d,u]}}),x=Es({inputs:{x:o},backend:a,attrs:{shape:[n.sizeFromShape(o.shape)/p,p]}});if(a.shouldExecuteOnCPU([o,s])||"string"===o.dtype){const e=a.readSync(s.dataId),n=a.bufferSync(o),t=uo(e,n,o.dtype,d,u,p,h,o.shape,l);return a.makeTensorInfo(c,o.dtype,t.values)}const m=new fl(u,h,[d,p]),g=a.runWebGLProgram(m,[x,f],x.dtype),b=Es({inputs:{x:g},backend:a,attrs:{shape:c}});return a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(g),b}};class ml{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const t=Ga(this.rank),a=function(e,n){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let n=0;n<e.length;n++)2===n?a.push("index"):a.push(`${t[n]}`);return a.join()}(e);this.userCode=`\n      void main() {\n        ${t} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${a}));\n      }\n    `}}function gl(e){const{inputs:a,backend:o,attrs:s}=e,{x:i,indices:u}=a,{axis:l,batchDims:c}=s,d=n.parseAxisParam(l,i.shape)[0];if(t().get("DEBUG")){const e=o.readSync(u.dataId),t=i.shape[d];for(let a=0;a<e.length;++a){const r=e[a];n.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const p=r.segment_util.collectGatherOpShapeInfo(i,u,d,c),h=n.sizeFromShape(u.shape),f=[],x=Es({inputs:{x:i},backend:o,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Es({inputs:{x:u},backend:o,attrs:{shape:[p.batchSize,h/p.batchSize]}});f.push(x),f.push(m);const g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize];if(o.shouldExecuteOnCPU([i,u])||"string"===i.dtype){const e=o.bufferSync(m),n=o.bufferSync(x),t=lo(n,e,g);return f.forEach((e=>o.disposeIntermediateTensorInfo(e))),o.makeTensorInfo(p.outputShape,t.dtype,t.values)}const b=new ml(x.shape,g),v=o.runWebGLProgram(b,[x,m],x.dtype);f.push(v);const C=Es({inputs:{x:v},backend:o,attrs:{shape:p.outputShape}});return f.forEach((e=>o.disposeIntermediateTensorInfo(e))),C}const bl={kernelName:We,backendName:"webgl",kernelFunc:gl},vl={kernelName:Me,backendName:"webgl",kernelFunc:Cs({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:co,dtype:"bool"})},Cl={kernelName:Ge,backendName:"webgl",kernelFunc:Cs({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:po})};const $l={kernelName:ze,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{input:a}=n;return Zu(a,!0,t)}},Il={kernelName:Xe,backendName:"webgl",kernelFunc:vs({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"})},yl={kernelName:He,backendName:"webgl",kernelFunc:vs({opSnippet:"return float(isinf(x));",dtype:"bool"})},wl={kernelName:je,backendName:"webgl",kernelFunc:vs({opSnippet:"return float(isnan(x));",dtype:"bool"})},Sl={kernelName:Ke,backendName:"webgl",kernelFunc:Cs({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:ho,dtype:"bool"})},Rl={kernelName:qe,backendName:"webgl",kernelFunc:Cs({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:fo,dtype:"bool"})};const kl={kernelName:Ye,backendName:"webgl",kernelFunc:function(e){const{backend:n,attrs:t}=e,{start:a,stop:r,num:o}=t,s=xo(a,r,o);return n.makeTensorInfo([s.length],"float32",s)}},Tl={kernelName:Qe,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:mo})},El={kernelName:Ze,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"})},Nl={kernelName:Je,backendName:"webgl",kernelFunc:Cs({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"})},Al={kernelName:en,backendName:"webgl",kernelFunc:vs({opSnippet:"return float(!(x >= 1.0));"})},Fl={kernelName:nn,backendName:"webgl",kernelFunc:Cs({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"})};class Ol{constructor(e,n,t,a,r){this.variableNames=["x"],this.outputShape=[];const o=n,s=e[3]-1;let i;this.outputShape=e;const u=`float(${t}) + float(${a}) * sum`;i=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${s}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${i};\n        setOutput(val);\n      }\n    `}}class _l{constructor(e,n,t,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=n,s=e[3]-1;let i;this.outputShape=e;const u=`float(${t}) + float(${a}) * sum`;i=.5===r?`inversesqrt(${u})`:1===r?`1.0/(${u})`:`exp(log(${u}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${i};\n        setOutput(result);\n      }\n    `}}const Dl={kernelName:tn,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:a,attrs:r}=e,{x:o}=n,{depthRadius:s,bias:i,alpha:u,beta:l}=r,c=t().getBool("WEBGL_PACK_NORMALIZATION")?new _l(o.shape,s,i,u,l):new Ol(o.shape,s,i,u,l);return a.runWebGLProgram(c,[o],o.dtype)}};class Ll{constructor(e,n,t,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=t,this.alpha=a,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${n})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${n} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${t});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Pl={kernelName:an,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:a}=e,{x:r,y:o,dy:s}=n,{depthRadius:i,bias:u,alpha:l,beta:c}=a,d=new Ll(r.shape,i,u,l,c);return t.runWebGLProgram(d,[r,o,s],r.dtype)}};function Bl(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{reductionIndices:i,keepDims:u}=o,l=s.shape.length,c=n.parseAxisParam(i,s.shape);let d=c;const p=r.getAxesPermutation(d,l),h=null!=p,f=a.shouldExecuteOnCPU([s]);let x=s;if(h){if(f){const e=a.texData.get(x.dataId).values,n=new Array(l);for(let e=0;e<n.length;e++)n[e]=s.shape[p[e]];const t=Vo(e,s.shape,s.dtype,p,n);x=a.makeTensorInfo(n,s.dtype);a.texData.get(x.dataId).values=t}else x=Ls(s,p,a);d=r.getInnerMostAxes(d.length,l)}r.assertAxesAreInnerMostDims("max",d,l);const[m,g]=r.computeOutAndReduceShapes(x.shape,d);let b,v=m;if(u&&(v=r.expandShapeToKeepDim(m,c)),f){const e=a.texData.get(x.dataId).values,t=go(e,n.sizeFromShape(g),v,s.dtype);b=a.makeTensorInfo(v,s.dtype);a.texData.get(b.dataId).values=t}else b=function(e,t,a,r){const o=n.sizeFromShape(t),s=Es({inputs:{x:e},attrs:{shape:[n.sizeFromShape(e.shape)/o,o]},backend:r}),i=Os(s,e.dtype,"max",r),u=Es({inputs:{x:i},attrs:{shape:a},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),u}(x,g,v,a);return h&&a.disposeIntermediateTensorInfo(x),b}const Ul={kernelName:rn,backendName:"webgl",kernelFunc:Bl},Vl={kernelName:on,backendName:"webgl",kernelFunc:Cs({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:bo})};const Wl={kernelName:sn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t;ya(s,"maxPool");const{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=o;n.assert(r.eitherStridesOrDilationsAreOne(u,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`));const d=r.computePool2DInfo(s.shape,i,u,1,l,c);if(1===d.filterWidth&&1===d.filterHeight&&n.arraysEqual(d.inShape,d.outShape))return ls({inputs:{x:s},backend:a});const p=new pi(d,"max",!1);return a.runWebGLProgram(p,[s],s.dtype)}};const Ml={kernelName:un,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:o}=n,{filterSize:s,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=a,d=r.computePool3DInfo(o.shape,s,i,[1,1,1],u,c,l),p=new hi(d,"max",!1);return t.runWebGLProgram(p,[o],o.dtype)}};class Gl{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,t=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,s=r-1-e.padInfo.top,i=o-1-e.padInfo.left,u=r*o-1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${n}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zl{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,t=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,s=e.dilationWidth,i=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=i-1-e.padInfo.front,d=u-1-e.padInfo.top,p=l-1-e.padInfo.left,h=i*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${i};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${n}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${o}) {\n            float dyR = float(dyRCorner + wR) / ${t}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${s}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Xl={kernelName:ln,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{dy:o,input:s}=n,i=s,{filterSize:u,strides:l,pad:c,dimRoundingMode:d}=a,p=r.computePool3DInfo(i.shape,u,l,[1,1,1],c,d),h=new hi(p,"max",!0),f=t.runWebGLProgram(h,[i],i.dtype),x=new zl(p),m=t.runWebGLProgram(x,[o,f],i.dtype);return t.disposeIntermediateTensorInfo(f),m}};const Hl={kernelName:cn,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{dy:o,input:s,output:i}=n,u=s;ya([s,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:d,dimRoundingMode:p}=a,h=r.computePool2DInfo(u.shape,l,c,1,d,p),f=new pi(h,"max",!0),x=t.runWebGLProgram(f,[u],u.dtype),m=new Gl(h),g=t.runWebGLProgram(m,[o,x],u.dtype);return t.disposeIntermediateTensorInfo(x),g}};const jl={kernelName:dn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:a})=>{const{x:o}=e,{filterSize:s,strides:i,pad:u,includeBatchInIndex:l}=t,c=a;n.assert(4===o.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.shape.length}.`));const d=[1,1];n.assert(r.eitherStridesOrDilationsAreOne(i,d),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));const p=r.computePool2DInfo(o.shape,s,i,d,u),[h,f]=function(e,n,t,a){let r=new pi(t,"max",!1);const o=a.runWebGLProgram(r,[e],"float32");return r=new pi(t,"max",!0,!0,n),[o,a.runWebGLProgram(r,[e],"float32")]}(o,l,p,c);return[h,f]}};const Kl={kernelName:pn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:a})=>{const{x:o}=e,{keepDims:s,axis:i}=t,u=a,l=o.shape.length,c=n.parseAxisParam(i,o.shape);let d=c;const p=r.getAxesPermutation(d,l),h=null!=p,f=u.shouldExecuteOnCPU([o]),x=[];let m=o;if(h){if(f){const e=u.texData.get(m.dataId).values,n=new Array(l);for(let e=0;e<n.length;e++)n[e]=o.shape[p[e]];const t=Vo(e,o.shape,o.dtype,p,n);m=u.makeTensorInfo(n,o.dtype);u.texData.get(m.dataId).values=t}else m=Ls(o,p,u);x.push(m),d=r.getInnerMostAxes(d.length,l)}r.assertAxesAreInnerMostDims("sum",d,l);const[g,b]=r.computeOutAndReduceShapes(m.shape,d);let v=g;s&&(v=r.expandShapeToKeepDim(g,c));const C=function(e,t,a,r){const o=n.sizeFromShape(t),s=Es({inputs:{x:e},attrs:{shape:[n.sizeFromShape(e.shape)/o,o]},backend:r}),i=Os(s,"float32","mean",r),u=Es({inputs:{x:i},attrs:{shape:a},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),u}(m,b,v,u);for(const e of x)u.disposeIntermediateTensorInfo(e);return C}};const ql={kernelName:hn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{axis:i,keepDims:u}=o,l=s.shape.length,c=n.parseAxisParam(i,s.shape);let d=c;const p=r.getAxesPermutation(d,l);let h=s;null!=p&&(h=Us({inputs:{x:s},backend:a,attrs:{perm:p}}),d=r.getInnerMostAxes(d.length,s.shape.length)),r.assertAxesAreInnerMostDims("min",d,l);const[f,x]=r.computeOutAndReduceShapes(h.shape,d),m=Es({inputs:{x:h},backend:a,attrs:{shape:[-1,n.sizeFromShape(x)]}}),g=Os(m,m.dtype,"min",a);let b;if(u){b=Es({inputs:{x:g},backend:a,attrs:{shape:r.expandShapeToKeepDim(f,c)}})}else b=Es({inputs:{x:g},backend:a,attrs:{shape:f}});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),null!=p&&a.disposeIntermediateTensorInfo(h),b}},Yl={kernelName:fn,backendName:"webgl",kernelFunc:Cs({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:vo})};class Ql{constructor(e,n,t){this.variableNames=["x"],this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const a=e.length,r=Ga(a),o=n.map((e=>e[0])).join(","),s=n.map(((n,t)=>n[0]+e[t])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),u="reflect"===t?0:1;this.userCode=1!==a?`\n      ${r} start = ${r}(${o});\n      ${r} end = ${r}(${s});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${a}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${i}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Zl{constructor(e,n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const a=e.length,r=Ga(a),o=n.map((e=>e[0])).join(","),s=n.map(((n,t)=>n[0]+e[t])).join(","),i=Go("rc",a),u=Go("source",a),l=`${i[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${u.slice(-2).join()})`,d="reflect"===t?0:1;let p="";if(1===a){const e=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[a-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;p=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${i[a-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${i[a-2]} += 1;\n        if(${i[a-2]} < ${this.outputShape[a-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${i[a-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${o});\n      const ${r} end = ${r}(${s});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const Jl={kernelName:xn,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:a})=>{const{x:r}=e,{paddings:o,mode:s}=a,i=t().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zl(r.shape,o,s):new Ql(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)}},ec={kernelName:mn,backendName:"webgl",kernelFunc:Cs({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})};class nc{constructor(e,n,t){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${n-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${n-1}));\n      }\n    `}}const tc=Cs({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),ac={kernelName:gn,backendName:"webgl",kernelFunc:tc},rc="return a - b;",oc=Cs({opSnippet:rc,packedOpSnippet:rc,supportsComplex:!0,cpuKernelImpl:Po}),sc={kernelName:bn,backendName:"webgl",kernelFunc:oc};function ic(e){const{inputs:t,backend:a,attrs:o}=e,{logits:s}=t,{dim:i}=o,u=n.parseAxisParam([i],s.shape),l=Bl({inputs:{x:s},backend:a,attrs:{reductionIndices:u,keepDims:!1}}),c=r.expandShapeToKeepDim(l.shape,u),d=Es({inputs:{x:l},backend:a,attrs:{shape:c}}),p=oc({inputs:{a:s,b:d},backend:a}),h=Xu({inputs:{x:p},backend:a}),f=Ps({inputs:{x:h},backend:a,attrs:{axis:u,keepDims:!1}}),x=Es({inputs:{x:f},backend:a,attrs:{shape:c}}),m=tc({inputs:{a:h,b:x},backend:a});return a.disposeIntermediateTensorInfo(l),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(x),m}const uc={kernelName:vn,backendName:"webgl",kernelFunc:ic};const lc={kernelName:Cn,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{logits:r}=n,{numSamples:o,seed:s,normalized:i}=a,u=i?r:ic({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],d=new nc(l,c,o),p=[[s]],h=t.runWebGLProgram(d,[u],"int32",p);return i||t.disposeIntermediateTensorInfo(u),h}};const cc={kernelName:$n,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a}=e,{x:r}=n;if(a.shouldExecuteOnCPU([r])){const e=a.texData.get(r.dataId),[n,t]=$o(e.values,r.shape,r.dtype);return a.makeTensorInfo(t,r.dtype,n)}let o;return o=t().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Zo(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Yo(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),a.runWebGLProgram(o,[r],r.dtype)}},dc=l.nonMaxSuppressionV3Impl;const pc={kernelName:In,backendName:"webgl",kernelFunc:function(e){r.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:a}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=a,c=t.readSync(o.dataId),d=t.readSync(s.dataId),{selectedIndices:p}=dc(c,d,i,u,l);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}},hc=l.nonMaxSuppressionV4Impl;const fc={kernelName:yn,backendName:"webgl",kernelFunc:function(e){r.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:a}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:c}=a,d=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:h,validOutputs:f}=hc(d,p,i,u,l,c);return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}},xc=l.nonMaxSuppressionV5Impl;const mc={kernelName:wn,backendName:"webgl",kernelFunc:function(e){r.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:a}=e,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=a,d=t.readSync(o.dataId),p=t.readSync(s.dataId),h=i,f=u,x=l,m=c,{selectedIndices:g,selectedScores:b}=xc(d,p,h,f,x,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class gc{constructor(e,n,t,a){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${a}), float(${t}),\n                      float(index == coords.y)));\n      }\n    `}}const bc={kernelName:Sn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:a,attrs:r}=e,{indices:o}=t,{depth:s,onValue:i,offValue:u}=r,l=n.sizeFromShape(o.shape),c=new gc(l,s,i,u),d=Es({inputs:{x:o},backend:a,attrs:{shape:[l]}}),p=a.runWebGLProgram(c,[d],o.dtype);a.disposeIntermediateTensorInfo(d);const h=Es({inputs:{x:p},backend:a,attrs:{shape:[...o.shape,s]}});return a.disposeIntermediateTensorInfo(p),h}};function vc(e){const{inputs:n,backend:t}=e,{x:a}=n;if("complex64"===a.dtype){const e=_i({inputs:{input:a},backend:t}),n=vc({inputs:{x:e},backend:t}),r=Ki({inputs:{input:a},backend:t}),o=vc({inputs:{x:r},backend:t}),s=ds({inputs:{real:n,imag:o},backend:t});return t.disposeIntermediateTensorInfo(e),t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),s}return nl({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:t})}const Cc={kernelName:Rn,backendName:"webgl",kernelFunc:vc};const $c={kernelName:kn,backendName:"webgl",kernelFunc:function e(n){const{inputs:t,backend:a}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const n=_i({inputs:{input:r},backend:a}),t=e({inputs:{x:n},backend:a}),o=Ki({inputs:{input:r},backend:a}),s=vc({inputs:{x:o},backend:a}),i=ds({inputs:{real:t,imag:s},backend:a});return a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(s),i}return nl({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const Ic={kernelName:Tn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:r}=e,{axis:o}=r;if(1===t.length)return ju({inputs:{input:t[0]},backend:a,attrs:{dim:o}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{n.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),n.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=Qi({inputs:t.map((e=>{const n=ju({inputs:{input:e},backend:a,attrs:{dim:o}});return u.push(n),n})),backend:a,attrs:{axis:o}});return u.forEach((e=>a.disposeIntermediateTensorInfo(e))),l}};class yc{constructor(e,n,t){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const a=e.length,r=Ga(a),o=n.map((e=>e[0])).join(","),s=n.map(((n,t)=>n[0]+e[t])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?`\n      ${r} start = ${r}(${o});\n      ${r} end = ${r}(${s});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${s};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class wc{constructor(e,n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map(((n,t)=>n[0]+e[t]+n[1]));const a=e.length,r=Ga(a),o=n.map((e=>e[0])).join(","),s=n.map(((n,t)=>n[0]+e[t])).join(","),i=Go("rc",a),u=Go("source",a),l=`${i[a-1]} < ${this.outputShape[a-1]}`,c=1===a?"source":`vec2(${u.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${i[a-1]} += 1;\n       if(${l}) {\n      `,1===a?"":`}\n       rc = outputLoc;\n       ${i[a-2]} += 1;\n       if(${i[a-2]} < ${this.outputShape[a-2]}) {`,1===a?"":`  ${i[a-1]} += 1;\n         if(${l}) {`],p=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let h="";for(let e=0,n=1===a?2:4;e<n;e++)h+=`\n        ${d[e]}\n        if (${p}) {\n          result[${e}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;h+=1===a?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${o});\n      const ${r} end = ${r}(${s});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const Sc=e=>{const{inputs:a,backend:r,attrs:o}=e,{x:s}=a,{paddings:i,constantValue:u}=o;if(0===n.sizeFromShape(s.shape)){return nl({backend:r,attrs:{shape:i.map(((e,n)=>e[0]+s.shape[n]+e[1])),value:u,dtype:s.dtype}})}const l=t().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wc(s.shape,i,u):new yc(s.shape,i,u),c=[[u]];return r.runWebGLProgram(l,[s],s.dtype,c)},Rc={kernelName:En,backendName:"webgl",kernelFunc:Sc},kc={kernelName:Nn,backendName:"webgl",kernelFunc:Cs({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})};const Tc={kernelName:An,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{axis:i,keepDims:u}=o,l=s.shape.length,c=[],d=n.parseAxisParam(i,s.shape);let p=d;const h=r.getAxesPermutation(p,l);let f,x=s;if(null!=h&&(x=Us({inputs:{x:s},backend:a,attrs:{perm:h}}),p=r.getInnerMostAxes(p.length,l),c.push(x)),r.assertAxesAreInnerMostDims("prod",p,l),a.shouldExecuteOnCPU([x])){const e=a.texData.get(x.dataId).values,{outVals:n,outShape:t,outDtype:r}=yo(x.shape,x.dtype,e,p);f=a.makeTensorInfo(t,r,n)}else{const[e,t]=r.computeOutAndReduceShapes(x.shape,p),o=n.sizeFromShape(t),i=Es({inputs:{x:x},backend:a,attrs:{shape:[-1,o]}}),u=Os(i,y(s.dtype),"prod",a);f=Es({inputs:{x:u},backend:a,attrs:{shape:e}}),c.push(i),c.push(u)}if(u){c.push(f);const e=r.expandShapeToKeepDim(f.shape,d);f=Es({inputs:{x:f},backend:a,attrs:{shape:e}})}return c.forEach((e=>a.disposeIntermediateTensorInfo(e))),f}},Ec=e=>{const{backend:n,attrs:t}=e,{start:a,stop:r,step:o,dtype:s}=t,i=wo(a,r,o,s);return n.makeTensorInfo([i.length],s,i)},Nc={kernelName:Fn,backendName:"webgl",kernelFunc:Ec},Ac={kernelName:On,backendName:"webgl",kernelFunc:vs({opSnippet:"return 1.0 / x;"})},Fc={kernelName:_n,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"})},Oc={kernelName:Dn,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"})};class _c{constructor(e,n,t,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,u]=e;this.outputShape=[o,n,t,u];const l=[a&&n>1?s-1:s,a&&t>1?i-1:i],c=[a&&n>1?n-1:n,a&&t>1?t-1:t];let d;d=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Dc{constructor(e,n,t,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,u]=e;this.outputShape=[o,n,t,u];const l=[a&&n>1?s-1:s,a&&t>1?i-1:i],c=[a&&n>1?n-1:n,a&&t>1?t-1:t];let d;d=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${t-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Lc={kernelName:Ln,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:u}=r,[l,c]=u,d=t().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Dc(o.shape,l,c,s,i):new _c(o.shape,l,c,s,i);return a.runWebGLProgram(d,[o],"float32")}};class Pc{constructor(e,n,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,a,r]=n,[,o,s]=e,i=[t&&o>1?a-1:a,t&&s>1?r-1:r],u=[t&&o>1?o-1:o,t&&s>1?s-1:s],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Bc={kernelName:Pn,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{images:r,dy:o}=n,{alignCorners:s}=a,i=new Pc(o.shape,r.shape,s);return t.runWebGLProgram(i,[o],o.dtype)}};class Uc{constructor(e,n,t,a,r){this.variableNames=["A"],this.outputShape=[];const[o,s,i,u]=e;this.outputShape=[o,n,t,u];const l=[a&&n>1?s-1:s,a&&t>1?i-1:i],c=[a&&n>1?n-1:n,a&&t>1?t-1:t],d=a?"0.5":"0.0";let p;p=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${s}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Vc{constructor(e,n,t,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,s,i,u]=e;this.outputShape=[o,n,t,u];const l=[a&&n>1?s-1:s,a&&t>1?i-1:i],c=[a&&n>1?n-1:n,a&&t>1?t-1:t],d=a?"0.5":"0.0";let p;p=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${s}.0, ${i}.0,\n                                     ${i}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${t-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Wc={kernelName:Bn,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:a,attrs:r}=e,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:u}=r,[l,c]=u,d=t().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Vc(o.shape,l,c,s,i):new Uc(o.shape,l,c,s,i);return a.runWebGLProgram(d,[o],o.dtype)}};class Mc{constructor(e,n,t){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,a,r]=n,[,o,s]=e,i=[t&&o>1?a-1:a,t&&s>1?r-1:r],u=[t&&o>1?o-1:o,t&&s>1?s-1:s],l=i[0]/u[0],c=i[1]/u[1],d=1/l,p=1/c,h=2*Math.ceil(d)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${s}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${i[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${i[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${a}) - 1),\n                ${t} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${t} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Gc={kernelName:Un,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{images:r,dy:o}=n,{alignCorners:s}=a,i=new Mc(o.shape,r.shape,s);return t.runWebGLProgram(i,[o],o.dtype)}};class zc{constructor(e,n){this.variableNames=["x"];const t=e.length;if(t>4)throw new Error(`WebGL backend: Reverse of rank-${t} tensor is not yet supported`);if(this.outputShape=e,1===t)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const a=e.map(((t,a)=>(t=>-1!==n.indexOf(t)&&1!==e[t]?`${e[t]} - coords[${t}] - 1`:`coords[${t}]`)(a))).join(","),r=Ga(t);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class Xc{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const t=e.length;if(t>4)throw new Error(`WebGL backend: Reverse of rank-${t} tensor is not yet supported`);this.outputShape=e;const a=Go("rc",t),r=`${a[t-1]} + 1 < ${this.outputShape[t-1]}`,o=`${a[t-2]} + 1 < ${this.outputShape[t-2]}`,s=Ga(t);function i(t){const a=e.map(((a,r)=>function(t,a){return-1!==n.indexOf(t)&&1!==e[t]?`${e[t]} - ${a[t]} - 1`:`${a[t]}`}(r,t)));return`getChannel(getX(${a.join(",")}), vec2(${a.slice(-2).join(",")}))`}this.userCode=1===t?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${s} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return i(e)}(a.slice())};\n          if(${r}){\n            result.g = ${function(e){return e[t-1]="("+e[t-1]+" + 1)",i(e)}(a.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[t-2]="("+e[t-2]+" + 1)",i(e)}(a.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[t-1]="("+e[t-1]+" + 1)",e[t-2]="("+e[t-2]+" + 1)",i(e)}(a.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Hc={kernelName:Vn,backendName:"webgl",kernelFunc:function(e){const{inputs:a,backend:r,attrs:o}=e,{x:s}=a,{dims:i}=o,u=s.shape.length,l=n.parseAxisParam(i,s.shape);if(0===u)return ls({inputs:{x:s},backend:r});const c=t().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Xc(s.shape,l):new zc(s.shape,l);return r.runWebGLProgram(c,[s],s.dtype)}};class jc{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const t=e[1],a=e[2];this.outputShape=e;let r="";r="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${t}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Kc={kernelName:Wn,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{image:a}=e,{radians:o,fillValue:s,center:i}=n,u=t,l=new jc(a.shape,s),[c,d]=r.getImageCenter(i,a.shape[1],a.shape[2]),p=[[c,d,Math.sin(o),Math.cos(o)]];return u.runWebGLProgram(l,[a],a.dtype,p)}},qc={kernelName:Mn,backendName:"webgl",kernelFunc:vs({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"})},Yc={kernelName:Gn,backendName:"webgl",kernelFunc:vs({opSnippet:"return inversesqrt(x);",cpuKernelImpl:So})};class Qc{constructor(e,n,t,a,r,o,s=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const i=Ga(r.length),u=Ga(o.length);let l="";1===t?l="i":2===t&&(l="i, j");const c=`getIndices(${l})`;let d="";1===a?d="i":2===a&&(d="i, coords[1]");const p=`getUpdates(${d})`,h=n>1?"strides[j]":"strides";this.userCode=`\n        ${i} strides = ${i}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${n}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const Zc={kernelName:zn,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{indices:o,updates:s}=n,{shape:i}=a,{sliceRank:u,numUpdates:l,sliceSize:c,strides:d,outputSize:p}=r.calculateShapes(s,o,i),h=[p/c,c];if(0===p)return t.makeTensorInfo(i,o.dtype);const f=Es({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),x=Es({inputs:{x:s},backend:t,attrs:{shape:[l,c]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new Qc(l,u,f.shape.length,x.shape.length,d,h),b=t.runWebGLProgram(g,[x,f,m],x.dtype),v=Es({inputs:{x:b},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(m),v}};class Jc{constructor(e,n,t){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=n,t>4)throw Error(`Where for rank ${t} is not yet supported`);if(1===t)r="resRC",a="resRC";else{const t=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],s=[];for(let a=0;a<n.length;a++)s.push(`${t[a]}`),a<e&&o.push(`${t[a]}`);a=o.join(),r=s.join()}const o=Ga(t);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${a});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const ed={kernelName:Xn,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{condition:a,t:r,e:o}=n,i=new Jc(a.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(i,[a,r,o],s(r.dtype,o.dtype))}},nd={kernelName:Hn,backendName:"webgl",kernelFunc:vs({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${r.SELU_SCALEALPHA};\n  float scale = ${r.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`})},td={kernelName:jn,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ro})},ad={kernelName:Kn,backendName:"webgl",kernelFunc:vs({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"})},rd={kernelName:qn,backendName:"webgl",kernelFunc:vs({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"})},od={kernelName:Yn,backendName:"webgl",kernelFunc:vs({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"})},sd={kernelName:Qn,backendName:"webgl",kernelFunc:vs({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"})},id={kernelName:Zn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{blockShape:i,paddings:u}=o;n.assert(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const l=i.reduce(((e,n)=>e*n)),c=[[0,0]];c.push(...u);for(let e=1+i.length;e<s.shape.length;++e)c.push([0,0]);const d=[],p=Sc({inputs:{x:s},backend:a,attrs:{paddings:c,constantValue:0}}),h=r.getReshaped(p.shape,i,l,!1),f=r.getPermuted(h.length,i.length,!1),x=r.getReshapedPermuted(p.shape,i,l,!1),m=Es({inputs:{x:p},backend:a,attrs:{shape:h}}),g=Us({inputs:{x:m},backend:a,attrs:{perm:f}}),b=Es({inputs:{x:g},backend:a,attrs:{shape:x}});return d.push(p),d.push(m),d.push(g),d.forEach((e=>a.disposeIntermediateTensorInfo(e))),b}};const ud={kernelName:Jn,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{indices:a,values:r,denseShape:o,defaultValue:s}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==a.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${a.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==s.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${s.shape}`);const i=t.readSync(a.dataId),u=t.readSync(r.dataId),l=t.readSync(o.dataId),c=t.readSync(s.dataId)[0],[d,p,h,f,x]=Eo(i,a.shape,a.dtype,u,r.dtype,l,c);return[t.makeTensorInfo(p,a.dtype,d),t.makeTensorInfo([p[0]],r.dtype,h),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),t.makeTensorInfo([x.length],a.dtype,new Int32Array(x))]}};const ld={kernelName:et,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{inputIndices:a,inputShape:r,newShape:o}=n;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const s=Array.from(t.readSync(r.dataId)),i=t.readSync(a.dataId),u=Array.from(t.readSync(o.dataId)),[l,c,d]=No(i,a.shape,a.dtype,s,u);return[t.makeTensorInfo(c,a.dtype,l),t.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};const cd={kernelName:nt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{data:a,indices:r,segmentIds:o}=n;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const s=t.readSync(a.dataId),i=t.readSync(r.dataId),u=t.readSync(o.dataId),[l,c]=Ao(s,a.shape,a.dtype,i,u,!0);return t.makeTensorInfo(c,a.dtype,l)}};const dd={kernelName:tt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{data:a,indices:r,segmentIds:o}=n;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const s=t.readSync(a.dataId),i=t.readSync(r.dataId),u=t.readSync(o.dataId),[l,c]=Ao(s,a.shape,a.dtype,i,u);return t.makeTensorInfo(c,a.dtype,l)}};const pd={kernelName:at,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{sparseIndices:o,sparseValues:s,defaultValue:i}=n,{outputShape:u}=a,{sliceRank:l,numUpdates:c,strides:d,outputSize:p}=r.calculateShapes(s,o,u),h=new Qc(c,l,o.shape.length,s.shape.length,d,[p,1],!1),f=t.runWebGLProgram(h,[s,o,i],s.dtype),x=Es({inputs:{x:f},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(f),x}};const hd={kernelName:rt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s}=t,{numOrSizeSplits:i,axis:u}=o,l=n.parseAxisParam(u,s.shape)[0],c=r.prepareSplitSize(s,i,l),d=s.shape.length,p=new Array(d).fill(0),h=s.shape.slice();return c.map((e=>{const n=[...h];n[l]=e;const t=ki({inputs:{x:s},backend:a,attrs:{begin:p,size:n}});return p[l]+=e,t}))}},fd="return sqrt(x);",xd={kernelName:ot,backendName:"webgl",kernelFunc:vs({opSnippet:fd,packedOpSnippet:fd,cpuKernelImpl:Fo})},md={kernelName:st,backendName:"webgl",kernelFunc:vs({opSnippet:"return x * x;"})},gd={kernelName:it,backendName:"webgl",kernelFunc:Cs({opSnippet:"return (a - b) * (a - b);",packedOpSnippet:"return (a - b) * (a - b);"})};const bd={kernelName:ut,backendName:"webgl",kernelFunc:function({inputs:e,attrs:n,backend:t}){const{x:a}=e,r=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,o=new Yo(a.shape,r);return t.runWebGLProgram(o,[a],a.dtype)}};class vd{constructor(e,n,t){this.variableNames=["x"],this.outputShape=t;const a=t.length,r=Ga(t.length),o=Ga(t.length);let s="";if(1===a)s="coords * strides + begin";else{let e=0;s=t.map(((n,a)=>(e++,1===t.length?`coords * strides[${a}] + begin[${a}]`:`coords[${e-1}] * strides[${a}] + begin[${a}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${n});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}const Cd={kernelName:lt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:r}=e,{x:s}=t,{begin:u,end:l,strides:c,beginMask:d,endMask:p,ellipsisMask:h,newAxisMask:f,shrinkAxisMask:x}=r,{finalShapeSparse:m,finalShape:g,isIdentity:b,sliceDim0:v,isSimpleSlice:C,begin:$,end:I,strides:y}=i.sliceInfo(s.shape,u,l,c,d,p,h,f,x);let w;if(b)w=Es({inputs:{x:s},backend:a,attrs:{shape:g}});else if(v||C){n.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=i.computeOutShape($,I,y),t=ki({inputs:{x:s},backend:a,attrs:{begin:$,size:e}});w=Es({inputs:{x:t},backend:a,attrs:{shape:g}}),a.disposeIntermediateTensorInfo(t)}else{if(a.shouldExecuteOnCPU([s])){const e=a.readSync(s.dataId),n=o(s.shape,s.dtype,e),t=Oo(m,n,y,$);w=a.makeTensorInfo(g,s.dtype,t.values)}else{const e=new vd($,y,m);w=a.runWebGLProgram(e,[s],s.dtype)}}const S=Es({inputs:{x:w},backend:a,attrs:{shape:g}});return a.disposeIntermediateTensorInfo(w),S}};const $d={kernelName:ct,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{separator:r,nGramWidths:o,leftPad:s,rightPad:i,padWidth:u,preserveShortSequences:l}=a,{data:c,dataSplits:d}=n,p=t.readSync(c.dataId),h=t.readSync(d.dataId),[f,x]=_o(p,h,r,o,s,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(d.shape,"int32",x)]}};const Id={kernelName:dt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{skipEmpty:r}=a,{input:o,delimiter:s}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==s.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);const i=t.readSync(o.dataId),u=t.readSync(s.dataId)[0],[l,c,d]=Do(i,u,r),p=c.length;return[t.makeTensorInfo([p,2],"int32",l),t.makeTensorInfo([p],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(d))]}};const yd={kernelName:pt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{numBuckets:r}=a,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const s=t.readSync(o.dataId),i=Lo(s,r);return t.makeTensorInfo(o.shape,"int32",i)}},wd={kernelName:ht,backendName:"webgl",kernelFunc:vs({opSnippet:"return tan(x);"})},Sd={kernelName:ft,backendName:"webgl",kernelFunc:vs({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"})};class Rd{constructor(e,n){this.variableNames=["A"];const t=new Array(e.length);for(let a=0;a<t.length;a++)t[a]=e[a]*n[a];this.outputShape=t,this.rank=t.length;const a=Ga(this.rank),r=function(e){const n=e.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${e[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let n=0;n<e.length;n++)a.push(`imod(${t[n]}, ${e[n]})`);return a.join()}(e);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function kd(e){const{inputs:t,backend:a,attrs:r}=e,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const e=a.readSync(s.dataId),t="string"===s.dtype?e.map((e=>n.decodeString(e))):e,r=o(s.shape,s.dtype,t),u=Bo(r,i);return a.makeTensorInfo(u.shape,u.dtype,u.values)}const u=new Rd(s.shape,i);return a.runWebGLProgram(u,[s],s.dtype)}const Td={kernelName:xt,backendName:"webgl",kernelFunc:kd};class Ed{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Nd{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Ad(e,n){null!==n&&e.disposeIntermediateTensorInfo(n)}function Fd(e){let n=1;for(;n<e;)n*=2;return n}const Od={kernelName:mt,backendName:"webgl",kernelFunc:function(e){const{inputs:a,backend:r,attrs:o}=e,{x:s}=a,{k:i,sorted:u}=o,l=t().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=t().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=s.shape,p=d[d.length-1];if(r.shouldExecuteOnCPU([s])||p<l||i>c){const e=r.readSync(s.dataId),[n,t]=Uo(e,d,s.dtype,i,u);return[r.makeTensorInfo(n.shape,n.dtype,n.values),r.makeTensorInfo(t.shape,t.dtype,t.values)]}if(0===i)return d[d.length-1]=0,[r.makeTensorInfo(d,s.dtype,[]),r.makeTensorInfo(d,"int32",[])];if(1===p)return[s,nl({attrs:{shape:d,dtype:"int32",value:0},backend:r})];const h=r.texData.get(s.dataId),f=null!==h&&h.isPacked,x=f?r.unpackTensor(s):s,m=n.sizeFromShape(d)/p,g=Es({inputs:{x:x},attrs:{shape:[m,p]},backend:r});f&&Ad(r,x);const b=Fd(i),v=Fd(p);let C=null;const $=()=>null===C?[g,g]:[g,C],I=(e,n,t)=>{const a=$(),o=new Ed(t),s=[[p],[null===C?1:0],[Number.NEGATIVE_INFINITY],[e],[n]],i=C;C=r.runWebGLProgram(o,a,"int32",s),Ad(r,i)};for(let e=1;e<b;e*=2){const n=2*e;for(let t=e;t>=1;t/=2)I(n,t,[m,v])}for(let e=v;e>b;e/=2){const n=$(),t=new Nd([m,e/2]),a=[[p],[null===C?1:0],[b]],o=C;C=r.runWebGLProgram(t,n,"int32",a),Ad(r,o);const s=b/2,i=2*s;for(let e=s;e>=1;e/=2)I(i,e,C.shape)}let y=C;C=ki({inputs:{x:C},backend:r,attrs:{begin:0,size:[m,i]}}),Ad(r,y);let w=gl({inputs:{x:g,indices:C},backend:r,attrs:{axis:1,batchDims:1}});Ad(r,g);const S=d.slice(0,-1);S.push(i),y=C,C=Es({inputs:{x:C},attrs:{shape:S},backend:r}),Ad(r,y);const R=w;return w=Es({inputs:{x:w},attrs:{shape:S},backend:r}),Ad(r,R),[w,C]}};class _d{constructor(e,n,t,a,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const s="nearest"===t?1:2;let i;switch(a){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${n}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${s} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Dd={kernelName:gt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{image:r,transforms:o}=n,{interpolation:s,fillMode:i,fillValue:u,outputShape:l}=a,[c,d,p,h]=r.shape,[f,x]=null!=l?l:[d,p],m=new _d(d,p,s,i,u,[c,f,x,h]);return t.runWebGLProgram(m,[r,o],"float32")}};const Ld={kernelName:bt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,attrs:t,backend:a}=e,{axis:r}=t,{x:o}=n;ya(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const s=a.readSync(o.dataId),{outputValues:i,outputShape:u,indices:l}=Wo(s,r,o.shape,o.dtype);return[a.makeTensorInfo(u,o.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const Pd={kernelName:vt,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{value:r}=n;let{axis:o}=a;o<0&&(o+=r.shape.length);const s=r,i=s.shape.length,u=r.shape[o],l=new Array(i-1);let c=0;for(let e=0;e<i;e++)e!==o&&(l[c++]=s.shape[e]);const d=[],p=new Array(i).fill(0),h=s.shape.slice();h[o]=1;const f=new Array(u);for(let e=0;e<f.length;e++){p[o]=e;const n=ki({inputs:{x:s},backend:t,attrs:{begin:p,size:h}}),a=Es({inputs:{x:n},backend:t,attrs:{shape:l}});f[e]=a,d.push(n)}return d.forEach((e=>t.disposeIntermediateTensorInfo(e))),f}};class Bd{constructor(e,n){this.variableNames=["x","segmentIds"];const t=e.windowSize,a=e.batchSize,r=e.inSize,o=e.numSegments,s=o*Math.ceil(r/t);this.outputShape=[a,s];const i=4*Math.floor(t/4),u=t%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%t>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let d="";r%t>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${t}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Ud=[Ms,zs,Xs,Hs,Ks,Qs,Zs,Js,oi,si,ii,ui,li,ci,di,fi,xi,bi,vi,Ci,yi,Ei,Ni,Ai,Li,Bi,Wi,ps,zi,Zi,ru,lu,cu,du,pu,hu,fu,xu,gu,$u,Su,Ru,Tu,Au,_u,Du,Pu,Uu,Vu,Wu,Mu,Gu,zu,Hu,Ku,Yu,Ju,tl,rl,sl,il,cl,pl,hl,xl,bl,vl,Cl,cs,$l,qi,Il,yl,wl,xs,Sl,Rl,kl,Tl,El,Nl,Al,Fl,Dl,Pl,Ul,Vl,Wl,Ml,Xl,Hl,jl,Kl,ql,Yl,Jl,ec,lc,Ts,cc,pc,fc,mc,Oi,bc,$c,Ic,Rc,kc,bs,Tc,Nc,Di,ac,Ac,Fc,Oc,Ns,Lc,Bc,Wc,Gc,Hc,Kc,qc,Yc,Zc,ed,nd,td,ad,rd,od,Ti,uc,sd,id,ud,ld,cd,dd,pd,hd,xd,md,gd,bd,Cd,$d,Id,yd,sc,Bs,wd,Sd,Td,Od,Dd,Vs,Ld,Pd,{kernelName:Ct,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:a,attrs:o}=e,{x:s,segmentIds:i}=t,{numSegments:u}=o,l=s.shape.length,c=[];let d=0;const p=r.getAxesPermutation([d],l);let h=s;null!=p&&(h=Us({inputs:{x:s},backend:a,attrs:{perm:p}}),c.push(h),d=r.getInnerMostAxes(1,l)[0]);const f=r.segment_util.computeOutShape(h.shape,d,u),x=n.sizeFromShape([h.shape[d]]),m=Es({inputs:{x:h},backend:a,attrs:{shape:[-1,x]}});c.push(m);const g=y(s.dtype),b=(e,n,t,o,s)=>{const i=e.shape[0],u=e.shape[1],l=r.segment_util.segOpComputeOptimalWindowSize(u,s),d=new Bd({windowSize:l,inSize:u,batchSize:i,numSegments:s},n),p=a.compileAndRun(d,[e,t],o);if(c.push(p),p.shape[1]===s)return p;const h=Ec({backend:a,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=kd({inputs:{x:h},backend:a,attrs:{reps:[u/l]}});c.push(h),c.push(f);return b(p,n,f,o,s)},v=Es({inputs:{x:b(m,"unsortedSegmentSum",i,g,u)},backend:a,attrs:{shape:f}});let C=v;if(null!=p){c.push(v);const e=r.getUndoAxesPermutation(p);C=Us({inputs:{x:C},backend:a,attrs:{perm:e}})}return c.forEach((e=>a.disposeIntermediateTensorInfo(e))),C}},Cc];for(const e of Ud)$t(e);export{Sr as GPGPUContext,as as MathBackendWebGL,os as forceHalfFloat,wr as gpgpu_util,wt as setWebGLContext,rs as version_webgl,ss as webgl,wa as webgl_util};
//# sourceMappingURL=tf-backend-webgl.fesm.min.js.map
