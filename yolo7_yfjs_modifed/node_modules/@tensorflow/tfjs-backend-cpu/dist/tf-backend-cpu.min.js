/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,a){"object"==typeof exports&&"undefined"!=typeof module?a(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],a):a((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf,e.seedrandom)}(this,(function(e,a,t){"use strict";function r(e){if(e&&e.__esModule)return e;var a=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(a,t,r.get?r:{enumerable:!0,get:function(){return e[t]}})}})),a.default=e,a}var n=r(t),i=function(e,a){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,a){e.__proto__=a}||function(e,a){for(var t in a)a.hasOwnProperty(t)&&(e[t]=a[t])})(e,a)};function s(e,a,t,r){return new(t||(t=Promise))((function(n,i){function s(e){try{u(r.next(e))}catch(e){i(e)}}function o(e){try{u(r.throw(e))}catch(e){i(e)}}function u(e){var a;e.done?n(e.value):(a=e.value,a instanceof t?a:new t((function(e){e(a)}))).then(s,o)}u((r=r.apply(e,a||[])).next())}))}function o(e,a){var t,r,n,i,s={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function o(i){return function(o){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;s;)try{if(t=1,r&&(n=2&i[0]?r.return:i[0]?r.throw||((n=r.return)&&n.call(r),0):r.next)&&!(n=n.call(r,i[1])).done)return n;switch(r=0,n&&(i=[2&i[0],n.value]),i[0]){case 0:case 1:n=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,r=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!(n=s.trys,(n=n.length>0&&n[n.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!n||i[1]>n[0]&&i[1]<n[3])){s.label=i[1];break}if(6===i[0]&&s.label<n[1]){s.label=n[1],n=i;break}if(n&&s.label<n[2]){s.label=n[2],s.ops.push(i);break}n[2]&&s.ops.pop(),s.trys.pop();continue}i=a.call(e,s)}catch(e){i=[6,e],r=0}finally{t=n=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,o])}}}function u(e){var a="function"==typeof Symbol&&Symbol.iterator,t=a&&e[a],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(a?"Object is not iterable.":"Symbol.iterator is not defined.")}function d(e,a){var t="function"==typeof Symbol&&e[Symbol.iterator];if(!t)return e;var r,n,i=t.call(e),s=[];try{for(;(void 0===a||a-- >0)&&!(r=i.next()).done;)s.push(r.value)}catch(e){n={error:e}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(n)throw n.error}}return s}function l(){for(var e=[],a=0;a<arguments.length;a++)e=e.concat(d(arguments[a]));return e}function p(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&a.util.assert("complex64"!==e.dtype,(function(){return t+" does not support complex64 tensors in the CPU backend."}))}))}var c=a.kernel_impls.whereImpl,f=function(e){function t(){var t=e.call(this)||this;return t.blockSize=48,t.firstUse=!0,t.data=new a.DataStorage(t,a.engine()),t}return function(e,a){function t(){this.constructor=e}i(e,a),e.prototype=null===a?Object.create(a):(t.prototype=a.prototype,new t)}(t,e),t.prototype.nextDataId=function(){return t.nextDataId++},t.prototype.write=function(e,t,r){this.firstUse&&(this.firstUse=!1,a.env().get("IS_NODE")&&a.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var n={id:this.nextDataId()};return this.data.set(n,{values:e,dtype:r,refCount:1}),n},t.prototype.makeTensorInfo=function(e,t,r){var n;if("string"===t&&null!=r&&r.length>0&&a.util.isString(r[0])){var i=r.map((function(e){return a.util.encodeString(e)}));n=this.write(i,e,t)}else n=this.write(r,e,t);return{dataId:n,shape:e,dtype:t}},t.prototype.refCount=function(e){return this.data.has(e)?this.data.get(e).refCount:0},t.prototype.incRef=function(e){this.data.get(e).refCount++},t.prototype.decRef=function(e){this.data.has(e)&&this.data.get(e).refCount--},t.prototype.move=function(e,a,t,r,n){this.data.set(e,{values:a,dtype:r,refCount:n})},t.prototype.numDataIds=function(){return this.data.numDataIds()},t.prototype.read=function(e){return s(this,void 0,void 0,(function(){return o(this,(function(a){return[2,this.readSync(e)]}))}))},t.prototype.readSync=function(e){var t=this.data.get(e),r=t.dtype,n=t.complexTensorInfos;if("complex64"===r){var i=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return a.backend_util.mergeRealAndImagArrays(i,s)}return this.data.get(e).values},t.prototype.bufferSync=function(e){var t=this.readSync(e.dataId),r=t;if("string"===e.dtype)try{r=t.map((function(e){return a.util.decodeString(e)}))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return a.buffer(e.shape,e.dtype,r)},t.prototype.makeOutput=function(e,t,r){var n=this.write(e,t,r);return a.engine().makeTensorFromDataId(n,t,r,this)},t.prototype.disposeData=function(e,a){if(void 0===a&&(a=!1),this.data.has(e)){if(this.data.get(e).refCount--,!a&&this.data.get(e).refCount>0)return!1;var t=this.data.get(e).complexTensorInfos;null!=t&&(this.disposeData(t.real.dataId,!0),this.disposeData(t.imag.dataId,!0)),this.data.delete(e)}return!0},t.prototype.disposeIntermediateTensorInfo=function(e){this.disposeData(e.dataId)},t.prototype.time=function(e){return s(this,void 0,void 0,(function(){var t;return o(this,(function(r){return t=a.util.now(),e(),[2,{kernelMs:a.util.now()-t}]}))}))},t.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},t.prototype.where=function(e){p([e],"where");var a=this.readSync(e.dataId);return c(e.shape,a)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.epsilon=function(){return e.prototype.epsilon.call(this)},t}(a.KernelBackend);function h(e){for(var a=new Float32Array(e.length),t=0;t<e.length;++t)a[t]=Math.abs(e[t]);return a}f.nextDataId=0;var m={kernelName:a.Abs,backendName:"cpu",kernelFunc:function(e){var t=e.inputs.x,r=e.backend;p(t,"abs");var n=new Float32Array(a.util.sizeFromShape(t.shape));return n=h(r.data.get(t.dataId).values),r.makeOutput(n,t.shape,t.dtype)}};function v(e){return function(t,r,n,i,s){var o=a.backend_util.assertAndGetBroadcastShape(t,r),u=o.length,d=a.util.computeStrides(o),l=a.util.sizeFromShape(o),p=a.util.getTypedArrayFromDType(s,l),c=t.length,f=r.length,h=a.util.computeStrides(t),m=a.util.computeStrides(r),v=a.backend_util.getBroadcastDims(t,o),k=a.backend_util.getBroadcastDims(r,o);if(v.length+k.length===0)for(var g=0;g<p.length;++g)p[g]=e(n[g%n.length],i[g%i.length]);else{var b=function(t){var r=a.util.indexToLoc(t,u,d),s=r.slice(-c);v.forEach((function(e){return s[e]=0}));var o=a.util.locToIndex(s,c,h),l=r.slice(-f);k.forEach((function(e){return l[e]=0}));var g=a.util.locToIndex(l,f,m);p[t]=e(n[o],i[g])};for(g=0;g<p.length;++g)b(g)}return[p,o]}}function k(e){var a=e.inputs,t=e.backend,r=a.real,n=a.imag,i=t.data.get(r.dataId).values,s=t.data.get(n.dataId).values,o=t.makeTensorInfo(r.shape,"complex64");return t.data.get(o.dataId).complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",i),imag:t.makeTensorInfo(n.shape,"float32",s)},o}var g={kernelName:a.Complex,backendName:"cpu",kernelFunc:k};function b(e,t,r){if(void 0===r&&(r="float32"),"complex64"===r)return k({inputs:{real:b(e,t,"float32"),imag:b(e,t,"float32")},backend:e});var n=a.util.makeZerosTypedArray(a.util.sizeFromShape(t),r);return e.makeTensorInfo(t,r,n)}function I(e){var a=e.inputs,t=e.backend,r=a.x;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var y={kernelName:a.Identity,backendName:"cpu",kernelFunc:I};function N(e){var a=e.inputs,t=e.backend,r=a.input,n=t.data.get(r.dataId).complexTensorInfos.real,i=t.data.get(n.dataId).values;return t.makeTensorInfo(n.shape,n.dtype,i)}var x={kernelName:a.Real,backendName:"cpu",kernelFunc:N};function S(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.dtype;if("complex64"===s){if("complex64"===i.dtype)return I({inputs:{x:i},backend:r});var o=b(r,i.shape,i.dtype),u=S({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),l=k({inputs:{real:u,imag:o},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),l}if("complex64"===i.dtype){var p=N({inputs:{input:i},backend:r}),l=S({inputs:{x:p},backend:r,attrs:{dtype:s}});return r.disposeIntermediateTensorInfo(p),l}if(!a.util.hasEncodingLoss(i.dtype,s))return{dataId:(l=I({inputs:{x:i},backend:r})).dataId,shape:l.shape,dtype:s};if("int32"===s){var c=r.data.get(i.dataId).values,f=Int32Array.from(c);return r.makeTensorInfo(i.shape,"int32",f)}if("bool"===s){var h=r.data.get(i.dataId).values,m=a.util.toTypedArray([0],i.dtype),g=d(v((function(e,a){return e!==a?1:0}))(i.shape,[],h,m,"bool"),2),y=g[0],x=g[1];return r.makeTensorInfo(x,"bool",y)}throw new Error("Error in Cast: failed to cast "+i.dtype+" to "+s)}var T={kernelName:a.Cast,backendName:"cpu",kernelFunc:S};function F(e,t,r,n){return null==r?function(r){var i=r.inputs,s=r.backend,o=i.a,u=i.b,l=s;p([o,u],e);var c=l.data.get(o.dataId).values,f=l.data.get(u.dataId).values,h="string"===o.dtype?a.backend_util.fromUint8ToStringArray(c):c,m="string"===o.dtype?a.backend_util.fromUint8ToStringArray(f):f,v=n||o.dtype,k=d(t(o.shape,u.shape,h,m,v),2),g=k[0],b=k[1];return l.makeTensorInfo(b,v,g)}:function(e){var a=e.inputs,i=e.backend,s=a.a,o=a.b,u=i;if("complex64"===s.dtype||"complex64"===o.dtype){var l=S({inputs:{x:s},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(l.dataId),c=p.complexTensorInfos.real,f=p.complexTensorInfos.imag,h=u.data.get(c.dataId).values,m=u.data.get(f.dataId).values,v=S({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(v.dataId),b=g.complexTensorInfos.real,I=g.complexTensorInfos.imag,y=u.data.get(b.dataId).values,N=u.data.get(I.dataId).values,x=d(r(s.shape,o.shape,h,m,y,N),3),T=x[0],F=x[1],M=x[2],A=u.makeTensorInfo(M,"float32",T),w=u.makeTensorInfo(M,"float32",F),D=k({inputs:{real:A,imag:w},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(A),u.disposeIntermediateTensorInfo(w),D}var _=u.data.get(s.dataId).values,E=u.data.get(o.dataId).values,z=n||s.dtype,W=d(t(s.shape,o.shape,_,E,z),2),C=W[0];M=W[1];return u.makeTensorInfo(M,z,C)}}function M(e){return function(t,r,n,i,s,o){var u=a.backend_util.assertAndGetBroadcastShape(t,r),d=a.util.sizeFromShape(u),l=u.length,p=a.util.computeStrides(u),c=a.util.getTypedArrayFromDType("float32",d),f=a.util.getTypedArrayFromDType("float32",d),h=a.backend_util.getBroadcastDims(t,u),m=a.backend_util.getBroadcastDims(r,u),v=a.backend_util.mergeRealAndImagArrays(n,i),k=a.backend_util.mergeRealAndImagArrays(s,o),g=t.length,b=a.util.computeStrides(t),I=r.length,y=a.util.computeStrides(r);if(h.length+m.length===0)for(var N=0;N<c.length;N++){var x=N%v.length,S=N%k.length,T=e(v[2*x],v[2*x+1],k[2*S],k[2*S+1]);c[N]=T.real,f[N]=T.imag}else{var F=function(t){var r=a.util.indexToLoc(t,l,p),n=r.slice(-g);h.forEach((function(e){return n[e]=0}));var i=a.util.locToIndex(n,g,b),s=r.slice(-I);m.forEach((function(e){return s[e]=0}));var o=a.util.locToIndex(s,I,y),u=e(v[2*i],v[2*i+1],k[2*o],k[2*o+1]);c[t]=u.real,f[t]=u.imag};for(N=0;N<c.length;N++)F(N)}return[c,f,u]}}var A=v((function(e,a){return e+a})),w=M((function(e,a,t,r){return{real:e+t,imag:a+r}})),D=F(a.Add,A,w),_={kernelName:a.Add,backendName:"cpu",kernelFunc:D};function E(e,t,r,n,i){for(var s=a.util.sizeFromShape(n),o=a.util.makeZerosTypedArray(i,r),u=0;u<e.length;u++){var d=e[u];if(d<0)throw new Error("Input x must be non-negative!");d>=i||(o[d]+=s>0?t[u]:1)}return o}function z(e,t,r,n){void 0===n&&(n=!1);for(var i=e.shape[0],s=e.shape[1],o=a.buffer([i,r],t.dtype),u=0;u<i;u++)for(var d=0;d<s;d++){var l=e.get(u,d);if(l<0)throw new Error("Input x must be non-negative!");l>=r||(n?o.set(1,u,l):t.size>0?o.set(o.get(u,l)+t.get(u,d),u,l):o.set(o.get(u,l)+1,u,l))}return o}function W(e){return function(t,r,n){for(var i=a.util.getTypedArrayFromDType(r,t.length),s=0;s<t.length;++s)i[s]=e(t[s],n);return i}}function C(e,t,r){return function(n){var i=n.inputs,s=n.attrs,o=n.backend,u=i.x;if(p(u,e),"string"===u.dtype||"string"===r)throw new Error("unaryKernelFunc does not support string input/output");for(var d=o,l=d.data.get(u.dataId).values,c=a.util.sizeFromShape(u.shape),f=r||u.dtype,h=a.util.getArrayFromDType(f,c),m=0;m<c;++m)h[m]=t(l[m],s);return d.makeTensorInfo(u.shape,f,h)}}function H(e,a,t){return function(r){var n=r.inputs,i=r.attrs,s=r.backend,o=n.x;if(p(o,e),"string"===o.dtype||"string"===t)throw new Error("unaryKernelFunc does not support string input/output");var u=s,d=u.data.get(o.dataId).values,l=t||o.dtype,c=a(d,l,i);return u.makeTensorInfo(o.shape,l,c)}}var P=W((function(e){return Math.ceil(e)})),R=H(a.Ceil,P),B={kernelName:a.Ceil,backendName:"cpu",kernelFunc:R};function O(e,t,r,n){var i=a.util.getArrayFromDType(r,a.util.sizeFromShape(t));if(n&&"string"!==r){var s=0;e.forEach((function(e){var t=a.util.sizeFromShape(e.shape);i.set(e.vals,s),s+=t}))}else{var o=0;e.forEach((function(e){for(var n="string"===r?a.backend_util.fromUint8ToStringArray(e.vals):e.vals,s=0,u=0;u<e.shape[0];++u)for(var d=u*t[1]+o,l=0;l<e.shape[1];++l)i[d+l]=n[s++];o+=e.shape[1]}))}return i}var G=v((function(e,a){return e===a?1:0})),L=F(a.Equal,G,null,"bool"),V={kernelName:a.Equal,backendName:"cpu",kernelFunc:L},q=W((function(e){return Math.exp(e)})),U=H(a.Exp,q,"float32"),j={kernelName:a.Exp,backendName:"cpu",kernelFunc:U},Z=W((function(e){return Math.expm1(e)})),K=H(a.Expm1,Z),Y={kernelName:a.Expm1,backendName:"cpu",kernelFunc:K},J=W((function(e){return Math.floor(e)})),Q=H(a.Floor,J),X={kernelName:a.Floor,backendName:"cpu",kernelFunc:Q};function $(e,t,r,n,i,s,o,u,d){for(var p=a.buffer([n,s],r),c=0;c<n;c++){for(var f=[],h=0,m=0;m<i;m++){var v=e[c*i+m];h+=v*o[m],f.push(v)}if(h<0||h>=d/s)throw new Error("Invalid indices: "+f+" does not index into "+u);for(var k=0;k<s;k++)p.values[c*s+k]=t.get.apply(t,l(t.indexToLoc(h*s+k)))}return p}function ee(e,t,r){for(var n=a.buffer(r,e.dtype),i=0;i<n.size;++i){var s=n.indexToLoc(i).slice(),o=s[0],u=s[2],d=t.locToIndex([o,u]);s[2]=t.values[d];var l=e.locToIndex(s);0<=l&&l<e.values.length&&(n.values[i]=e.values[l])}return n}var ae=v((function(e,a){return e>a?1:0})),te=F(a.Greater,ae,null,"bool"),re={kernelName:a.Greater,backendName:"cpu",kernelFunc:te},ne=v((function(e,a){return e>=a?1:0})),ie=F(a.GreaterEqual,ne,null,"bool"),se={kernelName:a.GreaterEqual,backendName:"cpu",kernelFunc:ie},oe=v((function(e,a){return e<a?1:0})),ue=F(a.Less,oe,null,"bool"),de={kernelName:a.Less,backendName:"cpu",kernelFunc:ue},le=v((function(e,a){return e<=a?1:0})),pe=F(a.LessEqual,le,null,"bool"),ce={kernelName:a.LessEqual,backendName:"cpu",kernelFunc:pe};function fe(e,t,r){var n=(t-e)/(r-1),i=a.util.makeZerosTypedArray(r,"float32");i[0]=e;for(var s=1;s<i.length;s++)i[s]=i[s-1]+n;return i}var he=W((function(e){return Math.log(e)})),me=H(a.Log,he),ve={kernelName:a.Log,backendName:"cpu",kernelFunc:me};function ke(e,t,r,n){for(var i=a.util.getTypedArrayFromDType(n,a.util.sizeFromShape(r)),s=0;s<i.length;++s){for(var o=s*t,u=e[o],d=0;d<t;++d){var l=e[o+d];(Number.isNaN(l)||l>u)&&(u=l)}i[s]=u}return i}var ge=v((function(e,a){return Math.max(e,a)})),be=F(a.Maximum,ge),Ie={kernelName:a.Maximum,backendName:"cpu",kernelFunc:be},ye=v((function(e,a){return Math.min(e,a)})),Ne=F(a.Minimum,ye),xe={kernelName:a.Minimum,backendName:"cpu",kernelFunc:Ne},Se=v((function(e,a){return e*a})),Te=M((function(e,a,t,r){return{real:e*t-a*r,imag:e*r+a*t}})),Fe=F(a.Multiply,Se,Te),Me={kernelName:a.Multiply,backendName:"cpu",kernelFunc:Fe};function Ae(e,t,r){var n=a.util.createScalarValue(-1,r);return Se([],t,n,e,r)}var we={kernelName:a.Neg,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=a.x;p(r,"neg");var n=d(Ae(t.data.get(r.dataId).values,r.shape,r.dtype),2),i=n[0],s=n[1];return t.makeTensorInfo(s,r.dtype,i)}},De=v((function(e,a){return e!==a?1:0})),_e=F(a.NotEqual,De,null,"bool"),Ee={kernelName:a.NotEqual,backendName:"cpu",kernelFunc:_e};function ze(e,t,r,n,i){for(var s=t.length,o=a.util.sizeFromShape(t),u=a.util.computeStrides(t),d=a.util.computeStrides(i),l=a.util.getTypedArrayFromDType(r,a.util.sizeFromShape(i)),p=0;p<o;++p){for(var c=a.util.indexToLoc(p,s,u),f=new Array(c.length),h=0;h<f.length;h++)f[h]=c[n[h]];l[a.util.locToIndex(f,s,d)]=e[p]}return l}function We(e){var a=e.inputs,t=e.attrs,r=e.backend,n=a.x,i=t.perm;p(n,"transpose");for(var s=n.shape.length,o=new Array(s),u=0;u<o.length;u++)o[u]=n.shape[i[u]];var d=ze(r.data.get(n.dataId).values,n.shape,n.dtype,i,o);return{dataId:r.write(d,o,n.dtype),shape:o,dtype:n.dtype}}var Ce={kernelName:a.Transpose,backendName:"cpu",kernelFunc:We};function He(e,t,r,n){for(var i=d(a.backend_util.computeOutAndReduceShapes(e,n),2),s=i[0],o=i[1],u=a.upcastType(t,"int32"),l=a.util.makeZerosTypedArray(a.util.sizeFromShape(s),u),p=a.util.sizeFromShape(o),c=0;c<l.length;++c){for(var f=c*p,h=1,m=0;m<p;++m)h*=r[f+m];l[c]=h}return{outVals:l,outShape:s,outDtype:u}}var Pe={kernelName:a.Prod,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis,o=n.keepDims;p(i,"prod");var u=i.shape.length,d=a.util.parseAxisParam(s,i.shape),l=a.backend_util.getAxesPermutation(d,u),c=d,f=i,h=[];null!=l&&(f=We({inputs:{x:i},backend:r,attrs:{perm:l}}),h.push(f),c=a.backend_util.getInnerMostAxes(c.length,u));var m=r.data.get(f.dataId).values,v=He(f.shape,f.dtype,m,c),k=v.outVals,g=v.outShape,b=v.outDtype,I=g;return o&&(I=a.backend_util.expandShapeToKeepDim(g,d)),h.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),r.makeTensorInfo(I,b,k)}};function Re(e,t,r,n){if(e===t||e<t&&r<0||t<e&&r>1)return a.util.makeZerosTypedArray(0,n);var i=Math.abs(Math.ceil((t-e)/r)),s=a.util.makeZerosTypedArray(i,n);t<e&&1===r&&(r=-1),s[0]=e;for(var o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}var Be=W((function(e){return 1/Math.sqrt(e)})),Oe=H(a.Rsqrt,Be),Ge={kernelName:a.Rsqrt,backendName:"cpu",kernelFunc:Oe},Le=W((function(e){return 1/(1+Math.exp(-e))})),Ve=C(a.Sigmoid,(function(e){return 1/(1+Math.exp(-e))})),qe={kernelName:a.Sigmoid,backendName:"cpu",kernelFunc:Ve};function Ue(e,t,r,n,i){var s=a.slice_util.isSliceContinous(n,t,r),o=a.util.sizeFromShape(r),u=a.util.computeStrides(n);if(s){var d=a.slice_util.computeFlatOffset(t,u);return"string"===i?e.slice(d,d+o):e.subarray(d,d+o)}for(var p="string"===i?a.backend_util.fromUint8ToStringArray(e):e,c=a.buffer(n,i,p),f=a.buffer(r,i),h=0;h<f.size;++h){var m=f.indexToLoc(h),v=m.map((function(e,a){return e+t[a]}));f.set.apply(f,l([c.get.apply(c,l(v))],m))}return"string"===i?a.backend_util.fromStringArrayToUint8(f.values):f.values}function je(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.begin,o=n.size;p(i,"slice");var u=d(a.slice_util.parseSliceParams(i,s,o),2),l=u[0],c=u[1];a.slice_util.assertParamsValid(i,l,c);var f=Ue(r.data.get(i.dataId).values,l,c,i.shape,i.dtype);return r.makeTensorInfo(c,i.dtype,f)}var Ze={kernelName:a.Slice,backendName:"cpu",kernelFunc:je};function Ke(e,t,r,n,i,s,o){var u=t[0],d=s[0],l=new Array(d),p=new Array(u),c=t[1];if(0===d){if(0!==u)throw new Error(a.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));return[I=a.util.getArrayFromDType(r,0),[0,c],y=a.util.getArrayFromDType(i,0),l,p]}for(var f=!0,h=0,m=new Array(d).fill(0),v=0;v<u;++v){if((g=e[v*c])<0)throw new Error(a.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(v,g));if(g>=d)throw new Error(a.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(v,g,d));++m[g],f=f&&g>=h,h=g}for(var k=!0,g=0;g<d;++g){var b=0===m[g];l[g]=b,k=k&&!b,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(k&&f){var I=e,y=n;for(v=0;v<u;++v)p[v]=v;return[I,[u,c],y,l,p]}var N=m[d-1],x=(I=a.util.getArrayFromDType(r,N*c),y=a.util.getArrayFromDType(i,N),new Array(d).fill(0));for(v=0;v<u;++v){var S=x[g=e[v*c]],T=(0===g?0:m[g-1])+S;x[g]++;for(var F=0;F<c;++F)I[T*c+F]=e[v*c+F];y[T]=n[v],p[v]=T}for(g=0;g<d;++g){if(0===x[g]){var M=0===g?0:m[g-1];I[M*c+0]=g;for(var A=1;A<c;++A)I[M*c+A]=0;y[M]=o}}return[I,[N,c],y,l,p]}function Ye(e,t,r,n,i){for(var s=a.util.sizeFromShape(n),o=t[0],u=i.length,d=[],l=1,p=-1,c=0;c<u;++c){var f=i[c];if(-1===f){if(-1!==p)throw new Error(a.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,c));p=c,d.push(1)}else{if(f<0)throw new Error(a.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(c,f));l*=f,d.push(f)}}if(-1!==p){if(l<=0)throw new Error(a.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());var h=Math.trunc(s/l);if(l*h!==s)throw new Error(a.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(n,d));d[p]=h}if(a.util.sizeFromShape(d)!==s)throw new Error(a.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(n,d));var m=n.length,v=[];if(m>0){v[m-1]=1;for(c=m-2;c>=0;--c)v[c]=v[c+1]*n[c+1]}var k=[];if(u>0){k[u-1]=1;for(c=u-2;c>=0;--c)k[c]=k[c+1]*d[c+1]}for(var g=a.util.getArrayFromDType(r,o*u),b=0;b<o;++b){for(var I=0,y=0;y<m;++y)I+=e[b*m+y]*v[y];for(y=0;y<u;++y)g[b*u+y]=Math.trunc(I/k[y]),I%=k[y]}return[g,[o,u],d]}function Je(e,t,r,n,i,s,o){void 0===s&&(s=!1),void 0===o&&(o=0);var u=n.length,d=[t[0],e.length/t[0]],l=d[1],p=u>0?i[u-1]+1:0;if(p<0)throw new Error(a.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());var c=t.slice();c[0]=p;var f=c.reduce((function(e,a){return e*a}),1),h=a.util.getArrayFromDType(r,f);if(0===u)return p>0&&h.fill(o),[h,c];if(p<=0)throw new Error(a.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());for(var m=0,v=1,k=0,g=i[m];;){var b=0;if(v<u){if(g===(b=i[v])){++v;continue}if(g>=b)throw new Error(a.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(g<0||g>=p)throw new Error(a.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(g,p));g>k&&h.fill(o,k*l,g*l);for(var I=m;I<v;++I){var y=n[I];if(y<0||y>=d[0])throw new Error(a.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,n[I],d[0]));for(var N=0;N<l;N++)h[g*l+N]+=e[y*l+N]}if(s)for(N=0;N<l;N++)h[g*l+N]/=v-m;if(m=v,k=g+1,g=b,++v>u)break}return k<p&&h.fill(o,k*l,p*l),[h,c]}var Qe=W((function(e){return Math.sqrt(e)})),Xe=C(a.Sqrt,(function(e){return Math.sqrt(e)})),$e={kernelName:a.Sqrt,backendName:"cpu",kernelFunc:Xe},ea=v((function(e,a){var t=e-a;return t*t})),aa=F(a.SquaredDifference,ea),ta={kernelName:a.SquaredDifference,backendName:"cpu",kernelFunc:aa};function ra(e,t,r,n){for(var i=a.buffer(e,t.dtype),s=0;s<i.size;s++){for(var o=i.indexToLoc(s),u=new Array(o.length),d=0;d<u.length;d++)u[d]=o[d]*r[d]+n[d];i.set.apply(i,l([t.get.apply(t,l(u))],o))}return i}var na=function(){function e(e,t,r,n,i,s){this.separator=a.util.encodeString(e),this.nGramWidths=t,this.leftPad=a.util.encodeString(r),this.rightPad=a.util.encodeString(n),this.padWidth=i,this.preserveShort=s}return e.prototype.getPadWidth=function(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)},e.prototype.getNumNGrams=function(e,a){var t=this.getPadWidth(a);return Math.max(0,e+2*t-a+1)},e.prototype.createNGrams=function(e,a,t,r,n,i){for(var s=function(s){var u=o.getPadWidth(i),d=Math.max(0,u-s),l=Math.max(0,u-(n-(s+1))),p=i-(d+l),c=a+(d>0?0:s-u),f=0;f+=d*o.leftPad.length;for(var h=0;h<p;++h)f+=e[c+h].length;f+=l*o.rightPad.length,f+=(d+l+p-1)*o.separator.length,t[r+s]=new Uint8Array(f);var m=t[r+s],v=0,k=function(e){return e.forEach((function(e){return m[v++]=e}))};for(h=0;h<d;++h)k(o.leftPad),k(o.separator);for(h=0;h<p-1;++h)k(e[c+h]),k(o.separator);if(p>0){k(e[c+p-1]);for(h=0;h<l;++h)k(o.separator),k(o.rightPad)}else{for(h=0;h<l-1;++h)k(o.rightPad),k(o.separator);k(o.rightPad)}},o=this,u=0;u<n;++u)s(u)},e.prototype.compute=function(e,t){var r=this,n=e.length,i=t.length;if(i>0){var s=t[0];if(0!==s)throw new Error("First split value must be 0, got "+s);for(var o=1;o<i;++o){var u=t[o]>=s;if(!(u=u&&t[o]<=n))throw new Error("Invalid split value "+t[o]+", must be in ["+s+", "+n+"]");s=t[o]}if(s!==n)throw new Error("Last split value must be data size. Expected "+n+", got "+s)}var d=i-1,l=a.util.getArrayFromDType("int32",i);if(0===n||0===i){var p=new Array(n);for(o=0;o<=d;++o)l[o]=0;return[p,l]}l[0]=0;var c=function(e){var a=t[e]-t[e-1],n=0;f.nGramWidths.forEach((function(e){n+=r.getNumNGrams(a,e)})),f.preserveShort&&a>0&&0===n&&(n=1),l[e]=l[e-1]+n},f=this;for(o=1;o<=d;++o)c(o);var h=new Array(l[d]),m=function(a){var n=t[a],i=l[a];if(v.nGramWidths.forEach((function(s){var o=t[a+1]-t[a],u=r.getNumNGrams(o,s);r.createNGrams(e,n,h,i,u,s),i+=u})),v.preserveShort&&i===l[a]){var s=t[a+1]-t[a];if(0===s)return"continue";var o=s+2*v.padWidth;v.createNGrams(e,n,h,i,1,o)}},v=this;for(o=0;o<d;++o)m(o);return[h,l]},e}();function ia(e,a,t,r,n,i,s,o){return new na(t,r,n,i,s,o).compute(e,a)}function sa(e,a,t,r){if(e.length)if(0!==a.length)if(1!==a.length){var n=0;for(u=0;u<e.length+1;u++)if(u===e.length||-1!==a.indexOf(e[u])){o=e.subarray(n,u);t&&0===o.length||r.push(o),n=u+1}}else{for(var i=a[0],s=e.indexOf(i);-1!==s;){var o=e.subarray(0,s);t&&0===o.length||r.push(o),s=(e=e.subarray(s+1)).indexOf(i)}t&&0===e.length||r.push(e)}else for(var u=0;u<e.length;++u)r.push(e.subarray(u,u+1))}function oa(e,t,r){for(var n=e.length,i=[],s=0,o=0,u=new Array(n),d=0;d<n;++d){var l=i.length;sa(e[d],t,r,i);var p=i.length-l;u[d]=p,s+=p,o=Math.max(o,p)}var c=a.util.getArrayFromDType("int32",2*s),f=new Array(s),h=[n,o],m=0;for(d=0;d<n;++d)for(var v=0;v<u[d];++v)c[2*m]=d,c[2*m+1]=v,f[m]=i[m],++m;return[c,f,h]}function ua(e,t){for(var r=a.util.getArrayFromDType("int32",e.length),n=0;n<e.length;++n)r[n]=a.util.fingerPrint64(e[n]).modulo(t).getLowBitsUnsigned();return r}var da=v((function(e,a){return e-a})),la=M((function(e,a,t,r){return{real:e-t,imag:a-r}})),pa=F(a.Sub,da,la),ca={kernelName:a.Sub,backendName:"cpu",kernelFunc:pa};function fa(e,t){for(var r=new Array(e.rank),n=0;n<r.length;n++)r[n]=e.shape[n]*t[n];var i=a.buffer(r,e.dtype);for(n=0;n<i.values.length;++n){for(var s=i.indexToLoc(n),o=new Array(e.rank),u=0;u<o.length;u++)o[u]=s[u]%e.shape[u];var d=e.locToIndex(o);i.values[n]=e.values[d]}return i}var ha=function(e,a){var t=a.value-e.value;return 0===t?e.index-a.index:t};function ma(e,t,r,n){for(void 0===r&&(r=0),void 0===n&&(n=e.length-1);n>r;){if(n-r>600){var i=n-r+1,s=t-r+1,o=Math.log(i),u=.5*Math.exp(2*o/3),d=.5*Math.sqrt(o*u*(i-u)/i)*Math.sign(s-i/2);ma(e,t,Math.max(r,Math.floor(t-s*u/i+d)),Math.min(n,Math.floor(t+(i-s)*u/i+d)))}var l=e[t],p=r,c=n;for(a.util.swap(e,r,t),ha(e[n],l)>0&&a.util.swap(e,r,n);p<c;){for(a.util.swap(e,p,c),p++,c--;ha(e[p],l)<0;)p+=1;for(;ha(e[c],l)>0;)c-=1}0===ha(e[r],l)?a.util.swap(e,r,c):(c+=1,a.util.swap(e,c,n)),c<=t&&(r=c+1),t<=c&&(n=c-1)}}function va(e,t,r,n,i){for(var s=t[t.length-1],o=d([e.length/s,s],2),u=o[0],l=o[1],p=a.util.getTypedArrayFromDType(r,u*n),c=a.util.getTypedArrayFromDType("int32",u*n),f=function(a){var t=a*l,r=e.subarray(t,t+l),s=new Array(r.length);r.forEach((function(e,a){return s[a]={value:e,index:a}})),n<s.length&&(ma(s,n),s=s.slice(0,n)),i&&s.sort(ha);for(var o=a*n,u=p.subarray(o,o+n),d=c.subarray(o,o+n),f=0;f<n;f++)u[f]=s[f].value,d[f]=s[f].index},h=0;h<u;h++)f(h);var m=t.slice();return m[m.length-1]=n,[a.buffer(m,r,p),a.buffer(m,"int32",c)]}function ka(e,t,r,n){for(var i=a.util.parseAxisParam(t,r)[0],s=[1,r[0],1],o=0;o<i;o++)s[0]*=r[o];s[1]=r[i];for(o=i+1;o<r.length;o++)s[2]*=r[o];var u={},d=new Int32Array(r[i]),l=new a.TensorBuffer(s,n,e),p=[],c=1===s[0]&&1===s[2];for(o=0;o<r[i];o++){var f=void 0;if(c)f=e[o].toString();else{for(var h=[],m=0;m<s[0];m++)for(var v=0;v<s[2];v++)h.push(l.get(m,o,v));f=h.join(",")}if(void 0!==u[f])d[o]=u[f];else{var k=Object.keys(u).length;u[f]=k,d[o]=k,p.push(o)}}var g=s.slice();g[1]=Object.keys(u).length;var b=new a.TensorBuffer(g,n);p.forEach((function(e,a){for(var t=0;t<s[0];t++)for(var r=0;r<s[2];r++)b.set(l.get(t,e,r),t,a,r)}));var I=r.slice();return I[i]=g[1],{outputValues:b.values,outputShape:I,indices:d}}var ga={__proto__:null,simpleAbsImpl:h,addImpl:A,bincountImpl:E,bincountReduceImpl:z,ceilImpl:P,concatImpl:O,equalImpl:G,expImpl:q,expm1Impl:Z,floorImpl:J,gatherNdImpl:$,gatherV2Impl:ee,greaterImpl:ae,greaterEqualImpl:ne,lessImpl:oe,lessEqualImpl:le,linSpaceImpl:fe,logImpl:he,maxImpl:ke,maximumImpl:ge,minimumImpl:ye,multiplyImpl:Se,negImpl:Ae,notEqualImpl:De,prodImpl:He,rangeImpl:Re,rsqrtImpl:Be,sigmoidImpl:Le,sliceImpl:Ue,sparseFillEmptyRowsImpl:Ke,sparseReshapeImpl:Ye,sparseSegmentReductionImpl:Je,sqrtImpl:Qe,squaredDifferenceImpl:ea,stridedSliceImpl:ra,stringNGramsImpl:ia,stringSplitImpl:oa,stringToHashBucketFastImpl:ua,subImpl:da,tileImpl:fa,topKImpl:va,transposeImpl:ze,uniqueImpl:ka};a.registerBackend("cpu",(function(){return new f}),1);var ba=C(a.Elu,(function(e){return e>=0?e:Math.exp(e)-1})),Ia={kernelName:a.Elu,backendName:"cpu",kernelFunc:ba};function ya(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.alpha;p([i],"leakyRelu");for(var o=a.util.sizeFromShape(i.shape),u=r.data.get(i.dataId).values,d=a.util.getTypedArrayFromDType("float32",o),l=0;l<u.length;l++)d[l]=u[l]<0?s*u[l]:u[l];return r.makeTensorInfo(i.shape,"float32",d)}var Na={kernelName:a.LeakyRelu,backendName:"cpu",kernelFunc:ya},xa=v((function(e,a){return e<0?a*e:e}));function Sa(e){var a=e.inputs,t=e.backend,r=a.x,n=a.alpha;p([r,n],"prelu");var i=t.data.get(r.dataId).values,s=t.data.get(n.dataId).values,o=d(xa(r.shape,n.shape,i,s,"float32"),2),u=o[0],l=o[1];return t.makeTensorInfo(l,"float32",u)}var Ta={kernelName:a.Prelu,backendName:"cpu",kernelFunc:Sa},Fa=C(a.Relu,(function(e){return Math.max(0,e)})),Ma={kernelName:a.Relu,backendName:"cpu",kernelFunc:Fa},Aa=C(a.Relu6,(function(e){return Math.min(Math.max(0,e),6)})),wa={kernelName:a.Relu6,backendName:"cpu",kernelFunc:Aa};function Da(e,a,t,r,n){if("linear"===t)return I({inputs:{x:a},backend:e});if("relu"===t)return Fa({inputs:{x:a},backend:e});if("elu"===t)return ba({inputs:{x:a},backend:e});if("relu6"===t)return Aa({inputs:{x:a},backend:e});if("prelu"===t)return Sa({inputs:{x:a,alpha:r},backend:e});if("leakyrelu"===t)return ya({inputs:{x:a},backend:e,attrs:{alpha:n}});if("sigmoid"===t)return Ve({inputs:{x:a},backend:e});throw new Error("Activation "+t+" has not been implemented for the CPU backend.")}function _a(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.shape,o=a.util.sizeFromShape(i.shape),u=a.util.inferFromImplicitShape(s,o),d=a.util.sizeFromShape(u);a.util.assert(o===d,(function(){return"The new shape ("+u+") has "+d+" elements and the old shape ("+i.shape+") has "+o+" elements. The new shape and old shape must have the same number of elements."})),r.incRef(i.dataId);var l=r.data.get(i.dataId);if(null!=l.complexTensorInfos){var p=l.complexTensorInfos.real,c=l.complexTensorInfos.imag;p.shape=u,c.shape=u}return{dataId:i.dataId,shape:u,dtype:i.dtype}}var Ea={kernelName:a.Reshape,backendName:"cpu",kernelFunc:_a};function za(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.a,s=t.b,o=n.transposeA,u=n.transposeB;p([i,s],"matMul");var l=i.shape.length,c=s.shape.length,f=o?i.shape[l-2]:i.shape[l-1],h=u?s.shape[c-1]:s.shape[c-2],m=o?i.shape[l-1]:i.shape[l-2],v=u?s.shape[c-2]:s.shape[c-1],k=i.shape.slice(0,-2),g=s.shape.slice(0,-2),b=a.util.sizeFromShape(k),I=a.util.sizeFromShape(g),y=a.broadcast_util.assertAndGetBroadcastShape(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,v]);a.util.assert(f===h,(function(){return"Error in matMul: inner shapes ("+f+") and ("+h+") of Tensors with shapes "+i.shape+" and "+s.shape+" and transposeA="+o+" and transposeB="+u+" must match."}));for(var N=u?[I,v,h]:[I,h,v],x=_a({inputs:{x:i},backend:r,attrs:{shape:o?[b,f,m]:[b,m,f]}}),S=_a({inputs:{x:s},backend:r,attrs:{shape:N}}),T=o?x.shape[1]:x.shape[2],F=o?x.shape[2]:x.shape[1],M=u?S.shape[1]:S.shape[2],A=Math.max(b,I),w=r.data.get(x.dataId).values,D=r.data.get(S.dataId).values,_=a.util.computeStrides(x.shape),E=a.util.computeStrides(S.shape),z=d(o?[_[0],1,_[1]]:[_[0],_[1],1],3),W=z[0],C=z[1],H=z[2],P=d(u?[1,E[1],E[0]]:[E[1],1,E[0]],3),R=P[0],B=P[1],O=P[2],G=F*M,L=a.buffer([A,F,M],x.dtype),V=L.values,q=r.blockSize,U=0;U<A;U++)for(var j=0;j<F;j+=q)for(var Z=0;Z<M;Z+=q)for(var K=0;K<T;K+=q)for(var Y=Math.min(j+q,F),J=Math.min(Z+q,M),Q=Math.min(K+q,T),X=j;X<Y;X++)for(var $=Z;$<J;$++){for(var ee=0,ae=K;ae<Q;ae++){var te=Math.min(U,b-1)*W,re=Math.min(U,I-1)*O;ee+=w[te+X*C+ae*H]*D[ae*R+$*B+re]}V[U*G+(X*M+$)]+=ee}return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(S),r.makeTensorInfo(y,L.dtype,L.values)}var Wa={kernelName:a.BatchMatMul,backendName:"cpu",kernelFunc:za};var Ca={kernelName:a._FusedMatMul,backendName:"cpu",kernelFunc:function(e){var a,t,r,n,i,s=e.inputs,o=e.backend,d=e.attrs,l=s.a,p=s.b,c=s.bias,f=s.preluActivationWeights,h=d.transposeA,m=d.transposeB,v=d.activation,k=d.leakyreluAlpha,g=[];r=za({inputs:{a:l,b:p},attrs:{transposeA:h,transposeB:m},backend:o}),c&&(n=D({inputs:{a:r,b:c},backend:o}),g.push(r),r=n),v&&(i=Da(o,r,v,f,k),g.push(r),r=i);try{for(var b=u(g),I=b.next();!I.done;I=b.next()){var y=I.value;o.disposeIntermediateTensorInfo(y)}}catch(e){a={error:e}}finally{try{I&&!I.done&&(t=b.return)&&t.call(b)}finally{if(a)throw a.error}}return r}},Ha=C(a.Acos,(function(e){return Math.acos(e)})),Pa={kernelName:a.Acos,backendName:"cpu",kernelFunc:Ha},Ra=C(a.Acosh,(function(e){return Math.acosh(e)})),Ba={kernelName:a.Acosh,backendName:"cpu",kernelFunc:Ra};var Oa={kernelName:a.AddN,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=t;p(t,"addN");for(var i=n.map((function(e){return r.data.get(e.dataId).values})),s=a.buffer(n[0].shape,n[0].dtype),o=s.values,u=0;u<n.length;u++)for(var d=i[u],l=0;l<o.length;l++)o[l]+=d[l];return r.makeTensorInfo(s.shape,s.dtype,s.values)}};var Ga={kernelName:a.All,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis,o=n.keepDims;p(i,"all");var u=a.util.parseAxisParam(s,i.shape),l=u,c=a.backend_util.getAxesPermutation(l,i.shape.length),f=i;null!=c&&(f=We({inputs:{x:i},backend:r,attrs:{perm:c}}),l=a.backend_util.getInnerMostAxes(l.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("all",l,f.shape.length);for(var h=d(a.backend_util.computeOutAndReduceShapes(f.shape,l),2),m=h[0],v=h[1],k=a.util.sizeFromShape(v),g=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),b=r.data.get(f.dataId).values,I=0;I<g.length;++I){for(var y=I*k,N=b[y],x=0;x<k;++x){var S=b[y+x];N=N&&S}g[I]=N}null!=c&&r.disposeIntermediateTensorInfo(f);var T=r.makeTensorInfo(m,f.dtype,g);if(o){var F=_a({inputs:{x:T},backend:r,attrs:{shape:a.backend_util.expandShapeToKeepDim(m,u)}});return r.disposeIntermediateTensorInfo(T),F}return T}};var La={kernelName:a.Any,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis,o=n.keepDims;p(i,"any");var u=a.util.parseAxisParam(s,i.shape),l=u,c=a.backend_util.getAxesPermutation(l,i.shape.length),f=i;null!=c&&(f=We({inputs:{x:i},backend:r,attrs:{perm:c}}),l=a.backend_util.getInnerMostAxes(l.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("any",l,f.shape.length);for(var h=d(a.backend_util.computeOutAndReduceShapes(f.shape,l),2),m=h[0],v=h[1],k=a.util.sizeFromShape(v),g=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),b=r.data.get(f.dataId).values,I=0;I<g.length;++I){for(var y=I*k,N=b[y],x=0;x<k;++x){var S=b[y+x];N=N||S}g[I]=N}null!=c&&r.disposeIntermediateTensorInfo(f);var T=r.makeTensorInfo(m,f.dtype,g);if(o){var F=_a({inputs:{x:T},backend:r,attrs:{shape:a.backend_util.expandShapeToKeepDim(m,u)}});return r.disposeIntermediateTensorInfo(T),F}return T}};var Va={kernelName:a.ArgMax,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis;p(i,"argMax");var o=a.util.parseAxisParam(s,i.shape),u=a.backend_util.getAxesPermutation(o,i.shape.length),l=i,c=[];null!=u&&(l=We({inputs:{x:i},backend:r,attrs:{perm:u}}),c.push(l),o=a.backend_util.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],a.backend_util.assertAxesAreInnerMostDims("argMax",o,l.shape.length);for(var f=d(a.backend_util.computeOutAndReduceShapes(l.shape,o),2),h=f[0],m=f[1],v=a.util.sizeFromShape(h),k=a.util.makeZerosTypedArray(v,"int32"),g=a.util.sizeFromShape(m),b=r.data.get(l.dataId).values,I=0;I<k.length;++I){for(var y=I*g,N=b[y],x=0,S=0;S<g;++S){var T=b[y+S];T>N&&(N=T,x=S)}k[I]=x}return c.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),r.makeTensorInfo(h,"int32",k)}};var qa={kernelName:a.ArgMin,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis;p(i,"argMin");var o=a.util.parseAxisParam(s,i.shape),u=a.backend_util.getAxesPermutation(o,i.shape.length),l=i,c=[];null!=u&&(l=We({inputs:{x:i},backend:r,attrs:{perm:u}}),c.push(l),o=a.backend_util.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],a.backend_util.assertAxesAreInnerMostDims("argMin",o,l.shape.length);for(var f=d(a.backend_util.computeOutAndReduceShapes(l.shape,o),2),h=f[0],m=f[1],v=a.util.sizeFromShape(h),k=a.util.makeZerosTypedArray(v,"int32"),g=a.util.sizeFromShape(m),b=r.data.get(l.dataId).values,I=0;I<k.length;++I){for(var y=I*g,N=b[y],x=0,S=0;S<g;++S){var T=b[y+S];T<N&&(N=T,x=S)}k[I]=x}return c.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),r.makeTensorInfo(h,"int32",k)}},Ua=C(a.Asin,(function(e){return Math.asin(e)})),ja={kernelName:a.Asin,backendName:"cpu",kernelFunc:Ua},Za=C(a.Asinh,(function(e){return Math.asinh(e)})),Ka={kernelName:a.Asinh,backendName:"cpu",kernelFunc:Za},Ya=C(a.Atan,(function(e){return Math.atan(e)})),Ja={kernelName:a.Atan,backendName:"cpu",kernelFunc:Ya},Qa=v((function(e,a){return Math.atan2(e,a)})),Xa=F(a.Atan2,Qa),$a={kernelName:a.Atan2,backendName:"cpu",kernelFunc:Xa},et=C(a.Atanh,(function(e){return Math.atanh(e)})),at={kernelName:a.Atanh,backendName:"cpu",kernelFunc:et};function tt(e,t,r,n,i,s){for(var o=i.strideHeight,u=i.strideWidth,d=i.dilationHeight,l=i.dilationWidth,p=i.effectiveFilterHeight,c=i.effectiveFilterWidth,f=i.padInfo.top,h=i.padInfo.left,m="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=a.buffer(i.outShape,r),k=v.values,g=i.outShape[1]*i.outShape[2]*i.outShape[3],b=i.outShape[2]*i.outShape[3],I=i.outShape[3],y=0;y<i.batchSize;++y)for(var N=y*g,x=y*n[0],S=0;S<i.inChannels;++S)for(var T=0;T<i.outHeight;++T)for(var F=T*o-f,M=Math.max(0,F),A=Math.min(i.inHeight,p+F),w=N+T*b,D=0;D<i.outWidth;++D){for(var _=D*u-h,E=Math.max(0,_),z=Math.min(i.inWidth,c+_),W=m,C=0,H=0,P=M;P<A;P+=d){for(var R=x+P*n[1],B=E;B<z;B+=l){var O=e[R+B*n[2]+S];"max"===s&&O>W?W=O:"avg"===s&&(C+=O,H++)}if(isNaN(W))break}k[w+D*I+S]="avg"===s?C/H:W}return v}function rt(e,t,r,n,i,s){void 0===i&&(i=!1),void 0===s&&(s=!1);for(var o=a.buffer(n.outShape,"int32"),u=n.strideHeight,d=n.strideWidth,l=n.dilationHeight,p=n.dilationWidth,c=n.effectiveFilterHeight,f=n.effectiveFilterWidth,h=n.padInfo.top,m=n.padInfo.left,v=a.buffer(t,r,e),k=0;k<n.batchSize;++k)for(var g=0;g<n.inChannels;++g)for(var b=0;b<n.outHeight;++b){for(var I=b*u-h,y=I;y<0;)y+=l;for(var N=Math.min(n.inHeight,c+I),x=0;x<n.outWidth;++x){for(var S=x*d-m,T=S;T<0;)T+=p;for(var F=Math.min(n.inWidth,f+S),M=Number.NEGATIVE_INFINITY,A=-1,w=y;w<N;w+=l)for(var D=w-I,_=T;_<F;_+=p){var E=_-S,z=v.get(k,w,_,g);z>M&&(M=z,A=i?s?((k*n.inHeight+w)*n.inWidth+_)*n.inChannels+g:(w*n.inWidth+_)*n.inChannels+g:D*f+E)}o.set(A,k,b,x,g)}}return o}function nt(e,t,r,n,i,s){for(var o=i.strideDepth,u=i.strideHeight,d=i.strideWidth,l=i.dilationDepth,p=i.dilationHeight,c=i.dilationWidth,f=i.effectiveFilterDepth,h=i.effectiveFilterHeight,m=i.effectiveFilterWidth,v=i.padInfo.front,k=i.padInfo.top,g=i.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=a.buffer(i.outShape,r),y=I.values,N=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],x=i.outShape[2]*i.outShape[3]*i.outShape[4],S=i.outShape[3]*i.outShape[4],T=i.outShape[4],F=0;F<i.batchSize;++F)for(var M=F*N,A=F*n[0],w=0;w<i.inChannels;++w)for(var D=0;D<i.outDepth;++D){for(var _=D*o-v,E=_;E<0;)E+=l;for(var z=Math.min(i.inDepth,f+_),W=M+D*x,C=0;C<i.outHeight;++C){for(var H=C*u-k,P=H;P<0;)P+=p;for(var R=Math.min(i.inHeight,h+H),B=W+C*S,O=0;O<i.outWidth;++O){for(var G=O*d-g,L=G;L<0;)L+=c;for(var V=Math.min(i.inWidth,m+G),q=B+O*T,U=b,j=0,Z=0,K=E;K<z;K+=l){for(var Y=A+K*n[1],J=P;J<R;J+=p){for(var Q=Y+J*n[2],X=L;X<V;X+=c){var $=e[Q+X*n[3]+w];if("max"===s&&$>U?U=$:"avg"===s&&(j+=$,Z++),isNaN(U))break}if(isNaN(U))break}if(isNaN(U))break}y[q+w]="avg"===s?j/Z:U}}}return I}var it={kernelName:a.AvgPool,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x;p(i,"avgPool");var s=n.filterSize,o=n.strides,u=n.pad,d=n.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(o,1),(function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+o+" and dilations '1'"}));var l,c=a.backend_util.computePool2DInfo(i.shape,s,o,1,u,d);if(1===c.filterWidth&&1===c.filterHeight&&a.util.arraysEqual(c.inShape,c.outShape))l=I({inputs:{x:i},backend:r});else{var f=r.data.get(i.dataId).values,h=a.util.computeStrides(i.shape),m=tt(f,i.shape,i.dtype,h,c,"avg");l=r.makeTensorInfo(c.outShape,i.dtype,m.values)}return l}};var st={kernelName:a.AvgPool3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.filterSize,o=n.strides,u=n.pad,d=n.dimRoundingMode,l=n.dataFormat;p(i,"avgPool3d");var c=a.backend_util.computePool3DInfo(i.shape,s,o,1,u,d,l),f=nt(r.data.get(i.dataId).values,i.shape,i.dtype,a.util.computeStrides(i.shape),c,"avg");return r.makeTensorInfo(f.shape,"float32",f.values)}};var ot={kernelName:a.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.dy,s=t.input,o=n.filterSize,u=n.strides,d=n.pad,l=n.dimRoundingMode;p([i,s],"avgPool3DGrad");for(var c=a.backend_util.computePool3DInfo(s.shape,o,u,1,d,l),f=c.strideDepth,h=c.strideHeight,m=c.strideWidth,v=c.filterDepth,k=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,I=c.dilationHeight,y=c.dilationWidth,N=c.effectiveFilterDepth,x=c.effectiveFilterHeight,S=c.effectiveFilterWidth,T=N-1-c.padInfo.front,F=S-1-c.padInfo.left,M=x-1-c.padInfo.top,A=a.buffer(s.shape,"float32"),w=1/(v*k*g),D=r.bufferSync(i),_=0;_<c.batchSize;++_)for(var E=0;E<c.inChannels;++E)for(var z=0;z<c.inDepth;++z)for(var W=0;W<c.inHeight;++W)for(var C=0;C<c.inWidth;++C){for(var H=z-T,P=W-M,R=C-F,B=0,O=0;O<N;O+=b){var G=(H+O)/f;if(!(G<0||G>=c.outDepth||Math.floor(G)!==G))for(var L=0;L<x;L+=I){var V=(P+L)/h;if(!(V<0||V>=c.outHeight||Math.floor(V)!==V))for(var q=0;q<S;q+=y){var U=(R+q)/m;if(!(U<0||U>=c.outWidth||Math.floor(U)!==U))B+=D.get(_,G,V,U,E)}}}A.set(B*w,_,z,W,C,E)}return r.makeTensorInfo(A.shape,A.dtype,A.values)}};var ut={kernelName:a.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.dy,s=t.input,o=s;p([i,s],"avgPoolGrad");for(var u=n.filterSize,d=n.strides,l=n.pad,c=a.backend_util.computePool2DInfo(o.shape,u,d,1,l),f=c.strideHeight,h=c.strideWidth,m=c.filterHeight,v=c.filterWidth,k=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,I=c.effectiveFilterWidth,y=I-1-c.padInfo.left,N=b-1-c.padInfo.top,x=a.buffer(o.shape,"float32"),S=1/(m*v),T=r.data.get(i.dataId).values,F=a.buffer(i.shape,"float32",T),M=0;M<c.batchSize;++M)for(var A=0;A<c.inChannels;++A)for(var w=0;w<c.inHeight;++w)for(var D=0;D<c.inWidth;++D){for(var _=w-N,E=D-y,z=0,W=0;W<b;W+=k){var C=(_+W)/f;if(!(C<0||C>=c.outHeight||Math.floor(C)!==C))for(var H=0;H<I;H+=g){var P=(E+H)/h;if(!(P<0||P>=c.outWidth||Math.floor(P)!==P))z+=F.get(M,C,P,A)}}x.set(z*S,M,w,D,A)}return r.makeTensorInfo(x.shape,x.dtype,x.values)}};var dt={kernelName:a.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.scale,o=t.offset,u=t.mean,d=t.variance;a.util.assert(u.shape.length===d.shape.length,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),a.util.assert(null==o||u.shape.length===o.shape.length,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),a.util.assert(null==s||u.shape.length===s.shape.length,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."})),p([i,u,d,s,o],"batchNorm");var l=n.varianceEpsilon;null==l&&(l=.001);for(var c=r.data.get(i.dataId).values,f=r.data.get(u.dataId).values,h=r.data.get(d.dataId).values,m=s?r.data.get(s.dataId).values:new Float32Array([1]),v=o?r.data.get(o.dataId).values:new Float32Array([0]),k=new Float32Array(c.length),g=v.length,b=m.length,I=h.length,y=f.length,N=0,x=0,S=0,T=0,F=0;F<c.length;++F)k[F]=v[N++]+(c[F]-f[x++])*m[S++]/Math.sqrt(h[T++]+l),N>=g&&(N=0),x>=y&&(x=0),S>=b&&(S=0),T>=I&&(T=0);return r.makeTensorInfo(i.shape,i.dtype,k)}};var lt={kernelName:a.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.blockShape,o=n.crops;p([i],"batchToSpaceND");var u=s.reduce((function(e,a){return e*a})),d=a.backend_util.getReshaped(i.shape,s,u),l=a.backend_util.getPermuted(d.length,s.length),c=a.backend_util.getReshapedPermuted(i.shape,s,u),f=a.backend_util.getSliceBeginCoords(o,s.length),h=a.backend_util.getSliceSize(c,o,s.length),m=_a({inputs:{x:i},backend:r,attrs:{shape:d}}),v=We({inputs:{x:m},backend:r,attrs:{perm:l}}),k=_a({inputs:{x:v},backend:r,attrs:{shape:c}}),g=je({inputs:{x:k},backend:r,attrs:{begin:f,size:h}});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(k),g}};var pt={kernelName:a.Bincount,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.x,i=a.weights,s=r.size,o=E(t.data.get(n.dataId).values,t.data.get(i.dataId).values,i.dtype,i.shape,s);return t.makeTensorInfo([s],i.dtype,o)}};var ct={kernelName:a.BroadcastArgs,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=t.s0,i=t.s1,s=r.data.get(n.dataId).values,o=r.data.get(i.dataId).values,u=a.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(o));return r.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},ft=C(a.ClipByValue,(function(e,a){var t=a;return e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e})),ht={kernelName:a.ClipByValue,backendName:"cpu",kernelFunc:ft},mt={kernelName:a.ComplexAbs,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs.x,r=e.backend,n=new Float32Array(a.util.sizeFromShape(t.shape)),i=r.data.get(t.dataId),s=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,u=r.data.get(s.dataId).values,d=r.data.get(o.dataId).values,l=0;l<u.length;l++){var p=u[l],c=d[l];n[l]=Math.hypot(p,c)}return r.makeOutput(n,t.shape,"float32")}};function vt(e){var a=e.inputs,t=e.backend,r=a.input,n=t.data.get(r.dataId).complexTensorInfos.imag,i=t.data.get(n.dataId).values;return t.makeTensorInfo(n.shape,n.dtype,i)}var kt={kernelName:a.Imag,backendName:"cpu",kernelFunc:vt};function gt(e){var t=e.inputs,r=e.backend,n=e.attrs.axis,i=a.util.parseAxisParam(n,t[0].shape)[0],s=a.backend_util.computeOutShape(t.map((function(e){return e.shape})),i);if(0===a.util.sizeFromShape(s))return r.makeTensorInfo(s,t[0].dtype,[]);var o=t.filter((function(e){return a.util.sizeFromShape(e.shape)>0}));if(1===o.length)return I({inputs:{x:o[0]},backend:r});var u=o.map((function(e){return e.shape}));if(a.backend_util.assertParamsConsistent(u,i),"complex64"===o[0].dtype){var d=o.map((function(e){return N({inputs:{input:e},backend:r})})),l=o.map((function(e){return vt({inputs:{input:e},backend:r})})),p=gt({inputs:d,backend:r,attrs:{axis:i}}),c=gt({inputs:l,backend:r,attrs:{axis:i}}),f=k({inputs:{real:p,imag:c},backend:r});return d.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),l.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(c),f}var h=o.map((function(e){var t=a.util.sizeFromShape(e.shape.slice(i));return _a({inputs:{x:e},backend:r,attrs:{shape:[-1,t]}})})),m=h.map((function(e){return{vals:r.data.get(e.dataId).values,shape:e.shape}}));s=a.backend_util.computeOutShape(h.map((function(e){return e.shape})),1);var v=1===h[0].shape[0],g=O(m,s,t[0].dtype,v),b=a.backend_util.computeOutShape(o.map((function(e){return e.shape})),i),y=r.makeTensorInfo(b,t[0].dtype,g);return h.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),y}var bt={kernelName:a.Concat,backendName:"cpu",kernelFunc:gt};function It(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.filter,o=n.strides,u=n.pad,d=n.dataFormat,l=n.dilations,c=n.dimRoundingMode;p([i,s],"conv2d");for(var f=a.backend_util.convertConv2DDataFormat(d),h=a.backend_util.computeConv2DInfo(i.shape,s.shape,o,l,u,c,!1,f),m=h.filterHeight,v=h.filterWidth,k=h.dilationHeight,g=h.dilationWidth,b=h.padInfo.left,I=h.padInfo.top,y="channelsLast"===h.dataFormat,N=new a.TensorBuffer(h.outShape,i.dtype),x=a.util.computeStrides(i.shape),S=a.util.computeStrides(s.shape),T=x[0],F=y?x[1]:x[2],M=y?x[2]:1,A=y?1:x[1],w=N.strides[0],D=y?N.strides[1]:N.strides[2],_=y?N.strides[2]:1,E=y?1:N.strides[1],z=r.data.get(i.dataId).values,W=r.data.get(s.dataId).values,C=N.values,H=0;H<h.batchSize;++H)for(var P=H*T,R=H*w,B=0;B<h.outHeight;++B)for(var O=R+B*D,G=B*h.strideHeight-I,L=0;L<m;++L){var V=G+L*k;if(!(V<0||V>=h.inHeight))for(var q=L*S[0],U=P+V*F,j=0;j<h.outWidth;++j)for(var Z=O+j*_,K=j*h.strideWidth-b,Y=0;Y<v;++Y){var J=K+Y*g;if(!(J<0||J>=h.inWidth))for(var Q=U+J*M,X=q+Y*S[1],$=0;$<h.inChannels;++$){for(var ee=z[Q+$*A],ae=0;ae<h.outChannels;++ae)C[Z+ae*E]+=ee*W[X+ae];X+=h.outChannels}}}return r.makeTensorInfo(N.shape,N.dtype,C)}var yt={kernelName:a.Conv2D,backendName:"cpu",kernelFunc:It};var Nt={kernelName:a.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.dy,o=n.strides,u=n.pad,d=n.dataFormat,l=n.dimRoundingMode,c=n.filterShape;p([i,s],"conv2dBackpropFilter");for(var f=a.backend_util.convertConv2DDataFormat(d),h=a.backend_util.computeConv2DInfo(i.shape,c,o,1,u,l,!1,f),m=h.strideHeight,v=h.strideWidth,k=h.filterHeight,g=h.filterWidth,b="channelsLast"===h.dataFormat,I=new a.TensorBuffer(h.filterShape,"float32"),y=h.padInfo.left,N=h.padInfo.top,x=r.data.get(i.dataId).values,S=r.data.get(s.dataId).values,T=new a.TensorBuffer(i.shape,i.dtype,x),F=new a.TensorBuffer(s.shape,s.dtype,S),M=0;M<k;++M)for(var A=Math.max(0,Math.ceil((N-M)/m)),w=Math.min(h.outHeight,(h.inHeight+N-M)/m),D=0;D<g;++D)for(var _=Math.max(0,Math.ceil((y-D)/v)),E=Math.min(h.outWidth,(h.inWidth+y-D)/v),z=0;z<h.inChannels;++z)for(var W=0;W<h.outChannels;++W){for(var C=0,H=0;H<h.batchSize;++H)for(var P=A;P<w;++P)for(var R=M+P*m-N,B=_;B<E;++B){var O=D+B*v-y;C+=b?T.get(H,R,O,z)*F.get(H,P,B,W):T.get(H,z,R,O)*F.get(H,W,P,B)}I.set(C,M,D,z,W)}return r.makeTensorInfo(I.shape,I.dtype,I.values)}};var xt={kernelName:a.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.dy,s=t.filter,o=n.inputShape,u=n.strides,l=n.pad,c=n.dataFormat,f=n.dimRoundingMode;p([i,s],"conv2dBackpropInput");var h=a.util.computeStrides(s.shape),m=a.util.computeStrides(i.shape),v=a.backend_util.convertConv2DDataFormat(c),k=a.backend_util.computeConv2DInfo(o,s.shape,u,1,l,f,!1,v),g=new a.TensorBuffer(k.inShape,"float32"),b=g.values,I=r.data.get(i.dataId).values,y=r.data.get(s.dataId).values,N=d(h,3),x=N[0],S=N[1],T=N[2],F=k.batchSize,M=k.filterHeight,A=k.filterWidth,w=k.inChannels,D=k.inHeight,_=k.inWidth,E=k.outChannels,z=k.outHeight,W=k.outWidth,C=k.strideHeight,H=k.strideWidth;v=k.dataFormat;for(var P=M-1-k.padInfo.top,R=A-1-k.padInfo.left,B="channelsLast"===v,O=g.strides[0],G=B?g.strides[1]:g.strides[2],L=B?g.strides[2]:1,V=B?1:g.strides[1],q=m[0],U=B?m[1]:m[2],j=B?m[2]:1,Z=B?1:m[1],K=0;K<F;++K)for(var Y=0;Y<w;++Y)for(var J=0;J<D;++J)for(var Q=J-P,X=Math.max(0,Math.ceil(Q/C)),$=Math.min(z,(M+Q)/C),ee=0;ee<_;++ee){for(var ae=ee-R,te=Math.max(0,Math.ceil(ae/H)),re=Math.min(W,(A+ae)/H),ne=0,ie=X;ie<$;++ie)for(var se=ie*C-Q,oe=te;oe<re;++oe)for(var ue=q*K+U*ie+j*oe,de=x*(M-1-se)+S*(A-1-(oe*H-ae))+T*Y,le=0;le<E;++le){ne+=I[ue+Z*le]*y[de+le]}b[O*K+G*J+L*ee+V*Y]=ne}return r.makeTensorInfo(g.shape,g.dtype,g.values)}};var St={kernelName:a.Conv3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.filter,o=n.strides,u=n.pad,d=n.dilations;p([i,s],"conv3d");for(var l=a.backend_util.computeConv3DInfo(i.shape,s.shape,o,d,u),c=l.filterDepth,f=l.filterHeight,h=l.filterWidth,m=l.dilationDepth,v=l.dilationHeight,k=l.dilationWidth,g=l.padInfo,b=g.front,I=g.left,y=g.top,N=new a.TensorBuffer(l.outShape,i.dtype),x=r.data.get(i.dataId).values,S=r.data.get(s.dataId).values,T=N.values,F=a.util.computeStrides(i.shape),M=a.util.computeStrides(s.shape),A=0;A<l.batchSize;++A)for(var w=A*F[0],D=A*N.strides[0],_=0;_<l.outDepth;++_)for(var E=D+_*N.strides[1],z=_*l.strideDepth-b,W=0;W<c;++W){var C=z+W*m;if(!(C<0||C>=l.inDepth))for(var H=W*M[0],P=w+C*F[1],R=0;R<l.outHeight;++R)for(var B=E+R*N.strides[2],O=R*l.strideHeight-y,G=0;G<f;++G){var L=O+G*v;if(!(L<0||L>=l.inHeight))for(var V=H+G*M[1],q=P+L*F[2],U=0;U<l.outWidth;++U)for(var j=B+U*l.outChannels,Z=U*l.strideWidth-I,K=0;K<h;++K){var Y=Z+K*k;if(!(Y<0||Y>=l.inWidth))for(var J=V+K*M[2],Q=q+Y*l.inChannels,X=J,$=0;$<l.inChannels;++$){for(var ee=x[Q+$],ae=0;ae<l.outChannels;++ae)T[j+ae]+=ee*S[X+ae];X+=l.outChannels}}}}return r.makeTensorInfo(N.shape,N.dtype,N.values)}};var Tt={kernelName:a.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.dy,o=n.strides,u=n.pad,l=n.filterShape;p([i,s],"conv3dBackpropFilterV2");for(var c=a.util.computeStrides(i.shape),f=a.util.computeStrides(s.shape),h=a.backend_util.computeConv3DInfo(i.shape,l,o,1,u),m=h.strideDepth,v=h.strideHeight,k=h.strideWidth,g=h.filterDepth,b=h.filterHeight,I=h.filterWidth,y=new a.TensorBuffer(h.filterShape,"float32"),N=y.values,x=d(y.strides,4),S=x[0],T=x[1],F=x[2],M=x[3],A=r.data.get(s.dataId).values,w=d(f,4),D=w[0],_=w[1],E=w[2],z=w[3],W=r.data.get(i.dataId).values,C=d(c,4),H=C[0],P=C[1],R=C[2],B=C[3],O=h.padInfo.front,G=h.padInfo.left,L=h.padInfo.top,V=0;V<g;++V)for(var q=Math.max(0,Math.ceil((O-V)/m)),U=Math.min(h.outDepth,(h.inDepth+O-V)/m),j=V*S,Z=0;Z<b;++Z)for(var K=Math.max(0,Math.ceil((L-Z)/v)),Y=Math.min(h.outHeight,(h.inHeight+L-Z)/v),J=Z*T+j,Q=0;Q<I;++Q)for(var X=Math.max(0,Math.ceil((G-Q)/k)),$=Math.min(h.outWidth,(h.inWidth+G-Q)/k),ee=Q*F+J,ae=0;ae<h.inChannels;++ae)for(var te=ae*M+ee,re=0;re<h.outChannels;++re){for(var ne=0,ie=0;ie<h.batchSize;++ie)for(var se=ie*H,oe=ie*D,ue=q;ue<U;++ue)for(var de=(V+ue*m-O)*P+se,le=ue*_+oe,pe=K;pe<Y;++pe)for(var ce=(Z+pe*v-L)*R+de,fe=pe*E+le,he=X;he<$;++he){var me=he*z+fe;ne+=W[(Q+he*k-G)*B+ce+ae]*A[me+re]}N[te+re]=ne}return r.makeTensorInfo(y.shape,y.dtype,y.values)}};var Ft={kernelName:a.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.dy,s=t.filter,o=n.pad,u=n.strides,l=n.inputShape;p([i],"conv3dBackpropInputV2");for(var c=a.util.computeStrides(i.shape),f=a.util.computeStrides(s.shape),h=a.backend_util.computeConv3DInfo(l,s.shape,u,1,o),m=new a.TensorBuffer(h.inShape,"float32"),v=m.values,k=d(m.strides,4),g=k[0],b=k[1],I=k[2],y=k[3],N=r.data.get(i.dataId).values,x=d(c,4),S=x[0],T=x[1],F=x[2],M=x[3],A=r.data.get(s.dataId).values,w=d(f,4),D=w[0],_=w[1],E=w[2],z=w[3],W=h.batchSize,C=h.filterDepth,H=h.filterHeight,P=h.filterWidth,R=h.inChannels,B=h.inDepth,O=h.inHeight,G=h.inWidth,L=h.outChannels,V=h.outDepth,q=h.outHeight,U=h.outWidth,j=h.strideDepth,Z=h.strideHeight,K=h.strideWidth,Y=C-1-h.padInfo.front,J=H-1-h.padInfo.top,Q=P-1-h.padInfo.left,X=0;X<W;++X)for(var $=0;$<R;++$)for(var ee=0;ee<B;++ee)for(var ae=ee-Y,te=Math.max(0,Math.ceil(ae/j)),re=Math.min(V,(C+ae)/j),ne=0;ne<O;++ne)for(var ie=ne-J,se=Math.max(0,Math.ceil(ie/Z)),oe=Math.min(q,(H+ie)/Z),ue=0;ue<G;++ue){for(var de=ue-Q,le=Math.max(0,Math.ceil(de/K)),pe=Math.min(U,(P+de)/K),ce=0,fe=te;fe<re;++fe)for(var he=fe*j-ae,me=se;me<oe;++me)for(var ve=me*Z-ie,ke=le;ke<pe;++ke)for(var ge=S*X+T*fe+F*me+M*ke,be=D*(C-1-he)+_*(H-1-ve)+E*(P-1-(ke*K-de))+z*$,Ie=0;Ie<L;++Ie){ce+=N[ge+Ie]*A[be+Ie]}v[g*X+b*ee+I*ne+y*ue+$]=ce}return r.makeTensorInfo(m.shape,m.dtype,m.values)}},Mt=C(a.Cos,(function(e){return Math.cos(e)})),At={kernelName:a.Cos,backendName:"cpu",kernelFunc:Mt},wt=C(a.Cosh,(function(e){return Math.cosh(e)})),Dt={kernelName:a.Cosh,backendName:"cpu",kernelFunc:wt};var _t={kernelName:a.CropAndResize,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,r=e.backend,n=e.attrs,i=t.image,s=t.boxes,o=t.boxInd,u=n.cropSize,l=n.method,p=n.extrapolationValue,c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=s.shape[0],g=d(u,2),b=g[0],I=g[1],y=a.buffer([k,b,I,v],"float32"),N=r.data.get(s.dataId).values,x=r.data.get(o.dataId).values,S=r.data.get(i.dataId).values,T=a.util.computeStrides(i.shape),F=a.util.computeStrides(y.shape),M=0;M<k;M++){var A=4*M,w=N[A],D=N[A+1],_=N[A+2],E=N[A+3],z=x[M];if(!(z>=f))for(var W=b>1?(_-w)*(h-1)/(b-1):0,C=I>1?(E-D)*(m-1)/(I-1):0,H=0;H<b;H++){var P=b>1?w*(h-1)+H*W:.5*(w+_)*(h-1);if(P<0||P>h-1)for(var R=0;R<I;R++)for(var B=0;B<v;B++){var O=B+R*F[2]+H*F[1]+M*F[0];y.values[O]=p}else if("bilinear"===l){var G=Math.floor(P),L=Math.ceil(P),V=P-G;for(R=0;R<I;R++){if((X=I>1?D*(m-1)+R*C:.5*(D+E)*(m-1))<0||X>m-1)for(B=0;B<v;B++){O=B+R*F[2]+H*F[1]+M*F[0];y.values[O]=p}else{var q=Math.floor(X),U=Math.ceil(X),j=X-q;for(B=0;B<v;B++){var Z=S[O=B+q*T[2]+G*T[1]+z*T[0]],K=S[O=B+U*T[2]+G*T[1]+z*T[0]],Y=S[O=B+q*T[2]+L*T[1]+z*T[0]],J=Z+(K-Z)*j,Q=Y+(S[O=B+U*T[2]+L*T[1]+z*T[0]]-Y)*j;O=B+R*F[2]+H*F[1]+M*F[0],y.values[O]=J+(Q-J)*V}}}}else for(R=0;R<I;++R){var X;if((X=I>1?D*(m-1)+R*C:.5*(D+E)*(m-1))<0||X>m-1)for(B=0;B<v;B++){O=B+R*F[2]+H*F[1]+M*F[0];y.values[O]=p}else{var $=Math.round(X),ee=Math.round(P);for(B=0;B<v;B++){var ae=B+$*T[2]+ee*T[1]+z*T[0],te=B+R*F[2]+H*F[1]+M*F[0];y.values[te]=S[ae]}}}}}return r.makeTensorInfo(y.shape,y.dtype,y.values)}};var Et={kernelName:a.Cumprod,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis,o=n.exclusive,u=n.reverse;p(i,"cumprod");var d=a.backend_util.getAxesPermutation([s],i.shape.length),l=i;null!=d&&(l=We({inputs:{x:i},backend:r,attrs:{perm:d}}));var c=a.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(c!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most axis="+(l.shape.length-1)+" but got axis="+c);for(var f=a.upcastType(l.dtype,"int32"),h=a.util.makeOnesTypedArray(a.util.sizeFromShape(l.shape),f),m=r.data.get(l.dataId).values,v=l.shape[l.shape.length-1],k=u?function(e,a){return e+v-a-1}:function(e,a){return e+a},g=0;g<m.length;g+=v)for(var b=0;b<v;b++){var I=k(g,b);if(0===b)h[I]=o?1:m[I];else{var y=k(g,b-1);h[I]=o?m[y]*h[y]:m[I]*h[y]}}var N=r.makeTensorInfo(l.shape,f,h);if(null!=d){var x=We({inputs:{x:N},backend:r,attrs:{perm:a.backend_util.getUndoAxesPermutation(d)}});return r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(l),x}return N}};var zt={kernelName:a.Cumsum,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis,o=n.exclusive,u=n.reverse;p(i,"cumsum");var d=a.backend_util.getAxesPermutation([s],i.shape.length),l=i;null!=d&&(l=We({inputs:{x:i},backend:r,attrs:{perm:d}}));var c=a.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(c!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(l.shape.length-1)+" but got axis="+c);for(var f=a.upcastType(l.dtype,"int32"),h=a.util.makeZerosTypedArray(a.util.sizeFromShape(l.shape),f),m=r.data.get(l.dataId).values,v=l.shape[l.shape.length-1],k=u?function(e,a){return e+v-a-1}:function(e,a){return e+a},g=0;g<m.length;g+=v)for(var b=0;b<v;b++){var I=k(g,b);if(0===b)h[I]=o?0:m[I];else{var y=k(g,b-1);h[I]=o?m[y]+h[y]:m[I]+h[y]}}var N=r.makeTensorInfo(l.shape,f,h);if(null!=d){var x=We({inputs:{x:N},backend:r,attrs:{perm:a.backend_util.getUndoAxesPermutation(d)}});return r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(l),x}return N}};var Wt={kernelName:a.DenseBincount,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.x,i=a.weights,s=r.size,o=r.binaryOutput;if(1===n.shape.length){var u=E(t.data.get(n.dataId).values,t.data.get(i.dataId).values,i.dtype,i.shape,s);return t.makeTensorInfo([s],i.dtype,u)}if(2===n.shape.length){var d=z(t.bufferSync(n),t.bufferSync(i),s,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+n.shape.length+".")}};var Ct={kernelName:a.DepthToSpace,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.blockSize,o=n.dataFormat;a.util.assert("NHWC"===o,(function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+o}));for(var u=i.shape[0],d=i.shape[1],l=i.shape[2],p=i.shape[3],c=d*s,f=l*s,h=p/(s*s),m=r.data.get(i.dataId).values,v=new Float32Array(u*c*f*h),k=0,g=0;g<u;++g)for(var b=0;b<c;++b)for(var I=Math.floor(b/s),y=b%s,N=0;N<f;++N)for(var x=Math.floor(N/s),S=(y*s+N%s)*h,T=0;T<h;++T){var F=T+S+p*(x+l*(I+d*g));v[k++]=m[F]}return r.makeTensorInfo([u,c,f,h],i.dtype,v)}};function Ht(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.filter,o=n.strides,u=n.pad,d=n.dilations,l=n.dimRoundingMode;p([i,s],"depthwiseConv2DNative");var c=a.util.computeStrides(i.shape),f=a.util.computeStrides(s.shape),h=d;null==h&&(h=[1,1]),a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(o,h),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+h+"'"}));for(var m=a.backend_util.computeConv2DInfo(i.shape,s.shape,o,h,u,l,!0),v=m.filterHeight,k=m.filterWidth,g=m.dilationHeight,b=m.dilationWidth,I=m.padInfo,y=I.left,N=I.top,x=m.outChannels/m.inChannels,S=new a.TensorBuffer(m.outShape,i.dtype),T=r.data.get(i.dataId).values,F=r.data.get(s.dataId).values,M=S.values,A=0;A<m.batchSize;++A)for(var w=A*c[0],D=A*S.strides[0],_=0;_<m.outHeight;++_)for(var E=D+_*S.strides[1],z=_*m.strideHeight-N,W=0;W<v;++W){var C=z+W*g;if(!(C<0||C>=m.inHeight))for(var H=W*f[0],P=w+C*c[1],R=0;R<m.outWidth;++R)for(var B=E+R*S.strides[2],O=R*m.strideWidth-y,G=0;G<k;++G){var L=O+G*b;if(!(L<0||L>=m.inWidth))for(var V=H+G*f[1],q=P+L*m.inChannels,U=B,j=V,Z=0;Z<m.inChannels;++Z){for(var K=T[q+Z],Y=0;Y<x;++Y)M[U+Y]+=K*F[j+Y];U+=x,j+=x}}}return r.makeTensorInfo(S.shape,S.dtype,S.values)}var Pt={kernelName:a.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:Ht};var Rt={kernelName:a.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.dy,o=n.strides,u=n.dilations,d=n.pad,l=n.dimRoundingMode,c=n.filterShape;p([i,s],"depthwiseConv2dNativeBackpropFilter");for(var f=a.backend_util.computeConv2DInfo(i.shape,c,o,u,d,l,!0),h=f.strideHeight,m=f.strideWidth,v=f.filterHeight,k=f.filterWidth,g=new a.TensorBuffer(f.filterShape,"float32"),b=f.padInfo.left,I=f.padInfo.top,y=f.outChannels/f.inChannels,N=r.data.get(i.dataId).values,x=new a.TensorBuffer(i.shape,i.dtype,N),S=r.data.get(s.dataId).values,T=new a.TensorBuffer(s.shape,s.dtype,S),F=0;F<v;++F)for(var M=Math.max(0,Math.ceil((I-F)/h)),A=Math.min(f.outHeight,(f.inHeight+I-F)/h),w=0;w<k;++w)for(var D=Math.max(0,Math.ceil((b-w)/m)),_=Math.min(f.outWidth,(f.inWidth+b-w)/m),E=0;E<f.outChannels;++E){for(var z=Math.trunc(E/y),W=E%y,C=0,H=0;H<f.batchSize;++H)for(var P=M;P<A;++P)for(var R=F+P*h-I,B=D;B<_;++B){var O=w+B*m-b;C+=x.get(H,R,O,z)*T.get(H,P,B,E)}g.set(C,F,w,z,W)}return r.makeTensorInfo(g.shape,g.dtype,g.values)}};var Bt={kernelName:a.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.dy,s=t.filter,o=n.strides,u=n.dilations,l=n.pad,c=n.dimRoundingMode,f=n.inputShape;p([i,s],"depthwiseConv2DNativeBackpropInput");for(var h=a.util.computeStrides(i.shape),m=a.util.computeStrides(s.shape),v=a.backend_util.computeConv2DInfo(f,s.shape,o,u,l,c,!0),k=new a.TensorBuffer(v.inShape,"float32"),g=k.values,b=d(k.strides,3),I=b[0],y=b[1],N=b[2],x=r.data.get(i.dataId).values,S=d(h,3),T=S[0],F=S[1],M=S[2],A=r.data.get(s.dataId).values,w=d(m,3),D=w[0],_=w[1],E=w[2],z=v.batchSize,W=v.filterHeight,C=v.filterWidth,H=v.inChannels,P=v.inHeight,R=v.inWidth,B=v.outChannels,O=v.outHeight,G=v.outWidth,L=v.strideHeight,V=v.strideWidth,q=W-1-v.padInfo.top,U=C-1-v.padInfo.left,j=B/H,Z=0;Z<z;++Z)for(var K=0;K<H;++K)for(var Y=0;Y<P;++Y)for(var J=Y-q,Q=Math.max(0,Math.ceil(J/L)),X=Math.min(O,(W+J)/L),$=0;$<R;++$){for(var ee=$-U,ae=Math.max(0,Math.ceil(ee/V)),te=Math.min(G,(C+ee)/V),re=0,ne=Q;ne<X;++ne)for(var ie=ne*L-J,se=ae;se<te;++se)for(var oe=T*Z+F*ne+M*se,ue=D*(W-1-ie)+_*(C-1-(se*V-ee))+E*K,de=0;de<j;++de){re+=x[oe+(K*j+de)]*A[ue+de]}g[I*Z+y*Y+N*$+K]=re}return r.makeTensorInfo(k.shape,k.dtype,k.values)}};var Ot={kernelName:a.Diag,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,r=e.backend,n=t.x,i=a.util.sizeFromShape(n.shape),s=r.data.get(n.dataId).values,o=a.buffer([i,i],n.dtype),u=o.values,d=0;d<s.length;d++)u[d*i+d]=s[d];var p=l(n.shape,n.shape);return r.makeTensorInfo(p,o.dtype,o.values)}},Gt={kernelName:a.Dilation2D,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.filter,o=n.strides,u=n.pad,d=n.dilations,l=r,p=l.data.get(i.dataId).values,c=i.shape.length,f=l.data.get(s.dataId).values,h=s.shape.length,m=a.backend_util.computeDilation2DInfo(i.shape,s.shape,o,u,"NHWC",d),v=m.batchSize,k=m.inHeight,g=m.inWidth,b=m.inChannels,I=m.outHeight,y=m.outWidth,N=m.padInfo,x=m.strideHeight,S=m.strideWidth,T=m.filterHeight,F=m.filterWidth,M=m.dilationHeight,A=m.dilationWidth,w=m.outShape,D=a.util.sizeFromShape(w),_=w.length,E=a.util.getArrayFromDType(i.dtype,D),z=0;z<v;++z)for(var W=0;W<I;++W)for(var C=W*x-N.top,H=0;H<y;++H)for(var P=H*S-N.left,R=0;R<b;++R){for(var B=Number.MIN_SAFE_INTEGER,O=0;O<T;++O){var G=C+O*M;if(G>=0&&G<k)for(var L=0;L<F;++L){var V=P+L*A;if(V>=0&&V<g){var q=a.util.locToIndex([z,G,V,R],c,a.util.computeStrides(i.shape)),U=a.util.locToIndex([O,L,R],h,a.util.computeStrides(s.shape)),j=p[q]+f[U];j>B&&(B=j)}}}E[a.util.locToIndex([z,W,H,R],_,a.util.computeStrides(w))]=B}return{dataId:l.write(a.util.toTypedArray(E,i.dtype),w,i.dtype),shape:w,dtype:i.dtype}}},Lt={kernelName:a.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.filter,o=t.dy,u=n.strides,d=n.pad,l=n.dilations,p=r,c=a.util.toNestedArray(i.shape,p.data.get(i.dataId).values),f=a.util.toNestedArray(s.shape,p.data.get(s.dataId).values),h=a.backend_util.computeDilation2DInfo(i.shape,s.shape,u,d,"NHWC",l),m=h.batchSize,v=h.inHeight,k=h.inWidth,g=h.inChannels,b=h.outHeight,I=h.outWidth,y=h.padInfo,N=h.strideHeight,x=h.strideWidth,S=h.filterHeight,T=h.filterWidth,F=h.dilationHeight,M=h.dilationWidth,A=h.outShape;a.util.assert(o.rank===A.length,(function(){return"Error in "+a.Dilation2DBackpropFilter+", dy must have the same rank as output "+A.length+", but got "+o.rank}));for(var w=a.util.toNestedArray(A,p.data.get(o.dataId).values),D=a.util.makeZerosNestedTypedArray(s.shape,s.dtype),_=0;_<m;++_)for(var E=0;E<b;++E)for(var z=E*N-y.top,W=0;W<I;++W)for(var C=W*x-y.left,H=0;H<g;++H){for(var P=Number.MIN_SAFE_INTEGER,R=0,B=0,O=0;O<S;++O){var G=z+O*F;if(G>=0&&G<v)for(var L=0;L<T;++L){var V=C+L*M;if(V>=0&&V<k){var q=c[_][G][V][H]+f[O][L][H];q>P&&(P=q,R=O,B=L)}}}D[R][B][H]+=w[_][E][W][H]}return{dataId:p.write(a.util.toTypedArray(D,i.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Vt={kernelName:a.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.filter,o=t.dy,u=n.strides,d=n.pad,l=n.dilations,p=r,c=a.util.toNestedArray(i.shape,p.data.get(i.dataId).values),f=a.util.toNestedArray(s.shape,p.data.get(s.dataId).values),h=a.backend_util.computeDilation2DInfo(i.shape,s.shape,u,d,"NHWC",l),m=h.batchSize,v=h.inHeight,k=h.inWidth,g=h.inChannels,b=h.outHeight,I=h.outWidth,y=h.padInfo,N=h.strideHeight,x=h.strideWidth,S=h.filterHeight,T=h.filterWidth,F=h.dilationHeight,M=h.dilationWidth,A=h.outShape;a.util.assert(o.rank===A.length,(function(){return"Error in "+a.Dilation2DBackpropInput+", dy must have the same rank as output "+A.length+", but got "+o.rank}));for(var w=a.util.toNestedArray(A,p.data.get(o.dataId).values),D=a.util.makeZerosNestedTypedArray(i.shape,i.dtype),_=0;_<m;++_)for(var E=0;E<b;++E)for(var z=E*N-y.top,W=0;W<I;++W)for(var C=W*x-y.left,H=0;H<g;++H){for(var P=Number.MIN_SAFE_INTEGER,R=z<0?0:z,B=C<0?0:C,O=0;O<S;++O){var G=z+O*F;if(G>=0&&G<v)for(var L=0;L<T;++L){var V=C+L*M;if(V>=0&&V<k){var q=c[_][G][V][H]+f[O][L][H];q>P&&(P=q,R=G,B=V)}}}D[_][R][B][H]+=w[_][E][W][H]}return{dataId:p.write(a.util.toTypedArray(D,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};function qt(e){var t,r=e.inputs,n=e.backend,i=e.attrs,s=r.x,o=i.axis,u=i.keepDims;p(s,"sum");var l=(t="bool"===s.dtype?S({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):I({inputs:{x:s},backend:n})).shape.length,c=a.util.parseAxisParam(o,t.shape),f=a.backend_util.getAxesPermutation(c,l),h=c,m=t;null!=f&&(m=We({inputs:{x:t},backend:n,attrs:{perm:f}}),h=a.backend_util.getInnerMostAxes(h.length,l)),a.backend_util.assertAxesAreInnerMostDims("sum",h,m.shape.length);for(var v=d(a.backend_util.computeOutAndReduceShapes(m.shape,h),2),k=v[0],g=v[1],y=b(n,k,a.backend_util.upcastType(m.dtype,"int32")),N=a.util.sizeFromShape(g),x=n.data.get(y.dataId).values,T=n.data.get(m.dataId).values,F=0;F<x.length;++F){for(var M=F*N,A=0,w=0;w<N;++w)A+=T[M+w];x[F]=A}if(u){var D=y;y=_a({inputs:{x:y},backend:n,attrs:{shape:a.backend_util.expandShapeToKeepDim(y.shape,c)}}),n.disposeIntermediateTensorInfo(D)}return n.disposeIntermediateTensorInfo(t),null!=f&&n.disposeIntermediateTensorInfo(m),y}var Ut={kernelName:a.Sum,backendName:"cpu",kernelFunc:qt};var jt={kernelName:a.Einsum,backendName:"cpu",kernelFunc:function(e){var t,r,n,i,s=e.inputs,o=e.backend,d=e.attrs.equation,l=s,p=a.backend_util.decodeEinsumEquation(d,l.length),c=p.allDims,f=p.summedDims,h=p.idDims;a.backend_util.checkEinsumDimSizes(c.length,h,l);for(var m=a.backend_util.getEinsumComputePath(f,h),v=m.path,k=m.steps,g=k.length,b=null,I=c.length,y=[],N=0;N<g;++N){try{for(var x=(t=void 0,u(k[N])),S=x.next();!S.done;S=x.next()){var T=S.value,F=a.backend_util.getEinsumPermutation(I,h[T]),M=F.permutationIndices,A=F.expandDims,w=void 0;a.backend_util.isIdentityPermutation(M)?w=l[T]:(w=We({inputs:{x:l[T]},backend:o,attrs:{perm:M}}),y.push(w));for(var D=w.shape.slice(),_=0;_<A.length;++_)D.splice(A[_],0,1);a.util.arraysEqual(w.shape,D)||(w=_a({inputs:{x:w},backend:o,attrs:{shape:D}}),y.push(w)),null===b?b=w:(b=Fe({inputs:{a:w,b:b},backend:o}),y.push(b))}}catch(e){t={error:e}}finally{try{S&&!S.done&&(r=x.return)&&r.call(x)}finally{if(t)throw t.error}}N<g-1&&(v[N]>=0&&(b=qt({inputs:{x:b},backend:o,attrs:{axis:v[N]-(c.length-I),keepDims:!1}}),y.push(b)),I--)}try{for(var E=u(y),z=E.next();!z.done;z=E.next()){var W=z.value;W!==b&&o.disposeIntermediateTensorInfo(W)}}catch(e){n={error:e}}finally{try{z&&!z.done&&(i=E.return)&&i.call(E)}finally{if(n)throw n.error}}return b}};var Zt={kernelName:a.EluGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=t.dy,i=t.y;p([n,i],"eluGrad");for(var s=new Float32Array(a.util.sizeFromShape(i.shape)),o=r.data.get(i.dataId).values,u=r.data.get(n.dataId).values,d=0;d<o.length;++d){var l=o[d];s[d]=l>=1?u[d]:u[d]*(l+1)}return r.makeTensorInfo(i.shape,"float32",s)}},Kt=a.backend_util.ERF_P,Yt=a.backend_util.ERF_A1,Jt=a.backend_util.ERF_A2,Qt=a.backend_util.ERF_A3,Xt=a.backend_util.ERF_A4,$t=a.backend_util.ERF_A5,er=C(a.Erf,(function(e){var a=Math.sign(e),t=Math.abs(e),r=1/(1+Kt*t);return a*(1-(((($t*r+Xt)*r+Qt)*r+Jt)*r+Yt)*r*Math.exp(-t*t))})),ar={kernelName:a.Erf,backendName:"cpu",kernelFunc:er};function tr(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.input,s=n.dim,o=i.shape.length,u=i.shape.slice(),d=s;return s<0&&(a.util.assert(-(o+1)<=s,(function(){return"Axis must be in the interval ["+-(o+1)+", "+o+"]"})),d=o+s+1),u.splice(d,0,1),_a({inputs:{x:i},backend:r,attrs:{shape:u}})}var rr={kernelName:a.ExpandDims,backendName:"cpu",kernelFunc:tr},nr=v((function(e,a){return e/a})),ir=F(a.RealDiv,nr),sr={kernelName:a.RealDiv,backendName:"cpu",kernelFunc:ir};function or(e,t,r){for(var n=e.shape,i=n[0],s=n[1],o=r.data.get(e.dataId),u=o.complexTensorInfos.real,d=o.complexTensorInfos.imag,l=[i,s],p=a.util.sizeFromShape(l),c=a.util.getTypedArrayFromDType("float32",p),f=a.util.getTypedArrayFromDType("float32",p),h=0;h<i;h++){for(var m=je({inputs:{x:u},backend:r,attrs:{begin:[h,0],size:[1,s]}}),v=je({inputs:{x:d},backend:r,attrs:{begin:[h,0],size:[1,s]}}),g=k({inputs:{real:m,imag:v},backend:r}),b=ur(g,t,r),I=b.real,y=b.imag,N=a.backend_util.mergeRealAndImagArrays(I,y),x=0;x<s;x++){var S=a.backend_util.getComplexWithIndex(N,x);c[h*s+x]=S.real,f[h*s+x]=S.imag}r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(g)}var T=r.makeTensorInfo(l,"float32",c),F=r.makeTensorInfo(l,"float32",f),M=k({inputs:{real:T,imag:F},backend:r});return r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(F),M}function ur(e,t,r){var n=a.util.sizeFromShape(e.shape),i=r.data.get(e.dataId),s=r.data.get(i.complexTensorInfos.real.dataId).values,o=r.data.get(i.complexTensorInfos.imag.dataId).values;if(0==((g=n)&g-1)){var u=dr(s,o,n,t,r),d=[e.shape[0],e.shape[1]];if(t){var l=r.makeTensorInfo(d,"float32",u.real),p=r.makeTensorInfo(d,"float32",u.imag),c=r.makeTensorInfo([],"float32",a.util.createScalarValue(n,"float32")),f=I({inputs:{x:c},backend:r}),h=sr.kernelFunc({inputs:{a:l,b:c},backend:r}),m=sr.kernelFunc({inputs:{a:p,b:f},backend:r}),v=r.data.get(h.dataId).values,k=r.data.get(m.dataId).values;return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(m),{real:v,imag:k}}return u}var g,b=function(e,t,r){for(var n=new Float32Array(2*t),i=0;i<t;i++){for(var s=0,o=0,u=0;u<t;u++){var d=a.backend_util.exponent(i*u,t,r),l=a.backend_util.getComplexWithIndex(e,u);s+=l.real*d.real-l.imag*d.imag,o+=l.real*d.imag+l.imag*d.real}r&&(s/=t,o/=t),a.backend_util.assignToTypedArray(n,s,o,i)}return n}(a.backend_util.mergeRealAndImagArrays(s,o),n,t);return a.backend_util.splitRealAndImagArrays(b)}function dr(e,t,r,n,i){if(1===r)return{real:e,imag:t};var s=a.backend_util.mergeRealAndImagArrays(e,t),o=r/2,u=a.backend_util.complexWithEvenIndex(s),d=u.real,l=u.imag,p=[d.length],c=i.makeTensorInfo(p,"float32",d),f=i.makeTensorInfo(p,"float32",l),h=k({inputs:{real:c,imag:f},backend:i}),m=a.backend_util.complexWithOddIndex(s),v=m.real,g=m.imag,b=[v.length],I=i.makeTensorInfo(b,"float32",v),y=i.makeTensorInfo(b,"float32",g),x=k({inputs:{real:I,imag:y},backend:i}),S=dr(d,l,o,n,i),T=S.real,F=S.imag,M=[T.length],A=i.makeTensorInfo(M,"float32",T),w=i.makeTensorInfo(M,"float32",F),_=k({inputs:{real:A,imag:w},backend:i}),E=dr(v,g,o,n,i),z=E.real,W=E.imag,C=[z.length],H=i.makeTensorInfo(C,"float32",z),P=i.makeTensorInfo(C,"float32",W),R=k({inputs:{real:H,imag:P},backend:i}),B=a.backend_util.exponents(r,n),O=[B.real.length],G=i.makeTensorInfo(O,"float32",B.real),L=i.makeTensorInfo(O,"float32",B.imag),V=k({inputs:{real:G,imag:L},backend:i}),q=Fe({inputs:{a:V,b:R},backend:i}),U=D({inputs:{a:_,b:q},backend:i}),j=pa({inputs:{a:_,b:q},backend:i}),Z=N({inputs:{input:U},backend:i}),K=N({inputs:{input:j},backend:i}),Y=vt({inputs:{input:U},backend:i}),J=vt({inputs:{input:j},backend:i}),Q=gt({inputs:[Z,K],backend:i,attrs:{axis:0}}),X=gt({inputs:[Y,J],backend:i,attrs:{axis:0}}),$=i.data.get(Q.dataId).values,ee=i.data.get(X.dataId).values;return i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(I),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(R),i.disposeIntermediateTensorInfo(G),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(Z),i.disposeIntermediateTensorInfo(Y),i.disposeIntermediateTensorInfo(K),i.disposeIntermediateTensorInfo(J),i.disposeIntermediateTensorInfo(Q),i.disposeIntermediateTensorInfo(X),{real:$,imag:ee}}var lr={kernelName:a.FFT,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=t.input,i=a.util.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],o=_a({inputs:{x:n},backend:r,attrs:{shape:[i/s,s]}}),u=or(o,!1,r),d=_a({inputs:{x:u},backend:r,attrs:{shape:n.shape}});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),d}};function pr(e){var t=e.backend,r=e.attrs,n=r.shape,i=r.value,s=r.dtype||a.util.inferDtype(i),o=a.util.getArrayFromDType(s,a.util.sizeFromShape(n));return function(e,a,t){e.fill(a)}(o,i),t.makeTensorInfo(n,s,o)}var cr={kernelName:a.Fill,backendName:"cpu",kernelFunc:pr};var fr={kernelName:a.FlipLeftRight,backendName:"cpu",kernelFunc:function(e){var t=e.inputs;e.attrs;for(var r=e.backend,n=t.image,i=r,s=a.util.getTypedArrayFromDType(n.dtype,a.util.sizeFromShape(n.shape)),o=d(n.shape,4),u=o[0],l=o[1],p=o[2],c=o[3],f=i.data.get(n.dataId).values,h=0;h<u;h++)for(var m=h*p*l*c,v=0;v<l;v++)for(var k=v*(p*c),g=0;g<p;g++)for(var b=g*c,I=0;I<c;I++){var y=Math.round(p-g-1),N=m+k+b+I,x=f[N];if(y>=0&&y<p)x=f[m+k+y*c+I];s[N]=x}return{dataId:i.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},hr=v((function(e,a){return Math.floor(e/a)})),mr=F(a.FloorDiv,hr,null,"int32"),vr={kernelName:a.FloorDiv,backendName:"cpu",kernelFunc:mr};var kr={kernelName:a.FusedConv2D,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.x,i=a.filter,s=a.bias,o=a.preluActivationWeights,u=r.strides,d=r.pad,l=r.dataFormat,p=r.dilations,c=r.dimRoundingMode,f=r.activation,h=r.leakyreluAlpha,m=It({inputs:{x:n,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:l,dilations:p,dimRoundingMode:c}});if(s){var v=m;m=D({inputs:{a:m,b:s},backend:t}),t.disposeIntermediateTensorInfo(v)}if(f){v=m;m=Da(t,m,f,o,h),t.disposeIntermediateTensorInfo(v)}return m}};var gr={kernelName:a.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.x,i=a.filter,s=a.bias,o=a.preluActivationWeights,u=r.strides,d=r.pad,l=r.dataFormat,p=r.dilations,c=r.dimRoundingMode,f=r.activation,h=r.leakyreluAlpha,m=Ht({inputs:{x:n,filter:i},backend:t,attrs:{strides:u,pad:d,dataFormat:l,dilations:p,dimRoundingMode:c}});if(s){var v=m;m=D({inputs:{a:m,b:s},backend:t}),t.disposeIntermediateTensorInfo(v)}if(f){v=m;m=Da(t,m,f,o,h),t.disposeIntermediateTensorInfo(v)}return m}};var br={kernelName:a.GatherNd,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=t.params,i=t.indices,s=a.util.sizeFromShape(n.shape),o=i.shape,u=o[o.length-1],l=d(a.backend_util.prepareAndValidate(n,i),4),p=l[0],c=l[1],f=l[2],h=l[3];if(0===c)return r.makeTensorInfo(p,n.dtype,[]);var m=$(r.data.get(i.dataId).values,r.bufferSync(n),n.dtype,c,u,f,h,n.shape,s);return r.makeTensorInfo(p,n.dtype,m.values)}};var Ir={kernelName:a.GatherV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.indices,o=n.axis,u=n.batchDims;p([i,s],"gatherV2");for(var d=a.util.parseAxisParam(o,i.shape)[0],l=r.data.get(s.dataId).values,c=i.shape[d],f=function(e){var t=l[e];a.util.assert(t<=c-1&&t>=0,(function(){return"GatherV2: the index value "+t+" is not in [0, "+(c-1)+"]"}))},h=0;h<l.length;++h)f(h);var m=u;null==u&&(m=0);var v=a.util.sizeFromShape(s.shape),k=a.backend_util.segment_util.collectGatherOpShapeInfo(i,s,d,m),g=_a({inputs:{x:i},backend:r,attrs:{shape:[k.batchSize,k.outerSize,k.dimSize,k.sliceSize]}}),b=_a({inputs:{x:s},backend:r,attrs:{shape:[k.batchSize,v/k.batchSize]}}),I=[k.batchSize,k.outerSize,v/k.batchSize,k.sliceSize],y=r.bufferSync(b),N=ee(r.bufferSync(g),y,I);return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),r.makeTensorInfo(k.outputShape,N.dtype,N.values)}};var yr={kernelName:a.IFFT,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=t.input,i=a.util.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],o=_a({inputs:{x:n},backend:r,attrs:{shape:[i/s,s]}}),u=or(o,!0,r),d=_a({inputs:{x:u},backend:r,attrs:{shape:n.shape}});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),d}},Nr=C(a.IsFinite,(function(e){return Number.isFinite(e)?1:0}),"bool"),xr={kernelName:a.IsFinite,backendName:"cpu",kernelFunc:Nr},Sr=C(a.IsInf,(function(e){return Math.abs(e)===1/0?1:0}),"bool"),Tr={kernelName:a.IsInf,backendName:"cpu",kernelFunc:Sr},Fr=C(a.IsNan,(function(e){return Number.isNaN(e)?1:0}),"bool"),Mr={kernelName:a.IsNan,backendName:"cpu",kernelFunc:Fr};var Ar={kernelName:a.LinSpace,backendName:"cpu",kernelFunc:function(e){var a=e.backend,t=e.attrs,r=fe(t.start,t.stop,t.num);return a.makeTensorInfo([r.length],"float32",r)}},wr=C(a.Log1p,(function(e){return Math.log1p(e)})),Dr={kernelName:a.Log1p,backendName:"cpu",kernelFunc:wr},_r=v((function(e,a){return e&&a})),Er=F(a.LogicalAnd,_r,null,"bool"),zr={kernelName:a.LogicalAnd,backendName:"cpu",kernelFunc:Er},Wr=C(a.LogicalNot,(function(e){return e?0:1}),"bool"),Cr={kernelName:a.LogicalNot,backendName:"cpu",kernelFunc:Wr},Hr=v((function(e,a){return e||a})),Pr=F(a.LogicalOr,Hr,null,"bool"),Rr={kernelName:a.LogicalOr,backendName:"cpu",kernelFunc:Pr};var Br={kernelName:a.LRN,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.depthRadius,o=n.bias,u=n.alpha,d=n.beta;p(i,"LRN");var l=i.shape[3],c=l-1,f=r.data.get(i.dataId).values,h=a.util.sizeFromShape(i.shape),m=new Float32Array(h);function v(e){for(var a=e%l,t=e-a+Math.max(0,a-s),r=e-a+Math.min(a+s,c),n=0;t<=r;t++){var i=f[t];n+=i*i}return n}for(var k=0;k<h;k++){var g=v(k),b=f[k]*Math.pow(o+u*g,-d);m[k]=b}return r.makeTensorInfo(i.shape,i.dtype,m)}};var Or={kernelName:a.LRNGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.y,o=t.dy,u=n.depthRadius,d=n.bias,l=n.alpha,c=n.beta;p(o,"LRNGrad");for(var f=a.util.sizeFromShape(o.shape),h=o.shape[3],m=r.data.get(o.dataId).values,v=r.data.get(i.dataId).values,k=r.data.get(s.dataId).values,g=new Float32Array(f),b=f,I=0;I<b;I++){for(var y=I%h,N=I-y+Math.max(0,y-u),x=I-y+Math.min(h,y+u+1),S=0,T=N;T<x;T++)S+=Math.pow(v[T],2);S=l*S+d;for(T=N;T<x;T++){var F=-2*l*c*v[T]*k[I]/S;I===T&&(F+=Math.pow(S,-c)),F*=m[I],g[T]+=F}}return r.makeTensorInfo(o.shape,i.dtype,g)}};function Gr(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.reductionIndices,o=n.keepDims,u=r,l=i.shape,c=l.length,f=a.util.parseAxisParam(s,l),h=f,m=a.backend_util.getAxesPermutation(h,c),v=u.data.get(i.dataId).values;if(null!=m){for(var k=new Array(c),g=0;g<k.length;g++)k[g]=l[m[g]];v=ze(v,l,i.dtype,m,k),h=a.backend_util.getInnerMostAxes(h.length,c),l=k}p(i,"max"),a.backend_util.assertAxesAreInnerMostDims("max",h,c);var b=d(a.backend_util.computeOutAndReduceShapes(l,h),2),I=b[0],y=b[1],N=ke(v,a.util.sizeFromShape(y),I,i.dtype),x=u.write(N,I,i.dtype),S=I;o&&(S=k=a.backend_util.expandShapeToKeepDim(I,f));return{dataId:x,shape:S,dtype:i.dtype}}var Lr={kernelName:a.Max,backendName:"cpu",kernelFunc:Gr};var Vr={kernelName:a.MaxPool,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x;p(i,"maxPool");var s=n.filterSize,o=n.strides,u=n.pad,d=n.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(o,1),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+o+" and dilations '1'"}));var l,c=a.backend_util.computePool2DInfo(i.shape,s,o,1,u,d);if(1===c.filterWidth&&1===c.filterHeight&&a.util.arraysEqual(c.inShape,c.outShape))l=I({inputs:{x:i},backend:r});else{var f=r.data.get(i.dataId).values,h=a.util.computeStrides(i.shape),m=tt(f,i.shape,i.dtype,h,c,"max");l=r.makeTensorInfo(c.outShape,i.dtype,m.values)}return l}};var qr={kernelName:a.MaxPool3D,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.filterSize,o=n.strides,u=n.pad,d=n.dimRoundingMode,l=n.dataFormat;p(i,"maxPool3d");var c=a.backend_util.computePool3DInfo(i.shape,s,o,1,u,d,l),f=nt(r.data.get(i.dataId).values,i.shape,i.dtype,a.util.computeStrides(i.shape),c,"max");return r.makeTensorInfo(f.shape,"float32",f.values)}};var Ur={kernelName:a.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.dy,s=t.input,o=n.filterSize,u=n.strides,d=n.pad,l=n.dimRoundingMode;p([i,s],"maxPool3DGrad");for(var c=a.backend_util.computePool3DInfo(s.shape,o,u,1,d,l),f=function(e,t){for(var r=a.buffer(t.outShape,"int32"),n=t.strideDepth,i=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,u=t.dilationHeight,d=t.dilationWidth,l=t.effectiveFilterDepth,p=t.effectiveFilterHeight,c=t.effectiveFilterWidth,f=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left,v=0;v<t.batchSize;++v)for(var k=0;k<t.inChannels;++k)for(var g=0;g<t.outDepth;++g){for(var b=g*n-f,I=b;I<0;)I+=o;for(var y=Math.min(t.inDepth,l+b),N=0;N<t.outHeight;++N){for(var x=N*i-h,S=x;S<0;)S+=u;for(var T=Math.min(t.inHeight,p+x),F=0;F<t.outWidth;++F){for(var M=F*s-m,A=M;A<0;)A+=d;for(var w=Math.min(t.inWidth,c+M),D=Number.NEGATIVE_INFINITY,_=-1,E=I;E<y;E+=o)for(var z=E-b,W=S;W<T;W+=u)for(var C=W-x,H=A;H<w;H+=d){var P=H-M,R=e.get(v,E,W,H,k);R>=D&&(D=R,_=z*p*c+C*p+P)}r.set(_,v,g,N,F,k)}}}return r}(r.bufferSync(s),c),h=c.strideDepth,m=c.strideHeight,v=c.strideWidth,k=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,I=c.effectiveFilterDepth,y=c.effectiveFilterHeight,N=c.effectiveFilterWidth,x=I-1-c.padInfo.front,S=N-1-c.padInfo.left,T=y-1-c.padInfo.top,F=a.buffer(s.shape,"float32"),M=r.bufferSync(i),A=0;A<c.batchSize;++A)for(var w=0;w<c.inChannels;++w)for(var D=0;D<c.inDepth;++D)for(var _=0;_<c.inHeight;++_)for(var E=0;E<c.inWidth;++E){for(var z=D-x,W=_-T,C=E-S,H=0,P=0;P<I;P+=k){var R=(z+P)/h;if(!(R<0||R>=c.outDepth||Math.floor(R)!==R))for(var B=0;B<y;B+=g){var O=(W+B)/m;if(!(O<0||O>=c.outHeight||Math.floor(O)!==O))for(var G=0;G<N;G+=b){var L=(C+G)/v;if(!(L<0||L>=c.outWidth||Math.floor(L)!==L)){var V=I*y*N-1-f.get(A,R,O,L,w)===P*y*N+B*N+G?1:0;if(0!==V)H+=M.get(A,R,O,L,w)*V}}}}F.set(H,A,D,_,E,w)}return r.makeTensorInfo(F.shape,F.dtype,F.values)}};var jr={kernelName:a.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.dy,s=t.input,o=s;p([s,t.output],"maxPoolGrad");for(var u=n.filterSize,d=n.strides,l=n.pad,c=n.dimRoundingMode,f=a.backend_util.computePool2DInfo(o.shape,u,d,1,l,c),h=r.data.get(o.dataId).values,m=a.buffer(f.outShape,o.dtype,rt(h,o.shape,o.dtype,f).values),v=f.strideHeight,k=f.strideWidth,g=f.dilationHeight,b=f.dilationWidth,I=f.effectiveFilterHeight,y=f.effectiveFilterWidth,N=y-1-f.padInfo.left,x=I-1-f.padInfo.top,S=a.buffer(o.shape,"float32"),T=r.data.get(i.dataId).values,F=a.buffer(i.shape,"float32",T),M=0;M<f.batchSize;++M)for(var A=0;A<f.inChannels;++A)for(var w=0;w<f.inHeight;++w)for(var D=0;D<f.inWidth;++D){for(var _=w-x,E=D-N,z=0,W=0;W<I;W+=g){var C=(_+W)/v;if(!(C<0||C>=f.outHeight||Math.floor(C)!==C))for(var H=0;H<y;H+=b){var P=(E+H)/k;if(!(P<0||P>=f.outWidth||Math.floor(P)!==P)){var R=I*y-1-m.get(M,C,P,A)===W*y+H?1:0;if(0!==R)z+=F.get(M,C,P,A)*R}}}S.set(z,M,w,D,A)}return r.makeTensorInfo(S.shape,S.dtype,S.values)}};var Zr={kernelName:a.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.attrs,n=e.backend,i=t.x,s=r.filterSize,o=r.strides,u=r.pad,l=r.includeBatchInIndex,c=n;p(i,"MaxPoolWithArgmax");var f=c.data.get(i.dataId).values,h=a.backend_util.computePool2DInfo(i.shape,s,o,[1,1],u),m=d(function(e,t,r,n,i){var s=tt(e,0,r,a.util.computeStrides(t),i,"max"),o=rt(e,t,r,i,!0,n);return[s.values,o.values]}(f,i.shape,i.dtype,l,h),2),v=m[0],k=m[1],g=c.write(v,h.outShape,i.dtype),b=c.write(k,h.outShape,i.dtype);return[{dataId:g,shape:h.outShape,dtype:i.dtype},{dataId:b,shape:h.outShape,dtype:"int32"}]}};var Kr={kernelName:a.Mean,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis,o=n.keepDims,u=a.util.parseAxisParam(s,i.shape),d=a.backend_util.computeOutAndReduceShapes(i.shape,u)[1],l=a.util.sizeFromShape(d),p=[],c=r.makeTensorInfo([],"float32",new Float32Array([l]));p.push(c);var f=S({inputs:{x:i},backend:r,attrs:{dtype:"float32"}});p.push(f);var h=ir({inputs:{a:f,b:c},backend:r});p.push(h);var m=qt({inputs:{x:h},backend:r,attrs:{axis:s,keepDims:o}});return p.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),m}};var Yr={kernelName:a.Min,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.axis,o=n.keepDims;p(i,"min");var u=a.util.parseAxisParam(s,i.shape),l=u,c=a.backend_util.getAxesPermutation(l,i.shape.length),f=i;null!=c&&(f=We({inputs:{x:i},backend:r,attrs:{perm:c}}),l=a.backend_util.getInnerMostAxes(l.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",l,f.shape.length);for(var h=d(a.backend_util.computeOutAndReduceShapes(f.shape,l),2),m=h[0],v=h[1],k=a.util.sizeFromShape(v),g=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),b=r.data.get(f.dataId).values,I=0;I<g.length;++I){for(var y=I*k,N=b[y],x=0;x<k;++x){var S=b[y+x];(Number.isNaN(S)||S<N)&&(N=S)}g[I]=N}null!=c&&r.disposeIntermediateTensorInfo(f);var T=r.makeTensorInfo(m,f.dtype,g);if(o){var F=_a({inputs:{x:T},backend:r,attrs:{shape:a.backend_util.expandShapeToKeepDim(m,u)}});return r.disposeIntermediateTensorInfo(T),F}return T}};var Jr={kernelName:a.MirrorPad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.paddings,o=n.mode;p(i,"mirrorPad");for(var u=s.map((function(e,a){return e[0]+i.shape[a]+e[1]})),d=s.map((function(e){return e[0]})),l=s.map((function(e,a){return e[0]+i.shape[a]})),c="reflect"===o?0:1,f=r.data.get(i.dataId).values,h=i.shape.length,m=a.util.computeStrides(i.shape),v=a.util.sizeFromShape(u),k=u.length,g=a.util.computeStrides(u),b=a.util.getTypedArrayFromDType(i.dtype,v),I=0;I<v;I++){for(var y=a.util.indexToLoc(I,k,g),N=0;N<k;N++)y[N]<d[N]?y[N]=2*d[N]-y[N]-c:y[N]>=l[N]&&(y[N]=2*(l[N]-1)-y[N]+c);y=y.map((function(e,a){return e-d[a]}));var x=a.util.locToIndex(y,h,m);b[I]=f[x]}return{dataId:r.write(b,u,i.dtype),shape:u,dtype:i.dtype}}},Qr=v((function(e,a){var t=e%a;return e<0&&a<0||e>=0&&a>=0?t:(t+a)%a})),Xr=F(a.Mod,Qr),$r={kernelName:a.Mod,backendName:"cpu",kernelFunc:Xr};function en(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.logits,s=n.dim,o=i.shape.length,u=s;if(-1===u&&(u=o-1),u!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+o+" and dim was "+u);var d=a.util.parseAxisParam([u],i.shape),l=Gr({inputs:{x:i},backend:r,attrs:{reductionIndices:d,keepDims:!1}}),p=a.backend_util.expandShapeToKeepDim(l.shape,d),c=_a({inputs:{x:l},backend:r,attrs:{shape:p}}),f=pa({inputs:{a:i,b:c},backend:r}),h=U({inputs:{x:f},backend:r}),m=qt({inputs:{x:h},backend:r,attrs:{axis:d,keepDims:!1}}),v=_a({inputs:{x:m},backend:r,attrs:{shape:p}}),k=ir({inputs:{a:h,b:v},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(v),k}var an={kernelName:a.Softmax,backendName:"cpu",kernelFunc:en};var tn={kernelName:a.Multinomial,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,s=t.logits,o=i.numSamples,u=i.seed,d=i.normalized;p(s,"multinomial");for(var l=d?s:en({inputs:{logits:s},backend:r,attrs:{dim:-1}}),c=l.shape[0],f=l.shape[1],h=r.data.get(l.dataId).values,m=[c,o],v=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),"int32"),k=0;k<c;++k){var g=k*f,b=new Float32Array(f-1);b[0]=h[g];for(var I=1;I<b.length;++I)b[I]=b[I-1]+h[g+I];for(var y=n.alea(u.toString()),N=k*o,x=0;x<o;++x){var S=y();v[N+x]=b.length;for(I=0;I<b.length;I++)if(S<b[I]){v[N+x]=I;break}}}return d||r.disposeIntermediateTensorInfo(l),r.makeTensorInfo(m,"int32",v)}},rn=a.kernel_impls.nonMaxSuppressionV3Impl;var nn={kernelName:a.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.boxes,i=a.scores,s=r.maxOutputSize,o=r.iouThreshold,u=r.scoreThreshold;p(n,"NonMaxSuppression");var d=t.data.get(n.dataId).values,l=t.data.get(i.dataId).values,c=rn(d,l,s,o,u).selectedIndices;return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}},sn=a.kernel_impls.nonMaxSuppressionV4Impl;var on={kernelName:a.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.boxes,i=a.scores,s=r.maxOutputSize,o=r.iouThreshold,u=r.scoreThreshold,d=r.padToMaxOutputSize;p(n,"NonMaxSuppressionPadded");var l=t.data.get(n.dataId).values,c=t.data.get(i.dataId).values,f=sn(l,c,s,o,u,d),h=f.selectedIndices,m=f.validOutputs;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([m]))]}},un=a.kernel_impls.nonMaxSuppressionV5Impl;var dn={kernelName:a.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.boxes,i=a.scores,s=r.maxOutputSize,o=r.iouThreshold,u=r.scoreThreshold,d=r.softNmsSigma;p(n,"NonMaxSuppressionWithScore");var l=t.data.get(n.dataId).values,c=t.data.get(i.dataId).values,f=un(l,c,s,o,u,d),h=f.selectedIndices,m=f.selectedScores;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([m.length],"float32",new Float32Array(m))]}};var ln={kernelName:a.OneHot,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.indices,s=n.depth,o=n.onValue,u=n.offValue;p(i,"oneHot");var d=a.util.sizeFromShape(i.shape),c=new Float32Array(d*s);c.fill(u);for(var f=r.data.get(i.dataId).values,h=0;h<d;++h)f[h]>=0&&f[h]<s&&(c[h*s+f[h]]=o);return r.makeTensorInfo(l(i.shape,[s]),"int32",c)}};function pn(e){var a=e.inputs,t=e.backend,r=a.x;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){var n=N({inputs:{input:r},backend:t}),i=pn({inputs:{x:n},backend:t}),s=vt({inputs:{input:r},backend:t}),o=pn({inputs:{x:s},backend:t}),u=k({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),u}return pr({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var cn={kernelName:a.ZerosLike,backendName:"cpu",kernelFunc:pn};var fn={kernelName:a.OnesLike,backendName:"cpu",kernelFunc:function e(a){var t=a.inputs,r=a.backend,n=t.x;if("string"===n.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===n.dtype){var i=N({inputs:{input:n},backend:r}),s=e({inputs:{x:i},backend:r}),o=vt({inputs:{input:n},backend:r}),u=pn({inputs:{x:o},backend:r}),d=k({inputs:{real:s,imag:u},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(u),d}return pr({backend:r,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}};function hn(e){var t=e.inputs,r=e.backend,n=e.attrs.axis;if(1===t.length)return tr({inputs:{input:t[0]},backend:r,attrs:{dim:n}});var i=t[0].shape,s=t[0].dtype;t.forEach((function(e){a.util.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),a.util.assert(s===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var o=[],u=gt({inputs:t.map((function(e){var a=tr({inputs:{input:e},backend:r,attrs:{dim:n}});return o.push(a),a})),backend:r,attrs:{axis:n}});return o.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),u}var mn={kernelName:a.Pack,backendName:"cpu",kernelFunc:hn};var vn={kernelName:a.PadV2,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.paddings,o=n.constantValue;p(i,"pad");var u=s.map((function(e,a){return e[0]+i.shape[a]+e[1]})),d=s.map((function(e){return e[0]})),l=r.data.get(i.dataId).values,c=a.util.sizeFromShape(i.shape),f=i.shape.length,h=a.util.computeStrides(i.shape),m=a.util.sizeFromShape(u),v=u.length,k=a.util.computeStrides(u),g=a.util.getTypedArrayFromDType(i.dtype,m);0!==o&&g.fill(o);for(var b=0;b<c;b++){var I=a.util.indexToLoc(b,f,h).map((function(e,a){return e+d[a]}));g[a.util.locToIndex(I,v,k)]=l[b]}return{dataId:r.write(g,u,i.dtype),shape:u,dtype:i.dtype}}},kn=v((function(e,a){return Math.pow(e,a)})),gn=F(a.Pow,kn),bn={kernelName:a.Pow,backendName:"cpu",kernelFunc:gn};var In={kernelName:a.Range,backendName:"cpu",kernelFunc:function(e){var a=e.backend,t=e.attrs,r=t.start,n=t.stop,i=t.dtype,s=Re(r,n,t.step,i);return a.makeTensorInfo([s.length],i,s)}},yn=C(a.Reciprocal,(function(e){return 1/e})),Nn={kernelName:a.Reciprocal,backendName:"cpu",kernelFunc:yn};var xn={kernelName:a.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.images,s=n.alignCorners,o=n.halfPixelCenters,u=n.size;p(i,"resizeBilinear");for(var l=a.util.computeStrides(i.shape),c=d(u,2),f=c[0],h=c[1],m=d(i.shape,4),v=m[0],k=m[1],g=m[2],b=m[3],I=r.data.get(i.dataId).values,y=new Float32Array(a.util.sizeFromShape([v,f,h,b])),N=[s&&f>1?k-1:k,s&&h>1?g-1:g],x=[s&&f>1?f-1:f,s&&h>1?h-1:h],S=0,T=N[0]/x[0],F=N[1]/x[1],M=0;M<v;M++)for(var A=0;A<f;A++){var w=void 0;w=o?T*(A+.5)-.5:T*A;for(var D=Math.max(0,Math.floor(w)),_=w-D,E=Math.min(k-1,Math.ceil(w)),z=M*l[0]+D*l[1],W=M*l[0]+E*l[1],C=0;C<h;C++){var H=void 0;H=o?F*(C+.5)-.5:F*C;for(var P=Math.max(0,Math.floor(H)),R=H-P,B=Math.min(g-1,Math.ceil(H)),O=z+P*l[2],G=W+P*l[2],L=z+B*l[2],V=W+B*l[2],q=0;q<b;q++){var U=I[O+q],j=I[G+q],Z=U+(I[L+q]-U)*R,K=Z+(j+(I[V+q]-j)*R-Z)*_;y[S++]=K}}}return r.makeTensorInfo([v,f,h,b],"float32",y)}};var Sn={kernelName:a.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.images,s=t.dy,o=n.alignCorners;p([s,i],"resizeBilinearGrad");for(var u=a.util.computeStrides(i.shape),l=d(i.shape,4),c=l[0],f=l[1],h=l[2],m=l[3],v=d(s.shape,3),k=v[1],g=v[2],b=new Float32Array(c*f*h*m),I=[o&&k>1?f-1:f,o&&g>1?h-1:h],y=[o&&k>1?k-1:k,o&&g>1?g-1:g],N=I[0]/y[0],x=I[1]/y[1],S=r.data.get(s.dataId).values,T=0,F=0;F<c;F++)for(var M=F*u[0],A=0;A<k;A++)for(var w=A*N,D=Math.floor(w),_=Math.min(Math.ceil(w),f-1),E=M+D*u[1],z=M+_*u[1],W=w-D,C=1-W,H=0;H<g;H++)for(var P=H*x,R=Math.floor(P),B=Math.min(Math.ceil(P),h-1),O=P-R,G=1-O,L=E+R*u[2],V=E+B*u[2],q=z+R*u[2],U=z+B*u[2],j=C*G,Z=C*O,K=W*G,Y=W*O,J=0;J<m;J++){var Q=S[T++];b[L+J]+=Q*j,b[V+J]+=Q*Z,b[q+J]+=Q*K,b[U+J]+=Q*Y}return r.makeTensorInfo([c,h,f,m],"float32",b)}};var Tn={kernelName:a.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.images,s=n.alignCorners,o=n.halfPixelCenters,u=n.size;p(i,"resizeNearestNeighbor");for(var l=a.util.computeStrides(i.shape),c=d(u,2),f=c[0],h=c[1],m=d(i.shape,4),v=m[0],k=m[1],g=m[2],b=m[3],I=r.data.get(i.dataId).values,y=new Float32Array(v*f*h*b),N=[s&&f>1?k-1:k,s&&h>1?g-1:g],x=[s&&f>1?f-1:f,s&&h>1?h-1:h],S=N[0]/x[0],T=N[1]/x[1],F=0,M=0;M<v;M++)for(var A=M*l[0],w=0;w<f;w++){var D=o?S*(w+.5):S*w,_=Math.min(k-1,s?Math.round(D):Math.floor(D));o&&(_=Math.max(0,_));for(var E=A+_*l[1],z=0;z<h;z++){var W=o?T*(z+.5):T*z,C=Math.min(g-1,s?Math.round(W):Math.floor(W));o&&(C=Math.max(0,C));for(var H=E+C*l[2],P=0;P<b;P++){var R=I[H+P];y[F++]=R}}}return r.makeTensorInfo([v,f,h,b],i.dtype,y)}};var Fn={kernelName:a.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.images,s=t.dy,o=n.alignCorners;p([s,i],"resizeNearestNeighborGrad");for(var u=a.util.computeStrides(i.shape),l=a.util.computeStrides(s.shape),c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=d(s.shape,3),g=k[1],b=k[2],I=new Float32Array(f*h*m*v),y=r.data.get(s.dataId).values,N=[o&&g>1?h-1:h,o&&b>1?m-1:m],x=[o&&g>1?g-1:g,o&&b>1?b-1:b],S=N[0]/x[0],T=N[1]/x[1],F=1/S,M=1/T,A=2*Math.ceil(F)+2,w=2*Math.ceil(M)+2,D=0;D<f;D++)for(var _=D*u[0],E=0;E<h;E++)for(var z=_+E*u[1],W=Math.floor(E*F),C=Math.floor(W-A/2),H=0;H<m;H++)for(var P=z+H*u[2],R=Math.floor(H*M),B=Math.floor(R-w/2),O=0;O<v;O++){for(var G=0,L=0;L<A;L++){var V=L+C;if(!(V<0||V>=g)){var q=_+V*l[1],U=V*S;if(E===Math.min(h-1,o?Math.round(U):Math.floor(U)))for(var j=0;j<w;j++){var Z=j+B;if(!(Z<0||Z>=b)){var K=q+Z*l[2],Y=Z*T;H===Math.min(m-1,o?Math.round(Y):Math.floor(Y))&&(G+=y[K+O])}}}}I[P+O]=G}return r.makeTensorInfo(i.shape,i.dtype,I)}};var Mn={kernelName:a.Reverse,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.dims;p(i,"reverse");var o=i.shape.length,u=a.util.parseAxisParam(s,i.shape);if(0===o)return I({inputs:{x:i},backend:r});for(var d=new a.TensorBuffer(i.shape,i.dtype),c=r.bufferSync(i),f=function(e){var a=d.indexToLoc(e),t=a.slice();u.forEach((function(e){return t[e]=i.shape[e]-1-t[e]})),d.set.apply(d,l([c.get.apply(c,l(t))],a))},h=0;h<d.size;h++)f(h);return r.makeTensorInfo(d.shape,d.dtype,d.values)}},An={kernelName:a.RotateWithOffset,backendName:"cpu",kernelFunc:function(e){for(var t=e.inputs,r=e.attrs,n=e.backend,i=t.image,s=r.radians,o=r.fillValue,u=r.center,l=n,p=a.util.getTypedArrayFromDType(i.dtype,a.util.sizeFromShape(i.shape)),c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=d(a.backend_util.getImageCenter(u,h,m),2),g=k[0],b=k[1],I=Math.sin(s),y=Math.cos(s),N=l.data.get(i.dataId).values,x=0;x<f;x++)for(var S=x*m*h*v,T=0;T<h;T++)for(var F=T*(m*v),M=0;M<m;M++)for(var A=M*v,w=0;w<v;w++){var D=[f,T,M,w],_=D[2],E=D[1],z=(_-g)*y-(E-b)*I,W=(_-g)*I+(E-b)*y;z=Math.round(z+g),W=Math.round(W+b);var C=o;if("number"!=typeof o&&(C=3===w?255:o[w]),z>=0&&z<m&&W>=0&&W<h)C=N[S+W*(m*v)+z*v+w];p[S+F+A+w]=C}return{dataId:l.write(p,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},wn=C(a.Round,(function(e){var a=Math.floor(e);return e-a<.5?Math.floor(e):e-a>.5?Math.ceil(e):a%2==0?a:a+1})),Dn={kernelName:a.Round,backendName:"cpu",kernelFunc:wn};function _n(e,t,r,n,i,s,o,u,d,l){var p=[n/i,i],c=e.values,f=t.values;if(0===n)return a.buffer(r,t.dtype);var h=a.buffer(p,t.dtype);h.values.fill(d);for(var m=0;m<s;m++){for(var v=[],k=0,g=0;g<o;g++){var b=c[m*o+g];v.push(b),k+=b*u[g]}if(k<0||k>=n/i)throw new Error("Invalid indices: "+v+" does not index into "+r);for(var I=0;I<i;I++)l?h.values[k*i+I]+=f[m*i+I]:h.values[k*i+I]=0===t.rank?f[0]:f[m*i+I]}return h}var En={kernelName:a.ScatterNd,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.indices,s=t.updates,o=n.shape,u=a.backend_util.calculateShapes(s,i,o),d=u.sliceRank,l=u.numUpdates,p=u.sliceSize,c=u.strides,f=u.outputSize,h=_n(r.bufferSync(i),r.bufferSync(s),o,f,p,l,d,c,0,!0);return r.makeTensorInfo(o,h.dtype,h.values)}};var zn={kernelName:a.Select,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=t.condition,i=t.t,s=t.e;p([n,i,s],"select");for(var o=n.shape.length,u=r.data.get(n.dataId).values,d=r.data.get(i.dataId).values,l=r.data.get(s.dataId).values,c=a.upcastType(i.dtype,s.dtype),f=a.util.makeZerosTypedArray(a.util.sizeFromShape(i.shape),c),h=0,m=0===o||o>1||1===i.shape.length?1:a.util.sizeFromShape(i.shape.slice(1)),v=0;v<u.length;v++)for(var k=0;k<m;k++)1===u[v]?f[h++]=d[v]:f[h++]=l[v];return r.makeTensorInfo(i.shape,c,f)}},Wn=a.backend_util.SELU_SCALEALPHA,Cn=a.backend_util.SELU_SCALE,Hn=C(a.Selu,(function(e){return e>=0?Cn*e:Wn*(Math.exp(e)-1)})),Pn={kernelName:a.Selu,backendName:"cpu",kernelFunc:Hn},Rn=C(a.Sign,(function(e){return e<0?-1:e>0?1:0})),Bn={kernelName:a.Sign,backendName:"cpu",kernelFunc:Rn},On=C(a.Sin,(function(e){return Math.sin(e)})),Gn={kernelName:a.Sin,backendName:"cpu",kernelFunc:On},Ln=C(a.Sinh,(function(e){return Math.sinh(e)})),Vn={kernelName:a.Sinh,backendName:"cpu",kernelFunc:Ln},qn=Math.log(1.1920928955078125e-7)+2,Un=C(a.Softplus,(function(e){var a=e>-qn,t=e<qn,r=Math.exp(e);return t?r:a?e:Math.log(1+r)})),jn={kernelName:a.Softplus,backendName:"cpu",kernelFunc:Un};var Zn={kernelName:a.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.blockShape,o=n.paddings;p([i],"spaceToBatchND");var u=a.util.sizeFromShape(s),d=[[0,0]];d.push.apply(d,l(o));for(var c=1+s.length;c<i.shape.length;++c)d.push([0,0]);var f=vn.kernelFunc({inputs:{x:i},backend:r,attrs:{paddings:d,constantValue:0}}),h=a.backend_util.getReshaped(f.shape,s,u,!1),m=a.backend_util.getPermuted(h.length,s.length,!1),v=a.backend_util.getReshapedPermuted(f.shape,s,u,!1),k=_a({inputs:{x:f},backend:r,attrs:{shape:h}}),g=We({inputs:{x:k},backend:r,attrs:{perm:m}}),b=_a({inputs:{x:g},backend:r,attrs:{shape:v}});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(g),b}};var Kn={kernelName:a.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=a.indices,n=a.values,i=a.denseShape,s=a.defaultValue;if(1!==i.shape.length)throw new Error("Dense shape must be a vector, saw:\n        "+i.shape);if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n        "+r.shape);if(1!==n.shape.length)throw new Error("Values must be a vector, saw:\n        "+n.shape);if(0!==s.shape.length)throw new Error("Default value must be a scalar, saw:\n        "+s.shape);var o=t.data.get(r.dataId).values,u=t.data.get(n.dataId).values,l=t.data.get(i.dataId).values,p=t.data.get(s.dataId).values[0],c=d(Ke(o,r.shape,r.dtype,u,n.dtype,l,p),5),f=c[0],h=c[1],m=c[2],v=c[3],k=c[4];return[t.makeTensorInfo(h,r.dtype,f),t.makeTensorInfo([h[0]],n.dtype,m),t.makeTensorInfo([v.length],"bool",new Uint8Array(v.map((function(e){return Number(e)})))),t.makeTensorInfo([k.length],r.dtype,new Int32Array(k))]}};var Yn={kernelName:a.SparseReshape,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=a.inputIndices,n=a.inputShape,i=a.newShape;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape\n        "+r.shape);if(1!==n.shape.length)throw new Error("Input shape should be a vector but received shape\n        "+n.shape);if(1!==i.shape.length)throw new Error("Target shape should be a vector but received shape "+i.shape);var s=Array.from(t.data.get(n.dataId).values),o=t.data.get(r.dataId).values,u=Array.from(t.data.get(i.dataId).values),l=d(Ye(o,r.shape,r.dtype,s,u),3),p=l[0],c=l[1],f=l[2];return[t.makeTensorInfo(c,r.dtype,p),t.makeTensorInfo([f.length],i.dtype,new Int32Array(f))]}};var Jn={kernelName:a.SparseSegmentMean,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=a.data,n=a.indices,i=a.segmentIds;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==n.shape.length)throw new Error("Indices should be a vector but received shape\n          "+n.shape);if(1!==i.shape.length)throw new Error("Segment ids should be a vector but received shape\n          "+i.shape);if(n.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");var s=t.data.get(r.dataId).values,o=t.data.get(n.dataId).values,u=t.data.get(i.dataId).values,l=d(Je(s,r.shape,r.dtype,o,u,!0),2),p=l[0],c=l[1];return t.makeTensorInfo(c,r.dtype,p)}};var Qn={kernelName:a.SparseSegmentSum,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=a.data,n=a.indices,i=a.segmentIds;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==n.shape.length)throw new Error("Indices should be a vector but received shape\n         "+n.shape);if(1!==i.shape.length)throw new Error("Segment ids should be a vector but received shape\n         "+i.shape);if(n.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");var s=t.data.get(r.dataId).values,o=t.data.get(n.dataId).values,u=t.data.get(i.dataId).values,l=d(Je(s,r.shape,r.dtype,o,u),2),p=l[0],c=l[1];return t.makeTensorInfo(c,r.dtype,p)}};var Xn={kernelName:a.SparseToDense,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.sparseIndices,s=t.sparseValues,o=t.defaultValue,u=n.outputShape,d=a.backend_util.calculateShapes(s,i,u),l=d.sliceRank,p=d.numUpdates,c=d.sliceSize,f=d.strides,h=d.outputSize,m=_n(r.bufferSync(i),r.bufferSync(s),u,h,c,p,l,f,r.data.get(o.dataId).values[0],!1);return r.makeTensorInfo(u,m.dtype,m.values)}};var $n={kernelName:a.SplitV,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.numOrSizeSplits,o=n.axis,u=a.util.parseAxisParam(o,i.shape)[0],d=a.backend_util.prepareSplitSize(i,s,u),p=new Array(i.shape.length).fill(0),c=i.shape.slice();return d.map((function(e){var a=l(c);a[u]=e;var t=je({inputs:{x:i},backend:r,attrs:{begin:p,size:a}});return p[u]+=e,t}))}},ei={kernelName:a.Square,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=a.x,n=t;p(r,"square");for(var i=n.data.get(r.dataId).values,s=new Float32Array(i.length),o=0;o<i.length;++o){var u=i[o];s[o]=u*u}return{dataId:n.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},ai=C(a.Step,(function(e,a){var t=a;return isNaN(e)?NaN:e>0?1:t.alpha})),ti={kernelName:a.Step,backendName:"cpu",kernelFunc:ai};var ri={kernelName:a.StridedSlice,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=n.begin,o=n.end,u=n.strides,d=n.beginMask,l=n.endMask,c=n.ellipsisMask,f=n.newAxisMask,h=n.shrinkAxisMask;p(i,"stridedSlice");var m,v=a.slice_util.sliceInfo(i.shape,s,o,u,d,l,c,f,h),k=v.finalShapeSparse,g=v.finalShape,b=v.isIdentity,I=v.sliceDim0,y=v.isSimpleSlice,N=v.begin,x=v.end,S=v.strides;if(b)m=_a({inputs:{x:i},backend:r,attrs:{shape:g}});else if(I||y){a.util.assert(i.shape.length>=1,(function(){return"Input must have rank at least 1, got: "+i.shape.length}));var T=a.slice_util.computeOutShape(N,x,S),F=je({inputs:{x:i},backend:r,attrs:{begin:N,size:T}});m=_a({inputs:{x:F},backend:r,attrs:{shape:g}}),r.disposeIntermediateTensorInfo(F)}else{var M=ra(k,r.bufferSync(i),S,N);m=r.makeTensorInfo(g,M.dtype,M.values)}return m}};var ni={kernelName:a.StringNGrams,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=r.separator,i=r.nGramWidths,s=r.leftPad,o=r.rightPad,u=r.padWidth,l=r.preserveShortSequences,p=a.data,c=a.dataSplits,f=d(ia(t.data.get(p.dataId).values,t.data.get(c.dataId).values,n,i,s,o,u,l),2),h=f[0],m=f[1];return[t.makeTensorInfo([h.length],"string",h),t.makeTensorInfo(c.shape,"int32",m)]}};var ii={kernelName:a.StringSplit,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs.skipEmpty,n=a.input,i=a.delimiter;if("string"!==n.dtype)throw new Error("Input must be of datatype string");if(1!==n.shape.length)throw new Error("Input must be a vector, got shape: "+n.shape);if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: "+i.shape);var s=d(oa(t.data.get(n.dataId).values,t.data.get(i.dataId).values[0],r),3),o=s[0],u=s[1],l=s[2],p=u.length;return[t.makeTensorInfo([p,2],"int32",o),t.makeTensorInfo([p],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(l))]}};var si={kernelName:a.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs.numBuckets,n=a.input;if("string"!==n.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");var i=ua(t.data.get(n.dataId).values,r);return t.makeTensorInfo(n.shape,"int32",i)}},oi=C(a.Tan,(function(e){return Math.tan(e)})),ui={kernelName:a.Tan,backendName:"cpu",kernelFunc:oi},di=C(a.Tanh,(function(e){return Math.tanh(e)})),li={kernelName:a.Tanh,backendName:"cpu",kernelFunc:di};var pi={kernelName:a.Tile,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.x,i=r.reps;p(n,"tile");var s=fa(t.bufferSync(n),i);return t.makeTensorInfo(s.shape,s.dtype,s.values)}};var ci={kernelName:a.TopK,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.x,i=r.k,s=r.sorted;p(n,"topk");var o=d(va(t.data.get(n.dataId).values,n.shape,n.dtype,i,s),2),u=o[0],l=o[1];return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}};var fi={kernelName:a.Transform,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.attrs,n=e.backend,i=t.image,s=t.transforms,o=r.interpolation,u=r.fillMode,l=r.fillValue,p=r.outputShape,c=d(i.shape,4),f=c[0],h=c[1],m=c[2],v=c[3],k=d(null!=p?p:[h,m],2),g=k[0],b=k[1],I=[f,g,b,v],y=a.util.computeStrides(i.shape),N=y[0],x=y[1],S=y[2],T=a.util.getTypedArrayFromDType(i.dtype,a.util.sizeFromShape(I));T.fill(l);for(var F=n.data.get(i.dataId).values,M=n.data.get(s.dataId).values,A=0;A<f;++A){for(var w=1===s.shape[0]?M:M.subarray(8*A,8*A+8),D=0;D<g;++D)for(var _=0;_<b;++_)for(var E=0;E<v;++E){var z=void 0,W=w[6]*_+w[7]*D+1;if(0!==W){var C=(w[0]*_+w[1]*D+w[2])/W,H=(w[3]*_+w[4]*D+w[5])/W,P=hi(C,m,u),R=hi(H,h,u);switch(o){case"nearest":z=vi(F,h,m,N,x,S,A,R,P,E,l);break;case"bilinear":z=ki(F,h,m,N,x,S,A,R,P,E,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+o)}T[A*N+D*x+_*S+E]=z}}return n.makeTensorInfo(I,i.dtype,T)}return{dataId:n.write(T,I,i.dtype),shape:i.shape,dtype:i.dtype}}};function hi(e,t,r){switch(r){case"reflect":return function(e,t){var r=e;if(r<0){if(t<=1)r=0;else r<(n=2*t)&&(r=n*Math.trunc(-r/n)+r),r=r<-t?r+n:-r-1}else if(r>t-1){var n;if(t<=1)r=0;else(r-=(n=2*t)*Math.trunc(r/n))>=t&&(r=n-r-1)}return a.util.clamp(0,r,t-1)}(e,t);case"wrap":return function(e,t){var r=e;if(r<0)if(t<=1)r=0;else{var n=t-1;r+=t*(Math.trunc(-r/n)+1)}else if(r>t-1)if(t<=1)r=0;else{n=t-1;r-=t*Math.trunc(r/n)}return a.util.clamp(0,r,t-1)}(e,t);case"nearest":return function(e,t){return a.util.clamp(0,e,t-1)}(e,t);case"constant":default:return function(e,a){return e}(e)}}function mi(e,a,t,r,n,i,s,o,u,d,l){return 0<=o&&o<a&&0<=u&&u<t?e[s*r+o*n+u*i+d]:l}function vi(e,a,t,r,n,i,s,o,u,d,l){return mi(e,a,t,r,n,i,s,Math.round(o),Math.round(u),d,l)}function ki(e,a,t,r,n,i,s,o,u,d,l){var p=Math.floor(o),c=Math.floor(u),f=p+1,h=c+1;return(f-o)*((h-u)*mi(e,a,t,r,n,i,s,p,c,d,l)+(u-c)*mi(e,a,t,r,n,i,s,p,h,d,l))+(o-p)*((h-u)*mi(e,a,t,r,n,i,s,f,c,d,l)+(u-c)*mi(e,a,t,r,n,i,s,f,h,d,l))}var gi={kernelName:a.Unique,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.attrs,r=e.backend,n=t.axis,i=a.x;p(i,"unique");var s=ka(r.data.get(i.dataId).values,n,i.shape,i.dtype),o=s.outputValues,u=s.outputShape,d=s.indices;return[r.makeTensorInfo(u,i.dtype,o),r.makeTensorInfo([d.length],"int32",d)]}};var bi={kernelName:a.Unpack,backendName:"cpu",kernelFunc:function(e){var a=e.inputs,t=e.backend,r=e.attrs,n=a.value,i=r.axis;i<0&&(i+=n.shape.length);for(var s=n.shape.length,o=n.shape[i],u=new Array(s-1),d=0,l=0;l<s;l++)l!==i&&(u[d++]=n.shape[l]);var p=new Array(s).fill(0),c=n.shape.slice();c[i]=1;var f=new Array(o);for(l=0;l<f.length;l++){p[i]=l;var h=je({inputs:{x:n},backend:t,attrs:{begin:p,size:c}});f[l]=_a({inputs:{x:h},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(h)}return f}};var Ii,yi,Ni={kernelName:a.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,n=e.attrs,i=t.x,s=t.segmentIds,o=n.numSegments;p(i,"unsortedSegmentSum");for(var u=[],d=[],l=i.shape.length-s.shape.length,c=s,f=0;f<l;++f){var h=tr({inputs:{input:c},backend:r,attrs:{dim:f+1}});c=h,d.push(h)}for(f=0;f<o;++f){var m=a.util.createScalarValue(f,"int32"),v=r.makeTensorInfo([],"int32",m),k=L({inputs:{a:v,b:c},backend:r}),g=S({inputs:{x:k},backend:r,attrs:{dtype:"float32"}}),b=Fe({inputs:{a:g,b:i},backend:r}),I=qt({inputs:{x:b},backend:r,attrs:{axis:0,keepDims:!1}});u.push(I),d.push(v),d.push(k),d.push(g),d.push(b),d.push(I)}var y=hn({inputs:u,backend:r,attrs:{axis:0}});return d.forEach((function(e){return r.disposeIntermediateTensorInfo(e)})),y}},xi=[Ca,m,Pa,Ba,_,Oa,Ga,La,Va,qa,ja,Ka,Ja,$a,at,it,st,ot,ut,Wa,dt,lt,pt,ct,T,B,ht,g,mt,bt,yt,Nt,xt,St,Tt,Ft,At,Dt,_t,Et,zt,Wt,Ct,Pt,Rt,Bt,Ot,Gt,Lt,Vt,jt,Ia,Zt,V,ar,j,rr,Y,lr,cr,fr,X,vr,kr,gr,br,Ir,re,se,y,yr,kt,xr,Tr,Mr,Na,de,ce,Ar,ve,Dr,zr,Cr,Rr,Br,Or,Lr,Ie,Vr,qr,Ur,jr,Zr,Kr,Yr,xe,Jr,$r,tn,Me,we,nn,on,dn,Ee,ln,fn,mn,vn,bn,Ta,Pe,In,x,sr,Nn,Ma,wa,Ea,xn,Sn,Tn,Fn,Mn,An,Dn,Ge,En,zn,Pn,qe,Bn,Gn,Vn,Ze,an,jn,Zn,Kn,Yn,Jn,Qn,Xn,$n,$e,ei,ta,ti,ri,ni,ii,si,ca,Ut,ui,li,pi,ci,fi,Ce,gi,bi,Ni,cn];try{for(var Si=u(xi),Ti=Si.next();!Ti.done;Ti=Si.next()){var Fi=Ti.value;a.registerKernel(Fi)}}catch(e){Ii={error:e}}finally{try{Ti&&!Ti.done&&(yi=Si.return)&&yi.call(Si)}finally{if(Ii)throw Ii.error}}e.MathBackendCPU=f,e.shared=ga,e.version_cpu="3.15.0",Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-cpu.min.js.map
